WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:00.399 --> 00:00:06.477
Can an application be a monolith and microservices

00:00:06.560 --> 00:00:08.879
at the same time?

00:00:09.559 --> 00:00:14.119
In this talk, we will prove that it can be done.

00:00:14.719 --> 00:00:19.956
It's mostly demos, but we also need a bit of

00:00:20.039 --> 00:00:24.440
information to align on the subject.

00:00:24.880 --> 00:00:26.997
Let me first ask you a question.

00:00:27.080 --> 00:00:31.599
Is there anybody who does not know who Erwin

00:00:31.920 --> 00:00:34.040
SchrÃ¶dinger was?

00:00:35.040 --> 00:00:38.039
Well, okay, I will tell you.

00:00:38.719 --> 00:00:44.239
Erwin SchrÃ¶dinger was a scientist who created a

00:00:44.719 --> 00:00:49.279
thought experiment with a cat in a box,

00:00:50.199 --> 00:00:56.197
to illustrate the paradoxes and peculiarities of

00:00:56.280 --> 00:00:58.679
the quantum theory,

00:00:59.199 --> 00:01:04.799
especially the concept of superposition and the

00:01:05.000 --> 00:01:08.240
problem of measurement.

00:01:08.360 --> 00:01:15.396
In other words, things can be in any state until

00:01:15.479 --> 00:01:18.919
you measure it.

00:01:19.759 --> 00:01:26.960
Next, I will show you an example of what he meant.

00:01:27.560 --> 00:01:33.480
I think you recognize this laptop received an update.

00:01:34.000 --> 00:01:36.680
But does it work or is it broken?

00:01:37.200 --> 00:01:41.676
We only know that by opening the laptop and have

00:01:41.759 --> 00:01:43.200
a look.

00:01:43.880 --> 00:01:48.160
This is the same principle as SchrÃ¶dinger's cat.

00:01:48.920 --> 00:01:54.716
But does this also relate to software applications?

00:01:54.799 --> 00:01:58.840
In other words, can we build a SchrÃ¶dinger app?

00:02:00.719 --> 00:02:05.599
Let's dive into it.

00:02:06.439 --> 00:02:07.560
My name is John Meeuwissen.

00:02:08.200 --> 00:02:11.077
I'm 61.

00:02:11.160 --> 00:02:17.399
I started my career way back in 1979 as a mainframe

00:02:17.599 --> 00:02:18.479
programmer.

00:02:18.599 --> 00:02:23.560
I shifted to system programming and later

00:02:24.160 --> 00:02:27.317
software-oriented architecture,

00:02:27.400 --> 00:02:29.200
middleware integrations.

00:02:30.200 --> 00:02:37.839
More recently, I worked in low-code development,

00:02:37.959 --> 00:02:39.960
the back-up product,

00:02:40.400 --> 00:02:46.677
and then shifted to software development,

00:02:46.760 --> 00:02:51.039
full stack and open source with JavaScript,

00:02:52.360 --> 00:02:53.160
TypeScript.

00:02:53.360 --> 00:02:55.319
And personally, I'm a grandfather of 11.

00:03:00.800 --> 00:03:04.757
Let's now first align on the subject by looking at

00:03:04.840 --> 00:03:09.680
some data from market research.

00:03:10.440 --> 00:03:15.757
Apparently, 13% of the companies were not able to

00:03:15.840 --> 00:03:17.200
find us.

00:03:18.080 --> 00:03:24.720
But apart from that, there's one big challenge.

00:03:27.120 --> 00:03:30.397
54% of the companies think that adapting to changing

00:03:30.480 --> 00:03:35.477
client requirements is the biggest challenge of

00:03:35.560 --> 00:03:43.479
software development.

00:03:43.599 --> 00:03:49.800
As we all know, architecture is fundamental.

00:03:49.920 --> 00:03:53.439
And even when the code is set up modular,

00:03:54.840 --> 00:03:58.399
application modules are layered like this,

00:03:59.000 --> 00:04:04.919
like Lego blocks.

00:04:05.439 --> 00:04:10.557
Let us have a look at some problems caused by this

00:04:10.640 --> 00:04:15.440
sort of application development.

00:04:15.560 --> 00:04:20.600
First of all, implementing changes often requires

00:04:20.880 --> 00:04:27.597
refactoring of the application and its architecture.

00:04:27.680 --> 00:04:31.399
The deeper you have to go, the more it hurts.

00:04:31.759 --> 00:04:35.080
In other words, the more Lego blocks you have to

00:04:35.400 --> 00:04:38.200
remove and build up again.

00:04:39.600 --> 00:04:44.917
Secondly, refactoring the architecture basically

00:04:45.000 --> 00:04:50.439
means rebuilding the whole application or at least

00:04:50.759 --> 00:04:56.079
parts of it.

00:04:56.919 --> 00:05:01.120
As we can only design for today and not for

00:05:02.080 --> 00:05:02.720
tomorrow,

00:05:03.080 --> 00:05:06.880
that's giving us a lot of uncertainty.

00:05:07.000 --> 00:05:11.080
When designing the application, we want to make an

00:05:11.960 --> 00:05:15.960
architecture as future-proof as possible.

00:05:16.240 --> 00:05:21.600
So you have the least need to change it in the

00:05:22.400 --> 00:05:22.880
future.

00:05:23.400 --> 00:05:27.477
But how can we make future-proof decisions when the

00:05:27.560 --> 00:05:33.280
direction of the business constantly changes?

00:05:33.720 --> 00:05:39.560
This forces it also constantly to adapt the

00:05:39.880 --> 00:05:45.960
architecture to the current needs.

00:05:46.560 --> 00:05:52.597
But that's giving us a lot of time because of the

00:05:52.680 --> 00:05:56.360
Lego block architecture.

00:06:02.000 --> 00:06:06.556
The continuous architecting.

00:06:06.639 --> 00:06:10.277
Based on the uncertainty in the architecture,

00:06:10.360 --> 00:06:17.077
we are forced to constantly change the architecture.

00:06:17.160 --> 00:06:22.676
In the past years, microservices has been the way

00:06:22.759 --> 00:06:24.560
to go.

00:06:25.400 --> 00:06:28.599
But now, since we know they come with a cost,

00:06:34.319 --> 00:06:51.439
the monolith gains popularity again.

00:06:52.039 --> 00:06:53.439
Modern struggles.

00:06:59.840 --> 00:07:06.840
As microservices bring value in relation to

00:07:08.440 --> 00:07:11.759
scalability and fault tolerance,

00:07:12.039 --> 00:07:17.236
we want to be able to shift our architecture

00:07:17.319 --> 00:07:24.160
towards them and away from them when needed.

00:07:24.680 --> 00:07:26.917
But we don't want to change the architecture

00:07:27.000 --> 00:07:27.680
every time.

00:07:31.520 --> 00:07:41.960
What we think might help is a separation

00:07:42.160 --> 00:07:47.119
of concerns.

00:07:47.479 --> 00:07:51.516
This way, we don't have to bother about

00:07:51.599 --> 00:07:55.157
the architecture at development and

00:07:55.240 --> 00:08:04.240
the possible deployment strategies.

00:08:04.440 --> 00:08:11.439
So what we would like to have is a just-in-time

00:08:11.599 --> 00:08:16.437
architecture deployment model that easily adapts

00:08:16.520 --> 00:08:18.319
to our needs.

00:08:18.919 --> 00:08:25.399
So develop as a monolith and deploy it in any

00:08:26.159 --> 00:08:28.559
shape you need or like.

00:08:30.199 --> 00:08:38.876
But this requires the application to be in

00:08:38.959 --> 00:08:45.559
a strong modular structure.

00:08:45.839 --> 00:08:52.520
This is an example of an application structure

00:08:52.800 --> 00:08:57.679
that strongly adapts to the just-in-time

00:08:58.440 --> 00:09:03.880
architecture style.

00:09:04.480 --> 00:09:10.237
It is decomposed by resource modules like post,

00:09:10.320 --> 00:09:15.999
rating, reaction, etc., and it has the basic

00:09:16.320 --> 00:09:26.160
layering as above.

00:09:26.760 --> 00:09:32.680
This modular application structure allows

00:09:33.240 --> 00:09:40.519
for slicing.

00:09:40.959 --> 00:09:43.360
First of all, vertical slicing.

00:09:43.720 --> 00:09:49.840
This can improve performance and fault tolerance.

00:09:50.120 --> 00:09:53.876
For example, you can load balance over multiple

00:09:53.959 --> 00:10:04.680
split-off modules that are having high load.

00:10:08.600 --> 00:10:13.680
Second, you can separate the impact of failures

00:10:14.040 --> 00:10:19.799
in split-off functions from critical

00:10:20.160 --> 00:10:21.717
basic modules.

00:10:29.720 --> 00:10:34.000
This modular structure also allows for horizontal

00:10:38.000 --> 00:10:38.720
splitting.

00:10:39.000 --> 00:10:44.799
For the same reasons as performance, fault tolerance,

00:10:45.079 --> 00:10:50.760
and security.

00:10:51.120 --> 00:10:54.957
For instance, performance, you can split off the read

00:10:55.040 --> 00:11:02.080
and write operations and separate them in multiple

00:11:03.880 --> 00:11:08.839
segments for performance.

00:11:08.959 --> 00:11:13.040
Or you can improve security by putting the database,

00:11:13.320 --> 00:11:19.759
for instance, in the DMZ.

00:11:20.639 --> 00:11:27.316
Currently, there are two solutions aiming at splitting

00:11:27.399 --> 00:11:33.799
of a modular monolith into different services

00:11:33.920 --> 00:11:35.599
at any time.

00:11:36.279 --> 00:11:39.759
The first one is Service Weaver.

00:11:40.279 --> 00:11:46.760
It's from Google and it strongly focuses on the cloud.

00:11:47.760 --> 00:11:49.600
It supports the Go language.

00:11:49.839 --> 00:11:53.960
They offer a framework and their scope is backend.

00:11:55.519 --> 00:11:57.959
The second option is Jitar.

00:11:58.440 --> 00:12:04.477
That's an abbreviation for Just-in-Time Architecture

00:12:04.560 --> 00:12:09.079
and it's created by Masking Technology.

00:12:09.440 --> 00:12:12.680
It supports JavaScript, TypeScript.

00:12:13.320 --> 00:12:22.080
What we offer is a runtime and our scope is full stack.

00:12:23.000 --> 00:12:27.879
Today's pick will be Jitar.

00:12:28.399 --> 00:12:29.320
Demo time.

00:12:30.320 --> 00:12:36.200
In a moment, I will show you three different

00:12:38.040 --> 00:12:43.720
deployment options.

00:12:44.160 --> 00:12:50.357
The first one will be the monolith by running it as

00:12:50.440 --> 00:12:58.517
a single page segment on the server with only

00:12:58.600 --> 00:13:07.120
the backend for frontend functionality exposed.

00:13:07.560 --> 00:13:13.479
Next, we will split off the notification function

00:13:13.839 --> 00:13:18.799
and later load balance it.

00:13:19.639 --> 00:13:24.759
And finally, we will split off all read and write

00:13:25.600 --> 00:13:29.320
operations and put them in different segments

00:13:29.480 --> 00:13:39.000
on different servers.

00:13:39.440 --> 00:13:44.800
To demonstrate these scenarios, we will make use of

00:13:45.120 --> 00:13:50.120
our showcase application Comify.

00:13:50.800 --> 00:13:53.720
It's a social media app.

00:13:56.880 --> 00:14:04.077
It's a single page responsive application that can run

00:14:04.160 --> 00:14:08.520
on the web browser, tablet, or phone.

00:14:09.120 --> 00:14:16.280
And the technical stack is, it's running on Node.js,

00:14:16.680 --> 00:14:22.637
Jitar of course, React for the web UI and Java,

00:14:22.720 --> 00:14:27.116
TypeScript for the backend, and Keycloak for

00:14:27.199 --> 00:14:31.200
the authentication, Mongo for the database,

00:14:31.560 --> 00:14:38.080
and MinIO for the file system.

00:14:44.320 --> 00:14:45.759
I'm a bit bigger.

00:14:47.079 --> 00:14:47.479
Sorry.

00:14:49.600 --> 00:14:54.760
You have the profile, you have a timeline.

00:14:55.120 --> 00:15:01.279
You can explore for other comics or other creators.

00:15:01.639 --> 00:15:04.159
And here you can see who's following you

00:15:04.360 --> 00:15:06.600
or who you are following.

00:15:06.800 --> 00:15:11.679
If you have a look at there, you can find their comics.

00:15:12.199 --> 00:15:14.599
And you can react with another comic

00:15:15.199 --> 00:15:19.800
or you can react with a comment.

00:15:20.240 --> 00:15:23.159
That's about the application.

00:15:36.360 --> 00:15:36.637
Okay.

00:15:36.720 --> 00:15:44.359
Let's now have a closer look at Jitar.

00:15:46.279 --> 00:15:50.436
It's important to mention that this talk is about

00:15:50.519 --> 00:15:51.839
the concept.

00:15:52.199 --> 00:15:55.319
It's not selling Jitar.

00:15:56.079 --> 00:15:57.639
For two reasons.

00:15:58.079 --> 00:16:00.920
First of all, it's open source anyway.

00:16:01.440 --> 00:16:09.199
And secondly, it's not ready for production yet.

00:16:11.680 --> 00:16:12.000
Okay.

00:16:13.759 --> 00:16:19.477
Well, Jitar is a runtime we deliver and important

00:16:19.560 --> 00:16:23.519
thing is that it automates all client-server

00:16:24.040 --> 00:16:27.360
communication based on segments.

00:16:27.720 --> 00:16:30.679
It supports end-to-end type safety.

00:16:31.199 --> 00:16:35.719
And maybe most important, it's by configuration only.

00:16:36.319 --> 00:16:41.000
So there's not a single line of Jitar code in your

00:16:41.199 --> 00:16:43.519
application code.

00:16:44.199 --> 00:16:49.039
It also brings some powerful features like

00:16:49.440 --> 00:16:50.357
segmentation.

00:16:50.440 --> 00:16:53.880
So you can split up your application in any

00:16:54.399 --> 00:16:59.119
deployable part and deploy it distributed.

00:17:01.120 --> 00:17:05.239
It also does orchestration over the segmented

00:17:07.199 --> 00:17:07.919
functions.

00:17:08.400 --> 00:17:21.559
And it automatically does load balancing.

00:17:21.839 --> 00:17:26.759
Now, I'm going to show you the different scenarios.

00:17:35.360 --> 00:17:39.716
First of all, currently the application is running

00:17:39.799 --> 00:17:42.560
in, like I said, a standalone mode.

00:17:43.200 --> 00:17:48.640
So everything is in one single segment.

00:17:50.000 --> 00:17:57.517
Well, what Jitar does, it works with segments,

00:17:57.600 --> 00:17:58.319
like I said.

00:18:04.440 --> 00:18:08.399
By the way, is it readable for everybody?

00:18:08.679 --> 00:18:10.119
Also in the back?

00:18:14.280 --> 00:18:14.600
Okay.

00:18:15.280 --> 00:18:22.439
Well, I will first introduce the segments.

00:18:22.799 --> 00:18:27.680
The segments contain what will be split up.

00:18:29.200 --> 00:18:34.280
This is, for instance, the BFF segment.

00:18:34.720 --> 00:18:39.120
Here you expose all your features that you want to

00:18:40.679 --> 00:18:41.239
publish.

00:18:41.679 --> 00:18:46.959
And with access is public, then everybody can use it.

00:18:47.799 --> 00:18:49.520
There's also private.

00:18:49.880 --> 00:18:52.677
That means that this function can only be called

00:18:52.760 --> 00:18:57.200
within the segment.

00:18:57.640 --> 00:19:00.757
I also have some other segment files I prepared for

00:19:00.840 --> 00:19:03.040
the demo.

00:19:03.720 --> 00:19:06.080
Then we have services.

00:19:06.440 --> 00:19:09.840
Like I said, I now run the application with

00:19:11.559 --> 00:19:12.359
standalone.

00:19:12.559 --> 00:19:15.600
And then you can see it will start up the node,

00:19:15.760 --> 00:19:18.839
the gateway, repository, everything.

00:19:19.280 --> 00:19:23.560
And it loads a segment that that's the BFF.

00:19:24.240 --> 00:19:27.000
So that's the only one.

00:19:27.760 --> 00:19:38.800
But now, and like I said, this is running currently.

00:19:39.080 --> 00:19:42.480
And you can see, like I showed, it works.

00:19:44.760 --> 00:19:51.640
Now, I'm going to split off the notifications.

00:19:52.000 --> 00:20:03.440
So I have to make this segment available for Jitar.

00:20:03.960 --> 00:20:07.197
Because it takes all the segment files that are

00:20:07.280 --> 00:20:10.960
called JSON, segment or JSON.

00:20:20.240 --> 00:20:20.560
Okay.

00:20:21.720 --> 00:20:28.880
Then, changing segments, you always need to rebuild

00:20:29.280 --> 00:20:45.360
the application.

00:20:45.480 --> 00:20:45.720
Now.

00:21:05.200 --> 00:21:05.440
Yes.

00:21:06.200 --> 00:21:24.560
As you can see, it now builds the BFF segment only.

00:21:25.240 --> 00:21:25.480
No.

00:21:48.000 --> 00:21:48.320
Yeah.

00:21:49.000 --> 00:21:52.716
Here you can now see it built the notification

00:21:52.799 --> 00:21:55.160
and the BFF segment.

00:21:55.760 --> 00:21:56.160
Okay.

00:21:56.760 --> 00:22:09.236
Then we have to start up.

00:22:09.319 --> 00:22:18.760
The repository first.

00:22:27.600 --> 00:22:28.000
Okay.

00:22:33.200 --> 00:22:40.359
Then run the gateway.

00:22:40.799 --> 00:22:46.240
Then run the proxy.

00:22:46.840 --> 00:22:50.760
And then run the BFF segment.

00:22:51.200 --> 00:22:57.280
But we now also have a notification segment.

00:22:57.720 --> 00:23:00.559
So you also need this.

00:23:01.159 --> 00:23:04.237
And you can see he exposes the notification segment,

00:23:04.320 --> 00:23:08.760
the notification features.

00:23:09.120 --> 00:23:11.560
If we now go back,

00:23:12.240 --> 00:23:17.319
you will see that the application still works.

00:23:17.919 --> 00:23:23.716
And now if I ask for notifications,

00:23:23.799 --> 00:23:27.719
you will see that suddenly the notification segment

00:23:28.159 --> 00:23:32.839
gets a call for his feature.

00:23:33.279 --> 00:23:37.640
And the rest is just running in the BFF.

00:23:38.400 --> 00:23:38.800
Okay.

00:23:40.840 --> 00:23:50.119
Now, I will start second notification segment.

00:23:51.120 --> 00:23:56.080
And if I look at the gateway here,

00:23:56.760 --> 00:24:00.760
you will say, "Hey, I added a worker."

00:24:01.200 --> 00:24:04.596
So the segment is automatically registered

00:24:04.679 --> 00:24:12.319
at the gateway and will run it.

00:24:13.159 --> 00:24:20.560
If we now go back and run notifications again,

00:24:21.080 --> 00:24:27.760
you will see that it went to the other segment.

00:24:28.200 --> 00:24:30.360
And if you do it again,

00:24:30.960 --> 00:24:34.240
you'll see it went to the first segment again.

00:24:34.840 --> 00:24:35.560
And so on.

00:24:36.159 --> 00:24:42.839
Round robin load balancing automatically.

00:24:44.159 --> 00:24:52.840
Now, I will split off the reads and the writes also.

00:24:53.520 --> 00:25:16.399
So I have to make them active segments for data.

00:25:17.159 --> 00:25:21.080
I have to stop all the workers.

00:25:34.440 --> 00:25:48.919
And now I can rebuild the application.

00:25:49.039 --> 00:25:51.840
And you will now see that he built four segments.

00:25:59.240 --> 00:26:05.760
And then, oh, sorry.

00:26:06.360 --> 00:26:20.439
I have to start all the workers again.

00:26:21.039 --> 00:26:22.956
I have to run the BFF again.

00:26:39.679 --> 00:26:47.200
Yes, so run the BFF.

00:26:47.960 --> 00:26:51.400
Run the notifications again.

00:26:52.000 --> 00:26:56.799
And now we have new segments.

00:26:57.159 --> 00:26:58.400
We have to start the reads.

00:27:02.399 --> 00:27:06.480
And you have to start the writes.

00:27:07.000 --> 00:27:16.919
And if we now go back, it still works as if nothing

00:27:18.960 --> 00:27:19.600
happened.

00:27:19.960 --> 00:27:24.956
But if you now look, you will see that here,

00:27:25.039 --> 00:27:26.880
this is the read segment.

00:27:27.240 --> 00:27:33.040
It will suddenly get all the reads.

00:27:33.640 --> 00:27:41.917
And you can see that again, the notifications are sent

00:27:42.000 --> 00:27:49.799
to the single notification segment again.

00:27:50.399 --> 00:27:57.236
And if we for instance say, "I like this post,"

00:27:57.319 --> 00:28:05.040
a notification will be created.

00:28:05.480 --> 00:28:09.880
So indeed, you will see here in the write segment

00:28:12.120 --> 00:28:12.760
activity.

00:28:14.720 --> 00:28:18.360
Well, but talk is cheap.

00:28:18.960 --> 00:28:21.400
Let's show me the code.

00:28:22.080 --> 00:28:22.480
Okay.

00:28:35.000 --> 00:28:43.600
Time to take a look at the state of the application.

00:28:45.120 --> 00:28:52.680
There are a number of things you have to stick to

00:28:53.440 --> 00:28:54.799
to make it possible.

00:29:00.799 --> 00:29:09.320
How you set up your application code is important

00:29:09.600 --> 00:29:11.760
to make it work this way.

00:29:15.679 --> 00:29:20.076
So if we look, we have web UI containing all

00:29:20.159 --> 00:29:23.319
the React components.

00:29:23.519 --> 00:29:28.160
We have integrations containing all our integrations

00:29:28.279 --> 00:29:34.320
like Keycloak, Mongo, MinIO, et cetera.

00:29:35.080 --> 00:29:37.320
And we have of course the assets.

00:29:37.840 --> 00:29:42.440
And on the domain level, the highest level is features.

00:29:42.720 --> 00:29:47.839
It's all containing a single feature.

00:29:48.279 --> 00:29:52.840
It's modular.

00:29:53.440 --> 00:29:58.357
And it's in, that's about the architecture.

00:29:58.440 --> 00:30:00.440
It's a modular design.

00:30:00.960 --> 00:30:03.399
The highest level is feature and in React,

00:30:03.640 --> 00:30:11.199
in the web UI, it are all React components.

00:30:11.399 --> 00:30:14.920
Then the database management.

00:30:15.120 --> 00:30:19.037
One important thing, we only can work with

00:30:19.120 --> 00:30:22.760
immutable objects.

00:30:23.279 --> 00:30:27.759
And there must be no relation in the database.

00:30:30.519 --> 00:30:35.279
Referential integrity is in the application.

00:30:35.399 --> 00:30:54.760
And to support that, we work with sagas.

00:30:55.799 --> 00:31:07.239
Yes, this is an example of the add of post with the saga.

00:31:07.919 --> 00:31:14.559
Then for security, for access, we have Keycloak

00:31:14.919 --> 00:31:16.079
with OpenID.

00:31:18.000 --> 00:31:23.157
The security of the data, we have an authorization

00:31:23.240 --> 00:31:24.597
model of ownership.

00:31:24.680 --> 00:31:28.157
It means you can see everything, but you can only

00:31:28.240 --> 00:31:30.799
change what's yours.

00:31:31.399 --> 00:31:36.479
And we make use of data aggregation for the BFF.

00:31:37.159 --> 00:31:41.639
So that means we aggregate all data for the web UI.

00:31:42.399 --> 00:31:46.357
So you only have to show to them what you would like

00:31:46.440 --> 00:31:47.080
them to see.

00:31:47.639 --> 00:31:51.237
Things you don't want to expose to them, you can just

00:31:51.320 --> 00:31:55.439
leave them out of the aggregation.

00:31:55.559 --> 00:31:55.959
Okay.

00:31:56.240 --> 00:32:02.877
And function calls are secured by the code so-called

00:32:02.960 --> 00:32:05.519
Jitar trust key.

00:32:06.279 --> 00:32:15.640
That's a trust key to specify at the cluster level.

00:32:16.240 --> 00:32:20.920
Let's have a look.

00:32:21.600 --> 00:32:24.760
No, sorry.

00:32:25.440 --> 00:32:26.759
It's in the services.

00:32:43.240 --> 00:32:43.480
Yes.

00:32:44.240 --> 00:32:46.080
Here, we have a trust key.

00:32:48.720 --> 00:32:52.599
That's used on the cluster level of Jitar.

00:32:53.039 --> 00:33:00.600
And it makes sure that every function call will be

00:33:03.559 --> 00:33:10.040
checked if it has access mode protected.

00:33:10.480 --> 00:33:14.076
The function can only be called if the caller has

00:33:14.159 --> 00:33:17.039
the same trust key.

00:33:17.799 --> 00:33:22.160
And again, the function will only run if the caller

00:33:22.600 --> 00:33:26.760
also has the same trust key as the segment has.

00:33:27.399 --> 00:33:36.199
So that's how we secure function calls.

00:33:41.080 --> 00:33:48.316
So, as you can see here, this is for the post that

00:33:48.399 --> 00:33:54.319
all on feature level.

00:33:56.279 --> 00:33:58.600
So that's about it.

00:33:58.919 --> 00:34:04.879
Are there any questions?

00:34:07.000 --> 00:34:24.356
You have a microphone?

00:34:24.630 --> 00:34:26.783
So my question is, those constraints, how are they

00:34:26.893 --> 00:34:33.996
For example, if I import the database directly from

00:34:34.079 --> 00:34:37.800
a place I shouldn't be, will the...

00:34:38.000 --> 00:34:41.556
Because I presume we have to compile it to something

00:34:41.639 --> 00:34:42.200
first, right?

00:34:43.800 --> 00:34:45.796
No, just build your application.

00:34:45.879 --> 00:34:46.559
Yeah, okay.

00:34:46.760 --> 00:34:49.996
When you build, will I be warned if I import

00:34:50.079 --> 00:34:51.839
something that I shouldn't be?

00:35:00.640 --> 00:35:08.477
We work with integrations and the database is not

00:35:08.560 --> 00:35:10.200
dynamically imported.

00:35:10.560 --> 00:35:14.397
It's imported when you build your application.

00:35:14.480 --> 00:35:19.040
You make somewhere an import of the database.

00:35:19.400 --> 00:35:21.560
But that's in a function.

00:35:21.920 --> 00:35:23.760
And you can...

00:35:24.520 --> 00:35:31.200
That function is protected by the Jitar trust key.

00:35:31.880 --> 00:35:32.317
Okay, I see.

00:35:32.400 --> 00:35:36.276
So basically, the function that you showed us in the

00:35:36.359 --> 00:35:39.516
ðšðšŽðšŠðšðšžðš›ðšŽ.ðšðšœ, that basically gets injected all the

00:35:39.599 --> 00:35:41.557
dependencies that it needs, and we access it through

00:35:41.640 --> 00:35:44.277
the object that gets passed to the function?

00:35:44.360 --> 00:35:44.557
Yeah.

00:35:44.640 --> 00:35:49.920
Well, all functions are exposed default, exported

00:35:50.119 --> 00:35:50.759
default.

00:35:51.400 --> 00:35:54.520
And you just do the imports in every function.

00:35:54.720 --> 00:35:57.200
You do the import that you needs over there.

00:35:59.400 --> 00:36:00.679
Yes? I see, I see.

00:36:00.839 --> 00:36:05.960
And in the segment, you only specify the features

00:36:06.240 --> 00:36:11.480
that you want to expose public to the BFF or

00:36:13.280 --> 00:36:18.400
protected, so only within the application.

00:36:18.520 --> 00:36:25.837
And that way, the databases database access is

00:36:25.920 --> 00:36:26.640
protected.

00:36:26.800 --> 00:36:27.036
I see.

00:36:27.119 --> 00:36:29.557
So if I do something I shouldn't, the build is going

00:36:29.640 --> 00:36:32.039
to fail, basically.

00:36:32.319 --> 00:36:35.640
The build when you do npm run build is going to fail?

00:36:36.680 --> 00:36:39.840
Or is it going to fail during runtime?

00:36:41.040 --> 00:36:45.880
Well, which protection of the database do you mean?

00:36:47.520 --> 00:36:52.157
You mentioned that the database access is protected

00:36:52.240 --> 00:36:53.880
by some keys, right?

00:36:55.119 --> 00:37:01.920
And let's say I violated some of the rules identified

00:37:02.200 --> 00:37:04.797
defined by Jitar in the configuration, in some of

00:37:04.880 --> 00:37:05.519
the JSON.

00:37:06.119 --> 00:37:11.880
And then if that were to happen, will the build fail

00:37:12.240 --> 00:37:15.597
during build, or will the application fail when

00:37:15.680 --> 00:37:17.120
someone calls that function?

00:37:18.960 --> 00:37:20.516
I don't quite understand.

00:37:20.599 --> 00:37:26.236
I mean, you import databases in one of the functions

00:37:26.319 --> 00:37:28.359
of your application, yes?

00:37:29.720 --> 00:37:35.236
Well, if that import works, then the database

00:37:35.319 --> 00:37:38.959
connection is only available to that function.

00:37:40.040 --> 00:37:46.996
And that function can only be called by trusted other

00:37:47.079 --> 00:37:48.520
functions that call it.

00:37:48.839 --> 00:37:49.439
Oh, I see.

00:37:49.560 --> 00:37:50.920
Okay, yeah, I get it.

00:37:51.240 --> 00:37:54.759
Yeah, you never can go directly to the database.

00:37:55.119 --> 00:37:55.519
Okay.

00:37:55.640 --> 00:37:59.437
You only call database functions, and they really go

00:37:59.520 --> 00:38:00.479
to the database.

00:38:00.720 --> 00:38:01.877
Yeah, okay, I got it.

00:38:01.960 --> 00:38:07.240
Thank you.

00:38:10.280 --> 00:38:10.600
Okay.

00:38:12.800 --> 00:38:15.360
So, any more questions?

00:38:15.560 --> 00:38:15.800
No?

00:38:16.599 --> 00:38:23.920
Well, let me show you one more thing.

00:38:37.000 --> 00:38:37.600
Thank you.

00:38:46.119 --> 00:38:52.317
And for those who like Mr. SchrÃ¶dinger, there was a

00:38:52.400 --> 00:38:53.999
little cartoon I found.
