WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:02.919 --> 00:00:08.640
I hope you guys have great experience for this conference.

00:00:08.840 --> 00:00:12.600
I love seeing you in offline event like this,

00:00:13.759 --> 00:00:16.160
after years of pandemic.

00:00:17.080 --> 00:00:18.397
Let me introduce myself.

00:00:18.480 --> 00:00:18.973
My name is Riza.

00:00:19.056 --> 00:00:25.400
I'm co-founder of Hacktiv8, coding bootcamp in Indonesia.

00:00:25.680 --> 00:00:29.537
Today I will talk about HTML over the wire.

00:00:29.620 --> 00:00:32.717
There is a new concept, not so new,

00:00:32.800 --> 00:00:35.476
but maybe you haven't know that.

00:00:35.559 --> 00:00:42.040
But before that, let's roll back the time

00:00:42.280 --> 00:00:46.599
to see the history how web page render.

00:00:47.039 --> 00:00:49.239
And then we go to the present,

00:00:50.120 --> 00:00:53.276
we talk about multi-page application

00:00:53.359 --> 00:00:54.996
and single-page application.

00:00:55.079 --> 00:00:58.917
And then hopefully we can go to the future

00:00:59.000 --> 00:01:02.120
with HTML over the wire.

00:01:03.440 --> 00:01:07.560
How the page rendering history?

00:01:08.000 --> 00:01:13.400
At the beginning of web in 1990s,

00:01:14.439 --> 00:01:17.040
this is the real static web.

00:01:18.439 --> 00:01:21.320
There is link, blink, and marquee, right?

00:01:23.159 --> 00:01:29.480
You create HTML with your bare hand, with Notepad,

00:01:29.920 --> 00:01:30.837
without syntax highlighting.

00:01:30.920 --> 00:01:34.877
And then there is a code editor like FrontPage

00:01:34.960 --> 00:01:36.716
or Dreamweaver.

00:01:36.799 --> 00:01:37.877
What you see is what you get.

00:01:37.960 --> 00:01:41.000
You can drag and drop a button, a table,

00:01:41.119 --> 00:01:41.917
something like that.

00:01:42.000 --> 00:01:45.237
And then when you save your file in your desktop

00:01:45.320 --> 00:01:47.119
or your computer,

00:01:47.320 --> 00:01:52.520
then you have to transfer via FTP.

00:01:53.200 --> 00:01:56.556
And when user access your website,

00:01:56.639 --> 00:02:00.799
it's actually they read the file that you save

00:02:02.079 --> 00:02:07.639
from server and web browser will render the page.

00:02:08.239 --> 00:02:11.200
That's in 1990s.

00:02:11.800 --> 00:02:17.320
In 2000s, web getting dynamic.

00:02:18.720 --> 00:02:21.959
For example, this is early days of Twitter.

00:02:22.640 --> 00:02:24.319
It's not real time yet.

00:02:24.560 --> 00:02:27.719
You have to refresh to get a new data, right?

00:02:28.920 --> 00:02:32.317
At this era, Internet Explorer and Firefox

00:02:32.400 --> 00:02:35.000
is the OG of web browser.

00:02:35.440 --> 00:02:39.760
And the late 2000s, specifically 2008,

00:02:41.840 --> 00:02:47.717
Google fork the engine from WebKit or Safari,

00:02:47.800 --> 00:02:51.200
as we know it, and make a Google Chrome.

00:02:51.640 --> 00:02:53.436
The main selling point of the browser

00:02:53.519 --> 00:02:57.277
is multi-process browser.

00:02:57.360 --> 00:03:01.316
So you can running something in background,

00:03:01.399 --> 00:03:08.000
so the browser will getting more powerful.

00:03:08.360 --> 00:03:14.557
And a year before, Apple also introduced the iPhone,

00:03:14.640 --> 00:03:15.719
the first iPhone.

00:03:16.159 --> 00:03:18.720
There is no App Store yet.

00:03:19.440 --> 00:03:24.959
So if you want running an app or you like some website,

00:03:25.200 --> 00:03:27.320
you can open it in Safari Mobile

00:03:27.760 --> 00:03:29.560
and you add to home screen,

00:03:30.120 --> 00:03:37.479
like we do now for progressive web apps.

00:03:38.239 --> 00:03:43.480
We go to 2010s.

00:03:44.080 --> 00:03:49.239
The trend that Google Chrome started continue

00:03:49.640 --> 00:03:53.079
and browser getting more powerful.

00:03:53.840 --> 00:03:57.879
But web application is also getting more complex.

00:04:01.120 --> 00:04:07.279
You can book hotel or flight.

00:04:07.799 --> 00:04:12.959
You can view some users' videos with YouTube.

00:04:13.200 --> 00:04:17.800
You can listen to the music and everything else.

00:04:18.320 --> 00:04:22.237
Collaboration also happen in this browser,

00:04:22.320 --> 00:04:25.480
in your browser, like Google Docs or even Figma.

00:04:28.880 --> 00:04:36.360
So to do that, we believe that all the changes

00:04:36.800 --> 00:04:39.360
should happen in the client, in the browser.

00:04:39.720 --> 00:04:42.920
So at first server just send the blank HTML

00:04:43.440 --> 00:04:47.559
like div with ID root, without any content.

00:04:47.840 --> 00:04:52.000
And then the client will fetch the data

00:04:52.440 --> 00:04:56.079
and update the page.

00:04:56.759 --> 00:05:02.157
In this era, also known as a frontend framework

00:05:02.240 --> 00:05:10.680
as Angular, React, Vue, and others was born.

00:05:11.360 --> 00:05:15.520
And then web app getting more too dynamic.

00:05:15.880 --> 00:05:19.999
We got data from everywhere.

00:05:20.199 --> 00:05:22.520
And information overload.

00:05:23.680 --> 00:05:26.597
Maybe for some users, browser is not good enough,

00:05:26.680 --> 00:05:28.199
not powerful enough.

00:05:28.520 --> 00:05:32.440
Because maybe we open it on our mobile

00:05:33.639 --> 00:05:36.280
with limited internet connection.

00:05:39.000 --> 00:05:43.599
So the experience is not the same for all users.

00:05:44.000 --> 00:05:46.960
Different from desktop, tablet, mobile,

00:05:47.160 --> 00:05:49.560
and maybe low-end device.

00:05:51.160 --> 00:05:57.880
And meanwhile, JavaScript framework getting more size.

00:05:58.560 --> 00:06:01.676
And sometimes bloated.

00:06:01.759 --> 00:06:03.840
And our apps become like this:

00:06:04.080 --> 00:06:09.277
unresponsive, janky, and not a good user experience.

00:06:09.360 --> 00:06:12.000
We welcome to SPAlgeddon era.

00:06:14.400 --> 00:06:16.437
So turns out, single-page application

00:06:16.520 --> 00:06:20.717
that we introduced in 2010s

00:06:20.800 --> 00:06:24.720
is giving us a new problem.

00:06:25.160 --> 00:06:26.639
First, complexity.

00:06:26.759 --> 00:06:31.676
Logic, we have logic both in server and the client.

00:06:31.759 --> 00:06:38.516
State also in the server and in client.

00:06:38.599 --> 00:06:39.719
Authentication.

00:06:41.000 --> 00:06:41.800
Reactivity.

00:06:42.000 --> 00:06:46.440
Compiler, transpiler, getting more complex.

00:06:47.479 --> 00:06:53.600
If you have try how to config with webpack,

00:06:54.360 --> 00:06:57.639
you know what I mean.

00:06:58.664 --> 00:07:01.519
SEO, search engine optimization issue as well,

00:07:02.720 --> 00:07:08.320
not so good for single-page application.

00:07:08.440 --> 00:07:12.516
Then single-page application usually break

00:07:12.599 --> 00:07:16.119
the back and forward navigation.

00:07:16.479 --> 00:07:20.999
And looks like with our frameworks,

00:07:21.199 --> 00:07:24.120
we are going away from web standards.

00:07:24.759 --> 00:07:28.920
Like we have to use this component called link.

00:07:29.520 --> 00:07:32.439
We have anchor, why we use link?

00:07:33.039 --> 00:07:39.519
There's a reason, but we are going away from web standard.

00:07:39.879 --> 00:07:47.116
Then in this era, there are new wave of frameworks

00:07:47.199 --> 00:07:52.521
like Next.js, Nuxt, Astro, Qwik, SvelteKit,

00:07:53.599 --> 00:08:00.437
and React also develop React server component.

00:08:00.520 --> 00:08:03.800
So it's like the trend going back to the server side,

00:08:04.000 --> 00:08:06.559
not the client side.

00:08:07.159 --> 00:08:10.560
As conclusion, we are going from this:

00:08:11.240 --> 00:08:15.599
if we request some file, server will return the file.

00:08:15.960 --> 00:08:26.880
And then if the client asking for one route, /about,

00:08:27.159 --> 00:08:31.480
and then there is a backend for dynamic page.

00:08:32.080 --> 00:08:36.480
Maybe they query the data and they send back as HTML,

00:08:36.959 --> 00:08:43.920
and the web browser will render the page.

00:08:44.600 --> 00:08:49.357
And then the client will be working more hard

00:08:49.440 --> 00:08:52.240
than server for single-page application.

00:08:52.360 --> 00:08:55.037
So if the client request,

00:08:55.120 --> 00:08:57.679
the server will send the blank HTML.

00:08:58.279 --> 00:09:01.996
And usually a spinner,

00:09:02.079 --> 00:09:04.960
and then the client will ask for new data,

00:09:05.600 --> 00:09:09.280
and there is your webpage.

00:09:09.480 --> 00:09:12.920
So you need to wait for data to arrive first,

00:09:13.040 --> 00:09:19.600
and then you can browse the application.

00:09:19.720 --> 00:09:24.680
And last but not least, we have a framework,

00:09:24.880 --> 00:09:27.040
meta framework.

00:09:27.320 --> 00:09:29.597
The difference from single page application

00:09:29.680 --> 00:09:32.760
and meta framework is just the initial page.

00:09:32.959 --> 00:09:37.280
So, at first, they don't send you blank HTML.

00:09:37.640 --> 00:09:42.000
They send you HTML plus data and they will render.

00:09:42.200 --> 00:09:44.037
And after that, it's almost the same.

00:09:44.120 --> 00:09:47.320
Depend on the meta framework and the feature that you use,

00:09:47.519 --> 00:09:49.477
you can use multi-page application as well.

00:09:49.560 --> 00:09:52.280
You can use as single page application as well.

00:09:52.519 --> 00:09:53.996
So, if the data changes,

00:09:54.079 --> 00:09:57.517
the client will request the data

00:09:57.600 --> 00:10:02.000
and the data will send with type JSON

00:10:02.480 --> 00:10:11.440
and the client will re-render the page accordingly.

00:10:12.000 --> 00:10:15.319
Now, what is HTML over the wire?

00:10:15.839 --> 00:10:20.277
It's an alternative to create a dynamic

00:10:20.360 --> 00:10:24.800
and interactive server render web application.

00:10:24.920 --> 00:10:28.959
So, the rendering part will be on the server.

00:10:31.320 --> 00:10:33.756
It utilize the server to render the page

00:10:33.839 --> 00:10:37.400
and send HTML or a representation of HTML

00:10:38.000 --> 00:10:41.280
through HTTP protocol or WebSocket.

00:10:41.560 --> 00:10:44.439
You got fast first loading pages,

00:10:44.639 --> 00:10:47.917
speed and responsiveness associated with

00:10:48.000 --> 00:10:50.436
single page application without the complexity

00:10:50.519 --> 00:10:54.160
of front-end framework.

00:10:54.440 --> 00:10:56.280
You keep the state on the server.

00:10:56.800 --> 00:10:58.360
It's more simpler.

00:10:58.720 --> 00:11:03.957
You remove the data transportation and serialization

00:11:04.040 --> 00:11:05.480
like REST API.

00:11:05.600 --> 00:11:09.080
You don't need REST API, GraphQL, or even gRPC.

00:11:09.760 --> 00:11:11.760
You just serve from the server.

00:11:12.200 --> 00:11:15.040
What is the benefit?

00:11:15.480 --> 00:11:17.640
First, it's server focus.

00:11:18.040 --> 00:11:21.560
So, server generate and send HTML

00:11:22.240 --> 00:11:24.917
or a representation of HTML or the whole page.

00:11:25.000 --> 00:11:25.959
It's up to you.

00:11:26.440 --> 00:11:31.600
Then, this allow developers to focus on server side,

00:11:31.880 --> 00:11:36.957
working primarily in server side language

00:11:37.040 --> 00:11:38.840
that you are familiar with.

00:11:39.160 --> 00:11:41.756
You like Python, you can use Python.

00:11:41.839 --> 00:11:44.757
You like PHP, you can use PHP.

00:11:44.840 --> 00:11:46.957
Offer better SEO, of course,

00:11:47.040 --> 00:11:50.959
and simplify state management.

00:11:51.079 --> 00:11:53.996
Because state management just happen in the server side,

00:11:54.079 --> 00:11:56.560
not in the client side.

00:11:57.240 --> 00:11:58.600
And the logic as well.

00:11:59.760 --> 00:12:04.120
Server will generate the dynamic page.

00:12:04.720 --> 00:12:07.080
Browser just render the HTML and CSS

00:12:07.519 --> 00:12:10.920
with a little bit JavaScript if needed.

00:12:11.440 --> 00:12:13.357
The server will do what it's best.

00:12:13.440 --> 00:12:15.717
It's for calculating, for rendering,

00:12:15.800 --> 00:12:20.240
and the browser will re-render the page.

00:12:20.920 --> 00:12:26.080
It reduce the complexity of client JavaScript framework.

00:12:26.360 --> 00:12:30.440
If you write application that the user

00:12:31.040 --> 00:12:34.320
will use for lower end device or IoT,

00:12:34.880 --> 00:12:40.597
it's also good use case because the processing

00:12:40.680 --> 00:12:43.920
will be on the server, not on the client.

00:12:44.440 --> 00:12:48.160
You don't need to maintain both server code

00:12:48.480 --> 00:12:50.520
and client code base.

00:12:50.680 --> 00:12:54.520
You just write your application in the server.

00:12:55.040 --> 00:12:57.277
Better backward compatibility

00:12:57.360 --> 00:12:59.240
if you support older browser

00:13:00.199 --> 00:13:02.480
and faster initial page loads

00:13:02.959 --> 00:13:06.800
due to reduce JavaScript payloads.

00:13:07.160 --> 00:13:10.279
And we can also make the application

00:13:10.399 --> 00:13:14.600
that works just with HTML and CSS.

00:13:15.360 --> 00:13:17.520
JavaScript if necessary.

00:13:17.800 --> 00:13:22.357
And we can also create a real-time application.

00:13:22.440 --> 00:13:23.637
So, when data changes,

00:13:23.720 --> 00:13:27.359
the server will send the HTML through the wire

00:13:27.959 --> 00:13:35.280
and the client will re-render the page if necessary.

00:13:35.560 --> 00:13:38.237
Rather than sending the raw data

00:13:38.320 --> 00:13:40.400
and to be processed on the client side.

00:13:40.959 --> 00:13:44.277
No need to transport data like I said before,

00:13:44.360 --> 00:13:48.000
REST API or GraphQL or gRPC

00:13:48.160 --> 00:13:51.968
or another transport layer.

00:13:52.051 --> 00:13:52.324
But it has some drawbacks, of course.

00:13:52.407 --> 00:13:59.720
Because it's server focus,

00:14:00.600 --> 00:14:03.440
maybe you need more resource for the server.

00:14:04.120 --> 00:14:08.360
The load for server will increase.

00:14:08.720 --> 00:14:13.240
But compare to the client heavy app,

00:14:13.920 --> 00:14:16.237
it's depend on our server,

00:14:16.320 --> 00:14:18.760
not depend on our users.

00:14:19.360 --> 00:14:23.756
Our user will have the same or similar experience

00:14:23.839 --> 00:14:27.319
for the app because the hard work on the server.

00:14:30.480 --> 00:14:35.037
It's challenging to implement robust offline functionality

00:14:35.120 --> 00:14:37.959
compared to single-page application.

00:14:38.079 --> 00:14:40.957
We need more reliable network connection

00:14:41.040 --> 00:14:42.637
for smooth user experience

00:14:42.720 --> 00:14:46.960
because every time user request some data or some page,

00:14:47.160 --> 00:14:48.477
it will contact the server

00:14:48.560 --> 00:14:50.599
and server will send the HTML.

00:14:51.199 --> 00:14:54.957
And the latency can also affect responsiveness

00:14:55.040 --> 00:14:58.159
especially for user with slow connections.

00:14:59.800 --> 00:15:03.240
And because this is a new concept,

00:15:03.680 --> 00:15:06.359
we have limited third-party libraries.

00:15:06.639 --> 00:15:08.397
Most of the time, we have to build ourselves

00:15:08.480 --> 00:15:10.479
or wrapping another library

00:15:10.720 --> 00:15:13.517
and may need time to adapt and adopt new technique

00:15:13.600 --> 00:15:14.720
and new tools.

00:15:17.880 --> 00:15:23.760
If you draw where the positioning of the concept

00:15:23.920 --> 00:15:26.600
with multi-page application,

00:15:26.720 --> 00:15:30.240
we can develop less complex app, less complex code,

00:15:30.639 --> 00:15:33.480
but the user experience could be better.

00:15:34.000 --> 00:15:37.960
With single-page application, if we done right,

00:15:38.560 --> 00:15:42.360
we can have a good or great user experience,

00:15:42.560 --> 00:15:46.759
but not so good developer experience.

00:15:46.959 --> 00:15:51.080
If we done right. That a big if.

00:15:52.240 --> 00:15:56.436
And HTML over the wire in the between.

00:15:56.519 --> 00:16:01.239
So user experience is good enough for most of the cases,

00:16:02.360 --> 00:16:06.277
but we can use it without the complexity

00:16:06.360 --> 00:16:13.959
of development process.

00:16:14.399 --> 00:16:17.599
The first framework that explore this idea

00:16:17.759 --> 00:16:21.319
is Phoenix LiveView.

00:16:22.120 --> 00:16:25.600
Phoenix is batteries included web framework

00:16:26.560 --> 00:16:31.679
for functional programming language called Elixir.

00:16:32.199 --> 00:16:35.597
You can get fast first load pages speed

00:16:35.680 --> 00:16:39.559
and responsiveness that associated with SPA

00:16:40.319 --> 00:16:43.477
without the complexity of the front-end framework.

00:16:43.560 --> 00:16:45.360
You can keep the state on the server.

00:16:45.800 --> 00:16:50.600
You can write mostly your business logic on the server

00:16:50.839 --> 00:16:55.799
without having touch the client-side code.

00:16:58.120 --> 00:17:02.520
Phoenix will send the HTML part through WebSocket.

00:17:03.399 --> 00:17:07.116
So we can push the data if data changes from the server,

00:17:07.199 --> 00:17:08.799
not from the client.

00:17:09.319 --> 00:17:12.077
This is some of the framework or libraries

00:17:12.160 --> 00:17:14.479
that you can use for HTML over the wire.

00:17:14.880 --> 00:17:18.159
There is Hotwire from Ruby on Rails,

00:17:18.919 --> 00:17:21.157
inspired by LiveView.

00:17:21.240 --> 00:17:27.639
Then also Laravel invented Livewire.

00:17:27.839 --> 00:17:36.007
So you can write your front-end code with PHP.

00:17:36.090 --> 00:17:36.877
If you need more agnostic solution,

00:17:36.960 --> 00:17:41.160
you can use HTMX, the meme framework,

00:17:42.480 --> 00:17:44.547
or Unpoly, UnpolyJS and Deno Fresh,

00:17:45.773 --> 00:17:48.720
a framework called Fresh from Deno team.

00:17:49.240 --> 00:17:58.146
You can use this approach as well.

00:17:58.230 --> 00:17:59.237
So for the demo,

00:17:59.320 --> 00:18:02.957
I will create something like a dashboard,

00:18:03.040 --> 00:18:04.720
a simple dashboard.

00:18:05.000 --> 00:18:08.040
You can see on the browser or on the client.

00:18:08.320 --> 00:18:12.119
So when we hit the URL,

00:18:12.520 --> 00:18:13.637
it will go to the server,

00:18:13.720 --> 00:18:16.237
ask for some statistic

00:18:16.320 --> 00:18:20.120
and it will give you an HTML response.

00:18:20.480 --> 00:18:24.716
And the page will render. That's it.

00:18:24.799 --> 00:18:27.597
And the connection, HTTP connection is finished.

00:18:27.680 --> 00:18:31.999
Then when user interact with our app

00:18:34.200 --> 00:18:37.479
for example like on click,

00:18:37.919 --> 00:18:40.479
then the server will send a new HTML,

00:18:41.159 --> 00:18:45.677
then the client will re-render.

00:18:45.760 --> 00:18:47.479
Let's see in an action.

00:19:05.120 --> 00:19:05.520
Error.

00:19:08.159 --> 00:19:09.277
Okay, this is the app.

00:19:09.360 --> 00:19:10.080
Yeah.

00:19:13.760 --> 00:19:17.479
The statistic were from the backend from my laptop.

00:19:17.720 --> 00:19:21.120
You can see the CPU load, memory use, and uptime.

00:19:23.679 --> 00:19:28.157
This is the data that sent.

00:19:28.240 --> 00:19:34.596
This is the stats we hit to get statistic.

00:19:34.679 --> 00:19:35.520
This is the HTML.

00:19:35.840 --> 00:19:36.960
You can see the headers.

00:19:37.080 --> 00:19:38.840
This is HTML.

00:19:39.520 --> 00:19:41.160
And it render, okay?

00:19:41.720 --> 00:19:45.800
Then if we click and we update,

00:19:45.960 --> 00:19:49.880
a new stats will send from the browser.

00:19:50.320 --> 00:19:51.760
Sorry, from the server.

00:19:52.039 --> 00:19:54.480
And it will re-render.

00:19:55.000 --> 00:19:56.520
This is HTML as well.

00:19:56.640 --> 00:20:05.596
You can see the statistic over here like CPU usage

00:20:05.679 --> 00:20:07.400
144.43 and anything else.

00:20:08.039 --> 00:20:08.279
Okay.

00:20:09.039 --> 00:20:09.797
Let's see the code.

00:20:09.880 --> 00:20:10.680
This is the code.

00:20:11.039 --> 00:20:13.197
I'm using HTMX and Hono.

00:20:13.280 --> 00:20:18.720
So Hono is a web framework like Express in Node.js.

00:20:19.533 --> 00:20:24.797
We've got a layout and we use the layout for rendering

00:20:24.880 --> 00:20:30.279
the layout and we use route root route slash

00:20:30.960 --> 00:20:36.320
and render the initial stats which is all zero, right?

00:20:36.760 --> 00:20:39.716
When we refresh, start from zero and then

00:20:39.799 --> 00:20:41.999
the data will come.

00:20:42.760 --> 00:20:44.317
Okay, now we see the templates.

00:20:44.400 --> 00:20:45.799
This is the layout.

00:20:46.559 --> 00:20:48.476
We see the body and the content.

00:20:48.559 --> 00:20:53.920
The content itself is on the render stats function.

00:20:54.280 --> 00:20:57.476
And this is the HTML that get sent from server

00:20:57.559 --> 00:20:58.280
to client.

00:21:00.400 --> 00:21:04.836
You can see in here like CPU usages or memory

00:21:04.919 --> 00:21:05.720
and uptime.

00:21:05.879 --> 00:21:06.479
Okay.

00:21:08.240 --> 00:21:11.400
What interesting is when you use HTMX,

00:21:12.000 --> 00:21:17.840
you got a new property from HTML like 𝚜𝚡-𝚐𝚎𝚝

00:21:18.360 --> 00:21:19.839
or 𝚜𝚡-𝚙𝚘𝚜𝚝 or 𝚜𝚡-𝚙𝚊𝚝𝚌𝚑.

00:21:20.440 --> 00:21:26.019
And you define the 𝚜𝚡-𝚝𝚊𝚛𝚐𝚎𝚝 which is for my case

00:21:26.102 --> 00:21:29.679
will replace the content or the child of the body.

00:21:30.279 --> 00:21:34.399
And when it triggers, it triggers when on load.

00:21:34.919 --> 00:21:41.080
So when we change this to every 1 second,

00:21:41.480 --> 00:21:48.200
it will re-render every 1 second.

00:21:48.799 --> 00:21:49.119
Okay.

00:21:49.360 --> 00:21:51.157
It change every 1 second.

00:21:51.240 --> 00:21:53.079
There is new stats HTML.

00:22:00.559 --> 00:22:00.799
Okay.

00:22:01.320 --> 00:22:04.080
Let's change back.

00:22:04.760 --> 00:22:10.200
That's the demo number one.

00:22:15.400 --> 00:22:17.359
Now, we level up a bit.

00:22:17.480 --> 00:22:20.520
We will send the HTML through WebSocket.

00:22:20.720 --> 00:22:24.196
We can use HTMX as well, but we have to use

00:22:24.279 --> 00:22:27.520
third party library or extension in HTMX.

00:22:28.120 --> 00:22:32.200
But in this demo, I will show you the Elixir Phoenix

00:22:32.320 --> 00:22:36.517
version with the same application.

00:22:36.600 --> 00:22:40.277
But the difference is we send the data

00:22:40.360 --> 00:22:41.680
through WebSocket.

00:22:41.880 --> 00:22:44.520
So at first almost the same.

00:22:44.840 --> 00:22:48.277
We have client that does both ask something

00:22:48.360 --> 00:22:52.160
to the server and server will send HTML initial page.

00:22:52.760 --> 00:22:59.582
And then when user click something or click update

00:22:59.666 --> 00:23:05.920
button, it will use the WebSocket to update the page.

00:23:06.600 --> 00:23:11.280
Let's see the Elixir version.

00:23:17.080 --> 00:23:17.320
Okay.

00:23:18.080 --> 00:23:20.799
This one, the Phoenix version.

00:23:21.159 --> 00:23:24.119
You can see, it's almost the same.

00:23:24.799 --> 00:23:31.640
The difference is there is a WebSocket connection

00:23:31.840 --> 00:23:35.917
that sends data back and forth from the server

00:23:36.000 --> 00:23:38.360
to client and otherwise.

00:23:38.640 --> 00:23:42.160
So when we update the click the update button,

00:23:42.480 --> 00:23:50.280
it will send the data like event, type click.

00:23:50.880 --> 00:23:51.520
Like this.

00:23:51.960 --> 00:23:53.920
The event name is update.

00:23:54.360 --> 00:23:56.520
And it will send the data.

00:23:57.120 --> 00:23:58.080
The response.

00:24:00.350 --> 00:24:00.910
Zero.

00:24:01.799 --> 00:24:02.679
Not this.

00:24:03.279 --> 00:24:05.480
Let's see again.

00:24:06.159 --> 00:24:07.200
Okay, this is one.

00:24:08.320 --> 00:24:11.399
The response, Phoenix reply.

00:24:11.919 --> 00:24:16.836
The response is so Phoenix will send the diff or

00:24:16.919 --> 00:24:21.519
the changes only, not all HTML in form of

00:24:22.159 --> 00:24:23.637
JavaScript object like this.

00:24:23.720 --> 00:24:29.200
So the diff is just number one is 29.1, this one.

00:24:29.679 --> 00:24:34.319
This is not changing, so the server will not sending that.

00:24:34.600 --> 00:24:36.319
This is changing like 10,000.

00:24:39.679 --> 00:24:41.999
And uptime also changing.

00:24:43.200 --> 00:24:43.440
Okay.

00:24:43.720 --> 00:24:45.079
Let's see the code.

00:24:45.679 --> 00:24:46.677
This is the code.

00:24:46.760 --> 00:24:52.797
So the Phoenix LiveView have at least two function,

00:24:52.880 --> 00:24:55.919
the mount function.

00:24:56.520 --> 00:25:00.276
We set the initial state here like CPU usage, model,

00:25:00.359 --> 00:25:03.200
count, memory usage, and uptime.

00:25:03.880 --> 00:25:09.320
And then we need one more which is render function.

00:25:09.600 --> 00:25:12.480
This is our HTML or templates.

00:25:13.080 --> 00:25:18.716
Then we show the variable or the state here like

00:25:18.799 --> 00:25:21.799
CPU model and CPU usage.

00:25:23.039 --> 00:25:29.400
And if we click button update, it will trigger

00:25:29.559 --> 00:25:32.240
the update event.

00:25:32.760 --> 00:25:39.597
We need to define the function called handle_event.

00:25:39.680 --> 00:25:40.480
Oops.

00:25:42.279 --> 00:25:43.040
In this one.

00:25:43.399 --> 00:25:46.760
And we update the statistic with the new data.

00:25:49.679 --> 00:25:50.079
Right?

00:25:50.679 --> 00:25:56.637
And if we do something similar like the HTMX version

00:25:56.720 --> 00:26:00.680
before, we can update every 1 second.

00:26:01.000 --> 00:26:05.757
But this time, the server will tell that we need

00:26:05.840 --> 00:26:07.316
a timer every 1 second.

00:26:07.399 --> 00:26:13.959
It will trigger a tick event that we handle here.

00:26:14.440 --> 00:26:19.319
Same as handle_event that will call the update stats.

00:26:19.919 --> 00:26:24.920
So if we save and we see, this is now update

00:26:25.159 --> 00:26:26.680
every second.

00:26:30.159 --> 00:26:32.480
Thank you.

00:26:33.360 --> 00:26:33.480
Okay.

00:26:38.120 --> 00:26:46.880
Let us back to the slide.

00:26:47.480 --> 00:26:50.239
In summary, there is a great alternative to create

00:26:50.399 --> 00:26:54.560
dynamic and interactive server-rendered web app.

00:26:55.200 --> 00:27:00.437
It offers faster first loading page and responsiveness

00:27:00.520 --> 00:27:04.797
that we used to be on a single-page application

00:27:04.880 --> 00:27:07.320
without the complexity of front-end framework.

00:27:07.520 --> 00:27:11.000
As you can see in the demo, we haven't touched,

00:27:11.120 --> 00:27:14.199
we haven't write any JavaScript client, right?

00:27:14.559 --> 00:27:16.840
So we just focus on the server side.

00:27:17.520 --> 00:27:21.439
We keep state on the server like the old days

00:27:21.640 --> 00:27:23.560
like request response era.

00:27:24.240 --> 00:27:27.120
And no data transport needed.

00:27:27.640 --> 00:27:31.037
And we can focus on the server and back-end focus

00:27:31.120 --> 00:27:33.279
web development.

00:27:33.399 --> 00:27:33.877
That's it.

00:27:33.960 --> 00:27:35.559
This is HTML over the wire.

00:27:35.760 --> 00:27:39.560
I hope you enjoy my talk.

00:27:40.240 --> 00:27:44.080
How many times we got?

00:27:45.200 --> 00:27:45.840
15 minutes.

00:27:46.200 --> 00:27:46.840
Okay.

00:27:48.200 --> 00:27:51.716
If you like, I have some feedback form.

00:27:51.799 --> 00:27:55.797
If you want to give some feedback for me for this

00:27:55.880 --> 00:28:00.397
session, you can scan the QR code or you can visit

00:28:00.480 --> 00:28:01.280
feedback.rizal.work.

00:28:07.440 --> 00:28:11.076
Okay.

00:28:11.159 --> 00:28:20.277
And you can fill out the form like a small kind of

00:28:20.360 --> 00:28:22.217
form like this.

00:28:22.300 --> 00:28:25.623
I open as well.

00:28:25.706 --> 00:28:27.690
Wait.

00:28:27.773 --> 00:28:29.757
Yeah.

00:28:29.840 --> 00:28:34.397
When you fill the form, it will show on the screen

00:28:34.480 --> 00:28:37.277
and on your phone as well in real time.

00:28:37.360 --> 00:28:40.997
This is using Phoenix and Elixir as well.

00:28:41.080 --> 00:28:43.799
You can see the code on the right-hand side.

00:28:44.080 --> 00:28:48.557
You can click the GitHub button if you want to

00:28:48.640 --> 00:28:49.400
see the code.

00:28:50.000 --> 00:28:55.117
It will broadcast every update that after you send

00:28:55.200 --> 00:28:58.517
the data and save to the database, and the database

00:28:58.600 --> 00:29:03.640
will or the back-end will send the updates to all

00:29:03.840 --> 00:29:06.360
our screen.

00:29:07.120 --> 00:29:08.799
Oh, nice.

00:29:09.399 --> 00:29:10.320
Thank you.

00:29:11.000 --> 00:29:11.679
So many.

00:29:22.679 --> 00:29:22.919
Okay.

00:29:23.679 --> 00:29:25.639
I think that's it for me.

00:29:26.120 --> 00:29:29.837
If you want to follow me on social media, you can

00:29:29.920 --> 00:29:40.079
go to GitHub or LinkedIn, YouTube, and Twitter.

00:29:40.519 --> 00:29:43.760
Thank you very much for your time.

00:29:44.480 --> 00:29:44.720
Okay.

00:29:44.880 --> 00:29:45.956
Thank you so much, Riza.

00:29:46.039 --> 00:29:46.920
Thank you so much.
