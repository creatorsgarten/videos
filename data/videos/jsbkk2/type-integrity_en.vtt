WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:01.400 --> 00:00:02.200
Woo!

00:00:04.640 --> 00:00:04.960
Yeah.

00:00:05.799 --> 00:00:08.717
Okay, so this section is going to be speak in English.

00:00:08.800 --> 00:00:13.476
So I hope you guys are familiar with the topic.

00:00:13.559 --> 00:00:15.799
Maybe, maybe not.

00:00:17.359 --> 00:00:19.400
If you are not familiar with the topic, that's okay.

00:00:19.600 --> 00:00:23.080
Because we are going to talk about the overview of

00:00:23.320 --> 00:00:25.440
JavaScript and TypeScript in general.

00:00:25.800 --> 00:00:29.480
Okay, let's start with a little bit of introduction.

00:00:30.679 --> 00:00:34.316
You can call me Aom, or if you're not sure how to

00:00:34.399 --> 00:00:40.960
pronounce Aom in English, you may call me Salty.

00:00:41.399 --> 00:00:43.837
The full name is SaltyAom.

00:00:43.920 --> 00:00:48.439
I use this name on both Twitter and other places as well

00:00:48.800 --> 00:00:52.960
where it's like the blue app, like Bluesky or something.

00:00:53.280 --> 00:00:56.880
Everywhere else I use this name like Twitter, GitHub,

00:00:57.199 --> 00:01:00.640
and Bluesky as well if you want to follow along.

00:01:03.800 --> 00:01:07.640
If you are Thai, you probably know that I usually

00:01:08.240 --> 00:01:14.076
cosplay as my favorite character to speak about

00:01:14.159 --> 00:01:15.239
technical stuff.

00:01:15.960 --> 00:01:22.076
Today I cosplay as Pekomama from the kind of the

00:01:22.159 --> 00:01:28.517
company that made VTubers.

00:01:28.600 --> 00:01:37.199
Let's just skip because about license and stuff.

00:01:37.799 --> 00:01:38.799
Oh, I see.

00:01:39.040 --> 00:01:43.637
So we're going to wait.

00:01:43.720 --> 00:01:46.119
Maybe we can wait 5 minutes and start again?

00:01:47.560 --> 00:01:48.440
Sure, okay.

00:01:49.520 --> 00:01:53.716
Because we are a little bit earlier than time that

00:01:53.799 --> 00:01:54.680
we have.

00:01:55.880 --> 00:01:58.919
Actually it should be 10 minutes after this, right?

00:02:00.520 --> 00:02:01.280
Okay, sure.

00:02:02.840 --> 00:02:04.840
Maybe talk a little bit in general.

00:02:05.360 --> 00:02:09.477
Maybe we can get some idea about what I'm going to

00:02:09.560 --> 00:02:10.439
talk about today.

00:02:10.959 --> 00:02:14.560
But we are going to restart it all again after this

00:02:14.760 --> 00:02:15.436
10 minutes.

00:02:15.519 --> 00:02:16.359
Is that alright?

00:02:18.280 --> 00:02:19.680
Sure, okay.

00:02:24.720 --> 00:02:27.597
Let's start with a little bit of quiz time, right?

00:02:27.680 --> 00:02:28.839
Just like for fun.

00:02:31.480 --> 00:02:34.599
Let's start with this code example.

00:02:35.080 --> 00:02:37.160
We are going to play Who is a Millionaire?

00:02:39.440 --> 00:02:41.240
What is the language of this code?

00:02:42.760 --> 00:02:50.800
I'll give you a little bit of time to think about it.

00:02:52.560 --> 00:02:55.080
Maybe like we count down like 5, 4, 3, 2, 1.

00:02:59.239 --> 00:03:00.600
Let's show the answer.

00:03:00.720 --> 00:03:04.440
The answer is actually JavaScript ES4, not TypeScript.

00:03:04.560 --> 00:03:05.959
You can see the syntax here.

00:03:06.200 --> 00:03:08.960
It looks almost identical to TypeScript, right?

00:03:09.319 --> 00:03:12.156
But actually, this proposal was introduced in

00:03:12.239 --> 00:03:20.160
JavaScript ES4 where maybe almost 20 years ago.

00:03:21.400 --> 00:03:26.039
There's a proposal to add type natively to JavaScript.

00:03:27.120 --> 00:03:31.637
This proposal was almost added to the language,

00:03:31.720 --> 00:03:35.279
but somehow dropped it because there are too much

00:03:35.680 --> 00:03:39.356
stuff that they want to add into the JavaScript

00:03:39.439 --> 00:03:39.876
language.

00:03:39.959 --> 00:03:43.436
But there's a lot of things that they can't implement

00:03:43.519 --> 00:03:46.360
and they just skip to ES5 as we know it.

00:03:48.599 --> 00:03:51.439
That's a little bit of history.

00:03:53.000 --> 00:03:57.757
I think maybe we can start or should we still wait?

00:04:03.680 --> 00:04:07.520
Okay, let's start with what is TypeScript.

00:04:09.239 --> 00:04:11.479
TypeScript is just like JavaScript with type.

00:04:12.040 --> 00:04:13.480
I think a lot of people know that.

00:04:14.840 --> 00:04:16.797
If you don't know TypeScript,

00:04:16.880 --> 00:04:20.396
it actually just adds some type annotation to JavaScript

00:04:20.479 --> 00:04:21.960
and that's just it.

00:04:25.759 --> 00:04:27.919
You can't actually use TypeScript in browser,

00:04:28.280 --> 00:04:29.800
because you have to compile it

00:04:30.039 --> 00:04:32.237
since it isn't actually a language

00:04:32.320 --> 00:04:33.676
that you can run in the browser

00:04:33.759 --> 00:04:35.920
and it doesn't have browser support.

00:04:36.360 --> 00:04:39.997
So we somehow need to transpile the language

00:04:40.080 --> 00:04:44.280
into JavaScript to run it in the browser.

00:04:49.120 --> 00:04:50.717
We can see in this example

00:04:50.800 --> 00:04:55.520
that this is what TypeScript is like.

00:04:56.199 --> 00:04:59.437
You just add some colon after the parameter

00:04:59.520 --> 00:05:01.080
and you add type to it.

00:05:01.479 --> 00:05:05.917
So when you try to call a function with string,

00:05:06.000 --> 00:05:08.197
it is fine.

00:05:08.280 --> 00:05:09.956
But when you try to add a number,

00:05:10.039 --> 00:05:13.320
it throws an error.

00:05:14.520 --> 00:05:18.077
That's actually just what you want to add

00:05:18.160 --> 00:05:19.956
to the language,

00:05:20.039 --> 00:05:21.357
just add a type to it

00:05:21.440 --> 00:05:23.116
and if the type doesn't match,

00:05:23.199 --> 00:05:25.879
maybe throw an error or something like that.

00:05:26.680 --> 00:05:31.120
We can see on the State of JavaScript,

00:05:31.520 --> 00:05:32.439
in the last year,

00:05:33.440 --> 00:05:34.917
there are a lot of people

00:05:35.000 --> 00:05:37.119
that have been trying to adopt TypeScript

00:05:37.919 --> 00:05:40.599
maybe in their side project and their work.

00:05:41.639 --> 00:05:44.077
The charts show that there's a lot of people

00:05:44.160 --> 00:05:45.836
who are enjoying TypeScript

00:05:45.919 --> 00:05:48.120
and some people who don't enjoy it.

00:05:48.960 --> 00:05:54.400
But since we add type to the language,

00:05:55.280 --> 00:05:56.599
does it actually work?

00:05:57.120 --> 00:05:58.600
If we think about it,

00:05:58.720 --> 00:06:01.119
we can actually just surpass this error.

00:06:06.960 --> 00:06:08.836
TypeScript doesn't actually check the type

00:06:08.919 --> 00:06:09.919
in the runtime.

00:06:10.160 --> 00:06:12.717
So when you pass something

00:06:12.800 --> 00:06:15.160
that maybe TypeScript can't check,

00:06:15.680 --> 00:06:16.797
it is going to ignore it

00:06:16.880 --> 00:06:18.519
and pretend that everything is fine.

00:06:19.599 --> 00:06:21.639
TypeScript is like duck type.

00:06:22.199 --> 00:06:25.917
If it moves like a duck and quacks like a duck,

00:06:26.000 --> 00:06:27.720
then it's probably a duck.

00:06:28.280 --> 00:06:31.197
Let's say that you pass something

00:06:31.280 --> 00:06:32.560
that looks like a string,

00:06:32.880 --> 00:06:35.319
but it isn't actually a string,

00:06:36.400 --> 00:06:37.516
it is going to work fine

00:06:37.599 --> 00:06:40.280
because TypeScript pretends that it is a string.

00:06:41.000 --> 00:06:42.839
Let's get back to our example.

00:06:43.120 --> 00:06:44.797
We can see that in this example,

00:06:44.880 --> 00:06:47.599
we pass a number and then everything is fine.

00:06:48.440 --> 00:06:54.080
But if we pretend that the number is something else,

00:06:54.440 --> 00:06:55.599
it is going to be fine

00:06:55.800 --> 00:07:00.479
because TypeScript doesn't know what type of it.

00:07:00.720 --> 00:07:02.759
So everything works fine when actually

00:07:03.759 --> 00:07:06.800
it shouldn't be this way.

00:07:07.560 --> 00:07:14.157
So a lot of people are trying to make TypeScript be

00:07:14.240 --> 00:07:17.877
A lot of people trying to make TypeScript better behave

00:07:17.960 --> 00:07:18.680
in this way.

00:07:19.120 --> 00:07:21.880
They try to make a lot of stuff recently

00:07:22.080 --> 00:07:26.757
and we have been using it a lot recently

00:07:26.840 --> 00:07:29.120
that trying to fix something like this.

00:07:31.280 --> 00:07:35.717
There's actually two solutions that we can prevent

00:07:35.800 --> 00:07:36.997
this from happening.

00:07:37.080 --> 00:07:43.676
The first one is we use type inference,

00:07:43.759 --> 00:07:46.240
and the second one is transformer.

00:07:46.840 --> 00:07:50.157
But I have to warn that both of these solutions

00:07:50.240 --> 00:07:54.197
doesn't actually make TypeScript like a strong type

00:07:54.280 --> 00:07:54.676
language,

00:07:54.759 --> 00:07:57.116
but it's like some patches that we can apply

00:07:57.199 --> 00:07:59.037
to make TypeScript a little bit better

00:07:59.120 --> 00:08:00.840
at checking type.

00:08:02.720 --> 00:08:04.956
Let's go over our first topic,

00:08:05.039 --> 00:08:07.319
which is the type inference.

00:08:08.960 --> 00:08:12.439
I think a lot of people know what Zod is.

00:08:12.720 --> 00:08:14.956
Basically, it is a TypeScript library

00:08:15.039 --> 00:08:17.076
that you can define what the shape of object

00:08:17.159 --> 00:08:17.960
looks like.

00:08:18.319 --> 00:08:21.759
And then you can check if the input,

00:08:25.319 --> 00:08:27.076
something you have in the code base,

00:08:27.159 --> 00:08:30.997
that need to check if the type is actually

00:08:31.080 --> 00:08:32.000
a type or not.

00:08:32.320 --> 00:08:34.557
You can use 𝚙𝚊𝚛𝚜𝚎 or something like that

00:08:34.640 --> 00:08:35.999
utility function.

00:08:36.680 --> 00:08:39.357
First, you define the object in JavaScript

00:08:39.440 --> 00:08:43.196
and then once you define the object shape,

00:08:43.279 --> 00:08:47.957
you can use that reference to check if something else

00:08:48.040 --> 00:08:49.597
is the same as you want or not.

00:08:49.680 --> 00:08:51.677
So in our case, we have an object with

00:08:51.760 --> 00:08:55.280
a username string and then we parse it using

00:08:55.640 --> 00:08:56.400
something else.

00:08:56.720 --> 00:08:58.837
And if it work, it is going to work,

00:08:58.920 --> 00:09:01.480
but otherwise it's going to throw an error.

00:09:02.200 --> 00:09:05.996
But the interesting thing is that recently

00:09:06.079 --> 00:09:10.517
we have been adding something like getting the type

00:09:10.600 --> 00:09:12.160
from our code.

00:09:12.480 --> 00:09:15.120
If we see, we can see that on the last line,

00:09:15.600 --> 00:09:18.200
we infer the type from the first one

00:09:18.519 --> 00:09:20.000
in the JavaScript code base.

00:09:20.680 --> 00:09:24.240
And then we use some utility call 𝚣.𝚒𝚗𝚏𝚎𝚛

00:09:24.880 --> 00:09:26.560
and then we get a type.

00:09:26.920 --> 00:09:29.316
So this is what we call type inference,

00:09:29.399 --> 00:09:31.157
is that we write the code first

00:09:31.240 --> 00:09:34.919
and then we infer type from the code later.

00:09:36.279 --> 00:09:38.679
Actually, we can implement something like that.

00:09:40.600 --> 00:09:43.560
Maybe it doesn't look easy,

00:09:43.720 --> 00:09:46.397
but actually TypeScript provides us with something

00:09:46.480 --> 00:09:47.400
called generic.

00:09:47.760 --> 00:09:52.160
Generic is like something, if we have written

00:09:52.760 --> 00:09:57.120
some code in other language like maybe Rust, Java,

00:09:57.720 --> 00:10:01.319
we can pass some type and then infer something

00:10:01.640 --> 00:10:02.479
somewhere else.

00:10:02.760 --> 00:10:05.957
But ultimately, TypeScript also supports

00:10:06.040 --> 00:10:07.837
this same feature as well.

00:10:07.920 --> 00:10:11.157
So we can create some interface of class

00:10:11.240 --> 00:10:14.357
and then memorize the type and then provide them,

00:10:14.440 --> 00:10:18.117
does some recursive stuff to make something

00:10:18.200 --> 00:10:19.240
like that happen.

00:10:19.680 --> 00:10:23.597
But it has just been supported in recent version

00:10:23.680 --> 00:10:24.316
of TypeScript.

00:10:24.399 --> 00:10:27.319
So maybe TypeScript 4 or later,

00:10:27.920 --> 00:10:29.399
which isn't long ago yet,

00:10:29.720 --> 00:10:31.840
which is the exact timeline that Zod

00:10:32.519 --> 00:10:39.040
and some library like that have been popularized.

00:10:39.160 --> 00:10:42.277
So after we wrote some magic type,

00:10:42.360 --> 00:10:44.640
we can infer type from here.

00:10:44.920 --> 00:10:49.360
Actually my previous two talks were talking about

00:10:49.480 --> 00:10:50.720
how to implement this.

00:10:50.880 --> 00:10:53.957
So if you want to take a deep dive,

00:10:54.040 --> 00:10:55.397
maybe you can search in YouTube,

00:10:55.480 --> 00:10:58.279
but I'm not sure if it is uploaded or not.

00:11:00.880 --> 00:11:02.996
So it is great, right?

00:11:03.079 --> 00:11:06.677
But that comes with a cost and drawback.

00:11:06.760 --> 00:11:09.117
The first thing is that you have to make sure

00:11:09.200 --> 00:11:14.316
that the code actually works by making sure

00:11:14.399 --> 00:11:17.319
that the code actually validates type correctly.

00:11:18.480 --> 00:11:19.756
And once we did that,

00:11:19.839 --> 00:11:23.839
we have to also make sure that our type system

00:11:23.959 --> 00:11:27.316
in the type level work as same as the code

00:11:27.399 --> 00:11:28.400
in the runtime.

00:11:28.880 --> 00:11:32.397
Which means that we now have to separate

00:11:32.480 --> 00:11:35.479
code base that should function the same.

00:11:36.639 --> 00:11:39.200
And this is very hard to implement

00:11:39.639 --> 00:11:40.840
in our code bases.

00:11:41.959 --> 00:11:43.277
Since I made Elysia, right?

00:11:43.360 --> 00:11:47.960
We have a lot of black magic about typing and stuff.

00:11:48.120 --> 00:11:51.477
We have to add unit test for type level

00:11:51.560 --> 00:11:54.679
to make sure that everything works all right.

00:11:56.200 --> 00:12:00.760
So since I show you something like this,

00:12:01.399 --> 00:12:03.840
when should you write it yourself?

00:12:04.120 --> 00:12:07.439
The answer is you shouldn't,

00:12:07.560 --> 00:12:10.237
you should never write it in your application

00:12:10.320 --> 00:12:11.000
code base.

00:12:11.399 --> 00:12:13.477
Like if you have some application

00:12:13.560 --> 00:12:15.157
that you use in production,

00:12:15.240 --> 00:12:19.277
you need to ship a feature to your customer,

00:12:19.360 --> 00:12:21.000
you shouldn't write that at all.

00:12:21.199 --> 00:12:23.159
You should just let the...

00:12:23.519 --> 00:12:26.280
oh like a lot of people are coming.

00:12:26.720 --> 00:12:29.600
So do I need to restart or something?

00:12:32.639 --> 00:12:34.160
We have time.

00:12:34.360 --> 00:12:35.479
Are you guys okay?

00:12:37.160 --> 00:12:38.560
Can we recap a little bit?

00:12:44.399 --> 00:12:49.876
Okay, I didn't thought that there's going to be a lot

00:12:49.959 --> 00:12:50.680
of people.

00:12:55.480 --> 00:13:05.240
Actually, we have just surpassed halfway through.

00:13:05.920 --> 00:13:07.680
Let's review a little bit.

00:13:10.240 --> 00:13:11.680
I'm sorry for everyone.

00:13:12.839 --> 00:13:15.760
I like to talk about it so much.

00:13:16.480 --> 00:13:17.959
I want to get start quickly.

00:13:19.880 --> 00:13:23.316
You know that we have three people who are talking as

00:13:23.399 --> 00:13:24.920
keynote speaker, right?

00:13:25.480 --> 00:13:29.677
I actually want to see how the other speakers are going

00:13:29.760 --> 00:13:30.320
to speak.

00:13:31.959 --> 00:13:35.160
Somehow we have the same timetable.

00:13:36.279 --> 00:13:41.196
I can't apply to other speaker, which is making me mad,

00:13:41.279 --> 00:13:41.999
actually.

00:13:43.000 --> 00:13:45.440
So, let's restart it again.

00:13:45.880 --> 00:13:48.199
Sorry for everyone who was here before.

00:13:50.440 --> 00:13:52.319
Give me a minute.

00:14:00.320 --> 00:14:02.600
I talk a little bit too much at first.

00:14:03.519 --> 00:14:05.560
Let's review.

00:14:06.000 --> 00:14:08.756
Today, we want to talk about TypeScript with type

00:14:08.839 --> 00:14:13.717
integrity.

00:14:13.800 --> 00:14:16.519
Today, we are going to talk about TypeScript with type

00:14:17.399 --> 00:14:18.199
integrity.

00:14:19.000 --> 00:14:23.279
Obviously it's something that I'm not sure what it is

00:14:23.519 --> 00:14:23.999
about.

00:14:24.759 --> 00:14:28.440
Since we know that programmers are bad at naming things,

00:14:29.160 --> 00:14:31.079
I think it's understandable.

00:14:31.720 --> 00:14:35.360
I hope you guys forgive me for that.

00:14:36.160 --> 00:14:37.800
A little bit of introduction.

00:14:38.000 --> 00:14:44.237
My name is Aom in Thai, but for people somewhere else,

00:14:44.320 --> 00:14:46.797
you can call me Salty or SaltyAom.

00:14:46.880 --> 00:14:51.000
Basically, I am a core maintainer of Elysia.js.

00:14:52.280 --> 00:14:57.477
It's a framework for making web server Bun, which does

00:14:57.560 --> 00:15:00.280
a lot of black magic with typing and stuff.

00:15:01.160 --> 00:15:05.157
This name I use on both Twitter, GitHub, and mostly

00:15:05.240 --> 00:15:07.480
everywhere else, including some games.

00:15:10.720 --> 00:15:16.720
If you found player with this username, it's usually me.

00:15:20.199 --> 00:15:24.477
If you are Thai, you mostly familiar with what I have

00:15:24.560 --> 00:15:26.400
been doing recently.

00:15:27.120 --> 00:15:30.717
I apply to a lot of talk and conference to talk about

00:15:30.800 --> 00:15:32.480
stuff I interested in.

00:15:34.399 --> 00:15:39.319
Mostly the organizer usually request me to cosplay to

00:15:39.720 --> 00:15:40.200
speak.

00:15:40.839 --> 00:15:42.920
Also this one as well.

00:15:45.040 --> 00:15:50.079
The organizer actually request me to maybe cosplay and

00:15:51.199 --> 00:15:51.679
speak.

00:15:53.920 --> 00:15:58.357
A lot of people actually follow my Instagram account

00:15:58.440 --> 00:15:59.680
and saw that I cosplay.

00:16:07.800 --> 00:16:12.560
Today I cosplay as Pekomama, which is from the Vtuber

00:16:13.040 --> 00:16:15.957
company called Hololive.

00:16:16.040 --> 00:16:17.640
I think a lot of people are familiar with it.

00:16:17.880 --> 00:16:23.116
If you know like Pekora, Fubuki, or Gawr Gura or some

00:16:23.199 --> 00:16:24.037
people like that.

00:16:24.120 --> 00:16:28.477
They are Vtuber who are streaming gaming and something

00:16:28.560 --> 00:16:31.280
like that on YouTube and Twitch.

00:16:33.800 --> 00:16:38.077
This talk is going to be recommend for beginner levels.

00:16:38.160 --> 00:16:44.357
We are going to give about general overview of

00:16:44.440 --> 00:16:45.160
TypeScript.

00:16:46.880 --> 00:16:49.196
If you don't have any experience with TypeScript,

00:16:49.279 --> 00:16:50.000
that's fine.

00:16:50.240 --> 00:16:53.159
If you have a little bit, that's going to help a lot.

00:16:54.480 --> 00:16:55.880
Let's get started.

00:16:58.120 --> 00:16:59.917
Let's start with a little bit of quiz.

00:17:00.000 --> 00:17:02.077
I think a lot of people who were here before already

00:17:02.160 --> 00:17:03.199
know the answer.

00:17:05.160 --> 00:17:06.797
You can see this code, right?

00:17:06.880 --> 00:17:09.839
It does have interface, and it does have type

00:17:09.959 --> 00:17:10.759
annotation.

00:17:11.600 --> 00:17:15.760
My question is what is the language of this code?

00:17:16.360 --> 00:17:19.319
I will give you a little bit of time, like maybe 10

00:17:19.640 --> 00:17:21.039
seconds to think about it.

00:17:22.199 --> 00:17:25.917
People already know the answer, but for the newcomer,

00:17:26.000 --> 00:17:28.799
maybe you can think a little bit about it.

00:17:32.240 --> 00:17:34.360
Yeah, I think it's good time now.

00:17:35.120 --> 00:17:37.400
The answer is JavaScript ES4.

00:17:39.640 --> 00:17:41.557
You can see this syntax here.

00:17:41.640 --> 00:17:43.437
It almost looks like TypeScript.

00:17:43.520 --> 00:17:44.838
It does have type annotation.

00:17:45.280 --> 00:17:46.317
It does have class.

00:17:46.400 --> 00:17:48.000
It does have interface.

00:17:48.200 --> 00:17:51.317
Actually, it also have a public and private property

00:17:51.400 --> 00:17:52.040
as well.

00:17:52.799 --> 00:17:56.960
But this feature was first announced in JavaScript ES4,

00:17:57.840 --> 00:18:02.122
which is like almost 20 years ago or so.

00:18:02.640 --> 00:18:09.083
So we almost have type support in JavaScript,

00:18:09.280 --> 00:18:12.797
which is what we are trying to achieve today with

00:18:12.880 --> 00:18:14.080
TypeScript, right?

00:18:15.159 --> 00:18:18.560
But since there's a lot of history lesson,

00:18:18.679 --> 00:18:20.197
which I actually skip,

00:18:20.280 --> 00:18:23.797
and I don't know why they skip this version

00:18:23.880 --> 00:18:24.679
and straight to ES5.

00:18:26.520 --> 00:18:29.197
My guess is that they add too many features

00:18:29.280 --> 00:18:32.197
that too hard to implement in one version.

00:18:32.280 --> 00:18:34.919
So they just decide to skip it.

00:18:36.240 --> 00:18:38.836
But what is TypeScript in general, right?

00:18:38.919 --> 00:18:42.959
TypeScript is just like JavaScript with type.

00:18:43.520 --> 00:18:43.956
That's it.

00:18:44.039 --> 00:18:45.880
That's actually what TypeScript is.

00:18:46.559 --> 00:18:49.640
Although it's very popular with JavaScript user,

00:18:50.080 --> 00:18:51.277
like just adding type,

00:18:51.360 --> 00:18:54.277
and then a lot of people who use JavaScript

00:18:54.360 --> 00:18:58.877
then somehow magically want to use TypeScript.

00:18:58.960 --> 00:18:59.879
It's just type,

00:19:00.200 --> 00:19:02.836
but that's actually a lot of feature added

00:19:02.919 --> 00:19:04.956
in the language that is dynamic type

00:19:05.039 --> 00:19:08.920
and can get very complex quickly, like JavaScript.

00:19:09.320 --> 00:19:14.677
So the TypeScript language itself can't be used

00:19:14.760 --> 00:19:19.121
in the browser because the browser only knows

00:19:19.320 --> 00:19:20.200
JavaScript,

00:19:20.320 --> 00:19:23.000
but TypeScript isn't JavaScript.

00:19:23.480 --> 00:19:28.199
It is just like JavaScript with additional step

00:19:28.559 --> 00:19:31.000
that we can add some stuff into it.

00:19:31.320 --> 00:19:34.039
And in this case, it's just we add the type to it.

00:19:34.600 --> 00:19:38.836
So first we need to compile TypeScript to JavaScript

00:19:38.919 --> 00:19:39.880
itself first,

00:19:40.280 --> 00:19:42.400
and then we can use it in the browser.

00:19:42.760 --> 00:19:46.400
But this also apply to runtime like Node.js,

00:19:46.799 --> 00:19:49.476
but recently they ship some experimental stuff

00:19:49.559 --> 00:19:53.680
that we can use TypeScript directly in the runtime.

00:19:54.440 --> 00:19:57.596
Deno and Bun also add the ability to run

00:19:57.679 --> 00:19:59.120
TypeScript file natively.

00:19:59.720 --> 00:20:01.557
Although it is not actually native,

00:20:01.640 --> 00:20:04.437
they just remove the type and run it as JavaScript,

00:20:04.520 --> 00:20:08.920
but I think that works as well.

00:20:09.039 --> 00:20:11.397
But let's recap, right?

00:20:11.480 --> 00:20:15.079
Okay, a lot of people are already familiar with this.

00:20:16.120 --> 00:20:17.357
We have a function,

00:20:17.440 --> 00:20:20.117
and then maybe we say that this function

00:20:20.200 --> 00:20:23.956
should only accept a string like a word

00:20:24.039 --> 00:20:25.199
or something like that.

00:20:25.600 --> 00:20:30.080
So when we call it with word, it is going to work,

00:20:30.480 --> 00:20:33.037
but when we try to call it with the number,

00:20:33.120 --> 00:20:34.000
it doesn't work.

00:20:34.400 --> 00:20:36.600
So that's actually the point of TypeScript.

00:20:37.440 --> 00:20:40.600
We just want something that we can rely on

00:20:40.760 --> 00:20:45.836
and then make sure that we passing the correct stuff

00:20:45.919 --> 00:20:48.560
and everything is typed correctly.

00:20:48.760 --> 00:20:52.117
If we look at the state of JavaScript in the last year,

00:20:52.200 --> 00:20:55.357
we can see that a lot of people have been enjoying

00:20:55.440 --> 00:20:57.280
this feature like a lot.

00:20:57.960 --> 00:21:00.520
Although it's just type annotation,

00:21:00.919 --> 00:21:06.317
but actually that helps a lot in large codebase

00:21:06.400 --> 00:21:08.199
and complex type.

00:21:08.320 --> 00:21:09.956
A lot of stuff have been helping.

00:21:10.039 --> 00:21:13.399
So a lot of people have been adopting TypeScript

00:21:13.960 --> 00:21:14.680
recently.

00:21:15.559 --> 00:21:20.836
We can see that almost 50% are satisfying down here.

00:21:20.919 --> 00:21:23.160
And then some people doesn't want TypeScript,

00:21:23.400 --> 00:21:25.479
they can use JavaScript.

00:21:25.679 --> 00:21:29.920
But there's actually a problem with TypeScript itself.

00:21:30.360 --> 00:21:33.080
So we can see this code, right?

00:21:33.240 --> 00:21:37.076
It's we have a function that should only accept

00:21:37.159 --> 00:21:37.759
a string,

00:21:37.960 --> 00:21:41.000
but when we pass a number, it work fine,

00:21:41.320 --> 00:21:45.880
but actually TypeScript doesn't actually check a type.

00:21:46.480 --> 00:21:49.797
It only trying to make it look like

00:21:49.880 --> 00:21:54.120
it's checking a type, but it doesn't actually check it.

00:21:54.840 --> 00:21:58.279
So I want to introduce you to some concept called...

00:22:00.000 --> 00:22:00.960
what is it called?

00:22:05.039 --> 00:22:07.279
Okay, I actually forgot the term

00:22:08.000 --> 00:22:11.437
although I just talked about it 10 minutes ago,

00:22:11.520 --> 00:22:16.079
but it's called duck type if I recall correctly.

00:22:16.279 --> 00:22:18.476
But it is something that say that

00:22:18.559 --> 00:22:21.480
if it moves like a duck and quack like a duck,

00:22:21.720 --> 00:22:23.157
then it is likely a duck.

00:22:23.240 --> 00:22:25.117
So we have a duck here,

00:22:25.200 --> 00:22:26.720
and we have a rubber duck here.

00:22:26.840 --> 00:22:29.196
So if the rubber duck move like a duck

00:22:29.279 --> 00:22:31.600
and when we squeeze it, it also quack,

00:22:32.039 --> 00:22:33.880
then it's probably a duck.

00:22:34.320 --> 00:22:38.239
Although it isn't what a duck we want,

00:22:38.480 --> 00:22:39.877
but it also a duck.

00:22:39.960 --> 00:22:42.760
So TypeScript look at these images

00:22:42.919 --> 00:22:45.117
and then say that both are the same

00:22:45.200 --> 00:22:47.079
because they both are a duck.

00:22:47.559 --> 00:22:49.080
Actually, that's a concept that TypeScript

00:22:49.400 --> 00:22:53.317
have been using.

00:22:53.400 --> 00:22:55.437
So back to our code,

00:22:55.520 --> 00:22:58.437
we can see that our code function normally

00:22:58.520 --> 00:23:00.240
when we pass something like this.

00:23:01.480 --> 00:23:05.277
But when we try to say that a number

00:23:05.360 --> 00:23:06.877
isn't actually a number,

00:23:06.960 --> 00:23:08.319
but it is something else,

00:23:08.919 --> 00:23:11.400
this code somehow work perfectly fine.

00:23:11.559 --> 00:23:14.196
So we have a number,

00:23:14.279 --> 00:23:17.679
and we say that hey, you can see that

00:23:19.640 --> 00:23:22.237
what if we say to TypeScript that

00:23:22.320 --> 00:23:24.080
what if it isn't a number?

00:23:24.840 --> 00:23:26.437
Can we make it something else?

00:23:26.520 --> 00:23:28.079
And then it pass,

00:23:28.520 --> 00:23:29.960
although in our codebase,

00:23:30.120 --> 00:23:33.319
actually runtime code doesn't work.

00:23:33.919 --> 00:23:36.076
TypeScript isn't going to complain about it

00:23:36.159 --> 00:23:38.680
because it looks like a number.

00:23:39.120 --> 00:23:40.037
It looks like a string.

00:23:40.120 --> 00:23:42.000
So that's fine to TypeScript,

00:23:42.600 --> 00:23:44.917
but isn't fine to us and customer

00:23:45.000 --> 00:23:47.917
because it is going to throw error in the runtime

00:23:48.000 --> 00:23:51.280
and then fail our production server.

00:23:51.720 --> 00:23:55.757
So recently there have been an effort

00:23:55.840 --> 00:23:59.880
to make TypeScript actually a strong type language,

00:24:00.480 --> 00:24:03.117
although it isn't actually a strong type language,

00:24:03.200 --> 00:24:04.920
but we are trying to get there.

00:24:05.200 --> 00:24:08.880
So there is actually two ways to make this happen:

00:24:09.320 --> 00:24:11.237
the first one is we are using something called

00:24:11.320 --> 00:24:12.359
type inference,

00:24:12.520 --> 00:24:15.919
and the second one is called transformer.

00:24:16.799 --> 00:24:20.437
But both of these doesn't actually make

00:24:20.520 --> 00:24:22.517
the TypeScript a strong type language.

00:24:22.600 --> 00:24:25.759
So just a note before we start.

00:24:28.600 --> 00:24:33.960
So, type inference, I think a lot of people know what Zod is about.

00:24:34.480 --> 00:24:36.760
Like we define some shape in runtime,

00:24:37.159 --> 00:24:39.560
and we validate the shape in runtime as well.

00:24:40.039 --> 00:24:44.440
But we can also get a type from runtime into the type itself.

00:24:44.960 --> 00:24:48.319
We don't have to duplicate the code,

00:24:48.559 --> 00:24:52.440
say that we have an object with a username in runtime,

00:24:53.399 --> 00:24:56.480
and we don't have to duplicate the code in the type level,

00:24:56.640 --> 00:25:01.520
like manually writing the interface that call like user.

00:25:04.799 --> 00:25:07.599
We actually can infer the type from runtime itself.

00:25:07.720 --> 00:25:11.599
We write the code in the runtime and infer code to the type.

00:25:12.840 --> 00:25:17.596
This feature has just been recently added not long ago,

00:25:17.679 --> 00:25:19.240
like maybe two or three years,

00:25:19.360 --> 00:25:22.877
like in TypeScript 4, not sure which version,

00:25:22.960 --> 00:25:26.119
but there's a way to make it happen,

00:25:26.440 --> 00:25:29.080
which is using the thing called generic.

00:25:30.399 --> 00:25:36.680
Generic is like a function or some kind of special function,

00:25:36.840 --> 00:25:40.480
but it behaves like a function if you think about it.

00:25:40.919 --> 00:25:44.557
Like you accept something from the class or interface,

00:25:44.640 --> 00:25:47.560
and then you can somehow make stuff with it.

00:25:48.000 --> 00:25:50.596
And with that type of both,

00:25:50.679 --> 00:25:54.960
we can make something with the code below.

00:25:55.399 --> 00:25:58.237
So, we can see that we add some type here,

00:25:58.320 --> 00:26:02.280
something like this, and then boom, it's going to work.

00:26:03.720 --> 00:26:06.200
I also talk about this like two sessions ago,

00:26:06.320 --> 00:26:09.157
like maybe three months or four months ago.

00:26:09.240 --> 00:26:11.440
I'm not sure if it is recorded or not,

00:26:11.640 --> 00:26:13.080
but if you find one,

00:26:13.640 --> 00:26:16.357
please post it in comment if you are watching

00:26:16.440 --> 00:26:18.439
from the recorded video.

00:26:19.480 --> 00:26:23.037
But actually, it seems cool,

00:26:23.120 --> 00:26:27.117
but it has a drawback that we have to maintain

00:26:27.200 --> 00:26:31.160
both runtime code to make sure that runtime code

00:26:31.320 --> 00:26:32.517
actually validate the type,

00:26:32.600 --> 00:26:35.199
and then we have to maintain the type itself as well.

00:26:35.960 --> 00:26:38.880
In our code bases that we are working in Elysia,

00:26:39.000 --> 00:26:43.039
we have been like a lot of black magic with type stuff,

00:26:43.440 --> 00:26:47.637
but it is so complex that we have to add

00:26:47.720 --> 00:26:50.596
the unit test for type level to make sure that

00:26:50.679 --> 00:26:52.879
runtime and type level,

00:26:53.399 --> 00:26:56.840
both of the code match the same behavior.

00:26:57.200 --> 00:27:00.917
So, when should we use this, right?

00:27:01.000 --> 00:27:03.000
If you are using in the production server,

00:27:03.399 --> 00:27:08.716
like maybe you want to try to ship stuff

00:27:08.799 --> 00:27:11.439
to your end user, your customer,

00:27:12.720 --> 00:27:14.117
you shouldn't write it yourself

00:27:14.200 --> 00:27:16.319
because it is going to slow you down.

00:27:16.799 --> 00:27:19.476
But if you are using a library, that's fine

00:27:19.559 --> 00:27:21.797
because they have been devoting their time

00:27:21.880 --> 00:27:24.157
in their free time to make some stuff

00:27:24.240 --> 00:27:26.320
in the production a little bit faster.

00:27:29.440 --> 00:27:32.637
Just let some dedicated people handle it

00:27:32.720 --> 00:27:34.956
because it is going to consume a lot of time

00:27:35.039 --> 00:27:36.840
to make it happen correctly.

00:27:37.120 --> 00:27:40.360
So, this is the generic code in our code base.

00:27:41.320 --> 00:27:44.320
You can see that we have complex stuff

00:27:44.640 --> 00:27:49.076
from real code base, from real open source library,

00:27:49.159 --> 00:27:51.400
and this is just like the generic.

00:27:51.600 --> 00:27:54.196
There's a generic that accept it here,

00:27:54.279 --> 00:27:58.316
and then we do several like 3,000 or 4,000 lines

00:27:58.399 --> 00:28:00.600
of type to make stuff happen.

00:28:00.960 --> 00:28:04.800
So, you can see that it is actually code base in Elysia.

00:28:05.240 --> 00:28:07.357
I don't recommend you to look at it

00:28:07.440 --> 00:28:09.720
if you aren't familiar with TypeScript.

00:28:09.840 --> 00:28:11.917
But this pattern make a lot of things possible,

00:28:12.000 --> 00:28:16.120
like tRPC, Zod, Prisma, Drizzle, and Elysia itself.

00:28:17.799 --> 00:28:20.880
So, the second one is transformer.

00:28:21.159 --> 00:28:22.320
You may ask, what is it?

00:28:24.039 --> 00:28:29.119
This is actually the less known way to make it happen.

00:28:29.399 --> 00:28:32.039
The first way is that we write a code

00:28:32.919 --> 00:28:35.120
and transform it to type, right?

00:28:35.320 --> 00:28:38.279
But in this approach,

00:28:38.399 --> 00:28:40.000
we say that we have a type,

00:28:40.440 --> 00:28:42.200
and then we turn it into a code.

00:28:42.880 --> 00:28:45.360
So, how is that possible, right?

00:28:46.000 --> 00:28:49.519
Actually, there's some library called typia

00:28:50.080 --> 00:28:54.157
or typespec or io-ts that you can define a type

00:28:54.240 --> 00:28:54.760
in TypeScript,

00:28:55.200 --> 00:28:57.840
and then you can use that type in runtime.

00:29:00.559 --> 00:29:02.239
How is that possible, you may ask?

00:29:02.600 --> 00:29:09.277
TypeScript actually let you access the AST parser

00:29:09.360 --> 00:29:12.199
and then transform it into something else.

00:29:14.720 --> 00:29:16.000
If you are familiar with AST,

00:29:16.480 --> 00:29:18.237
then I recommend you should check it out

00:29:18.320 --> 00:29:20.079
because it's actually very cool.

00:29:20.360 --> 00:29:22.480
You can do a lot of stuff with it.

00:29:22.799 --> 00:29:25.877
But you know that AST is amazing

00:29:25.960 --> 00:29:29.316
and it is very hard to handle it

00:29:29.399 --> 00:29:32.679
if you are not familiar with compiler or something like that.

00:29:34.279 --> 00:29:38.559
But the actual drawback is that

00:29:39.120 --> 00:29:45.199
although TypeScript expose the API for handle stuff like that,

00:29:45.600 --> 00:29:49.440
it doesn't actually let you run it in TypeScript itself.

00:29:49.799 --> 00:29:53.157
You have to install some additional library

00:29:53.240 --> 00:29:54.320
called ttypescript

00:29:54.880 --> 00:29:58.677
and then you add the plugin into the compiler plugin

00:29:58.760 --> 00:30:01.480
in TS config to make it happen.

00:30:02.919 --> 00:30:05.119
Because TypeScript doesn't support it natively,

00:30:05.399 --> 00:30:07.397
a lot of people aren't using it

00:30:07.480 --> 00:30:11.357
because they want to rely on TypeScript itself,

00:30:11.440 --> 00:30:13.759
not some external runtime.

00:30:14.760 --> 00:30:21.277
So what happened if we took type inference to the limit,

00:30:21.360 --> 00:30:22.480
you may ask?

00:30:24.240 --> 00:30:28.079
We have a little project that I did in my free time.

00:30:28.679 --> 00:30:31.596
The first one I published maybe a year ago

00:30:31.679 --> 00:30:34.719
is called GraphQL Mobius,

00:30:35.840 --> 00:30:38.277
which allowed us to transform

00:30:38.360 --> 00:30:40.679
the string of the GraphQL into the type.

00:30:40.840 --> 00:30:43.476
You can see upward here that

00:30:43.559 --> 00:30:46.520
we have type definition writing in GraphQL

00:30:46.880 --> 00:30:49.237
and then we pass it into class called Mobius

00:30:49.320 --> 00:30:50.799
and then it generate the type.

00:30:52.039 --> 00:30:55.800
Actually this doesn't run any type,

00:30:56.159 --> 00:31:00.960
but we are actually using pattern matching in TypeScript

00:31:01.200 --> 00:31:05.603
in type level TypeScript to create something like AST

00:31:06.279 --> 00:31:07.799
and then pass it to the type.

00:31:09.120 --> 00:31:12.120
This doesn't involve any runtime code at all.

00:31:12.240 --> 00:31:14.716
There's no code generation, there's nothing.

00:31:14.799 --> 00:31:15.600
You don't need a CLI,

00:31:15.799 --> 00:31:18.436
you can just pass the type to the interface

00:31:18.519 --> 00:31:22.357
and then it create an AST syntax tree

00:31:22.440 --> 00:31:24.119
and then you can pass into the type.

00:31:24.960 --> 00:31:27.997
So you can actually create a compiler

00:31:28.080 --> 00:31:31.836
using pattern matching if you are crazy enough

00:31:31.919 --> 00:31:34.279
like what I did.

00:31:35.639 --> 00:31:39.757
But we can also pass SQL to a type as well,

00:31:39.840 --> 00:31:42.839
not only limited to GraphQL.

00:31:43.279 --> 00:31:47.600
So this pattern actually also applicable to gRPC

00:31:47.760 --> 00:31:52.119
and something else if you are crazy enough.

00:31:55.159 --> 00:31:56.836
I published both of these in GitHub

00:31:56.919 --> 00:32:01.120
and in my Twitter as well if you are interested.

00:32:01.240 --> 00:32:04.997
But the point is that we can make sure

00:32:05.080 --> 00:32:10.797
that everything works like we just want auto completion

00:32:10.880 --> 00:32:16.280
and then want some type safety when we try to run it.

00:32:17.960 --> 00:32:20.199
But let's talk about limitation.

00:32:21.360 --> 00:32:24.716
We already know that TypeScript doesn't actually check the type.

00:32:24.799 --> 00:32:28.039
So we have to maintain the runtime and the type as well.

00:32:28.480 --> 00:32:30.956
So what is the other limitation?

00:32:31.039 --> 00:32:35.959
Why can't we write everything in type level?

00:32:37.919 --> 00:32:43.119
Actually, there's a limit let me talk about a little bit.

00:32:44.159 --> 00:32:46.997
This is Elysia code that we can pass the body

00:32:47.080 --> 00:32:49.560
and then it infer type into the handler.

00:32:50.600 --> 00:32:53.956
You can imagine this as Express.js or Fastify

00:32:54.039 --> 00:32:57.556
or somewhere else that we have some path

00:32:57.639 --> 00:32:58.880
and then we have some body.

00:32:59.120 --> 00:33:01.160
We want to make sure that the body work.

00:33:01.360 --> 00:33:06.397
We just pass the type and then it somehow check the type

00:33:06.480 --> 00:33:10.000
in the runtime and apply the type to TypeScript.

00:33:10.399 --> 00:33:12.397
It allows us to do a lot of thing,

00:33:12.480 --> 00:33:16.800
but there's a little bit of limitation.

00:33:19.639 --> 00:33:21.760
If we have been grinding LeetCode

00:33:21.960 --> 00:33:25.400
or we know about time complexity,

00:33:25.600 --> 00:33:28.716
the type also has the time complexity

00:33:28.799 --> 00:33:32.080
and the delay that it can run.

00:33:32.880 --> 00:33:35.559
Let's say that we have a very large type

00:33:35.760 --> 00:33:37.680
and does a lot of recursive stuff.

00:33:38.000 --> 00:33:42.119
It is going to slow our code base down a little bit.

00:33:44.279 --> 00:33:46.157
If we use TypeScript a lot,

00:33:46.240 --> 00:33:50.440
maybe we can see that our VS Code or IDE sometimes

00:33:51.760 --> 00:33:54.080
take a little bit of time to apply change

00:33:54.440 --> 00:33:56.480
or trying to start a project.

00:33:56.720 --> 00:33:58.680
It is going to take a little bit of time

00:33:59.320 --> 00:34:01.196
because it also does stuff in the background

00:34:01.279 --> 00:34:02.119
that we can't see.

00:34:03.720 --> 00:34:07.200
Let me introduce you to some CLI

00:34:07.880 --> 00:34:09.836
that can help us visualize

00:34:09.919 --> 00:34:14.080
how long our TypeScript type take to run.

00:34:14.879 --> 00:34:17.040
If we run this command in your CLI

00:34:17.720 --> 00:34:22.516
and then it is going to generate some graph like this.

00:34:22.599 --> 00:34:30.477
We can inspect that which file,

00:34:30.560 --> 00:34:35.237
on the bottom right, you can see which file

00:34:35.320 --> 00:34:39.159
use how long the time.

00:34:40.599 --> 00:34:45.119
So this file use around 300

00:34:47.679 --> 00:34:49.520
And 66 milliseconds to type check.

00:34:49.839 --> 00:34:55.957
And imagine that we have thousands of TypeScript files.

00:34:56.040 --> 00:34:58.439
It is going to slow us down.

00:34:58.680 --> 00:35:02.237
So we can't actually run a lot of type here

00:35:02.320 --> 00:35:05.160
because it is going to slow the end user down.

00:35:07.079 --> 00:35:09.437
It also has a limitation as well.

00:35:09.520 --> 00:35:13.317
But one of the interesting things working with type

00:35:13.400 --> 00:35:17.280
is that when you know you have the limitation,

00:35:17.960 --> 00:35:20.639
you need to optimize the code.

00:35:21.079 --> 00:35:22.797
So in the previous year,

00:35:22.880 --> 00:35:29.117
we optimized Elysia from taking one and a half seconds

00:35:29.200 --> 00:35:31.677
down to 400 milliseconds.

00:35:31.760 --> 00:35:36.437
We have to think about how our code runs

00:35:36.520 --> 00:35:37.960
in the type level a lot.

00:35:39.839 --> 00:35:41.239
If you are not careful,

00:35:41.400 --> 00:35:47.040
we are going to have TypeScript type stack limitation.

00:35:47.720 --> 00:35:50.397
If you apply too much type to TypeScript,

00:35:50.480 --> 00:35:58.720
it might say that TypeScript has a stack of 30,000,

00:36:00.960 --> 00:36:02.440
which is just a made-up number.

00:36:03.520 --> 00:36:08.960
But if we run a recursive type in one function,

00:36:10.119 --> 00:36:15.756
and it does some stuff in the background

00:36:15.839 --> 00:36:20.717
that calls after 30,000 times,

00:36:20.800 --> 00:36:26.077
it will throw an error saying the type is infinite

00:36:26.160 --> 00:36:30.040
or it took too long to check the type.

00:36:30.160 --> 00:36:33.637
So TypeScript just assumes that maybe this type

00:36:33.720 --> 00:36:38.157
doesn't work because it has some recursive type

00:36:38.240 --> 00:36:43.200
happening that doesn't know when to end.

00:36:44.240 --> 00:36:46.720
But this also applies to functional programming.

00:36:46.880 --> 00:36:51.600
Maybe you have some loop that you forgot to exit,

00:36:51.720 --> 00:36:55.480
and it throws an error because it's too long

00:36:56.079 --> 00:36:56.920
to compute.

00:36:58.280 --> 00:37:05.239
So talking about a lot of stuff here,

00:37:05.560 --> 00:37:09.960
we can see that we can make a lot with TypeScript,

00:37:10.200 --> 00:37:12.280
but how about the future?

00:37:12.760 --> 00:37:14.880
Can it really be type safe?

00:37:16.560 --> 00:37:17.996
From my own perspective,

00:37:18.079 --> 00:37:19.400
maybe not yet.

00:37:19.920 --> 00:37:23.360
It might be possible to make TypeScript behave

00:37:23.720 --> 00:37:25.797
like a strong type language,

00:37:25.880 --> 00:37:27.120
but we aren't there yet.

00:37:27.240 --> 00:37:29.520
At least maybe two or three years

00:37:31.440 --> 00:37:32.399
from what I can see.

00:37:33.000 --> 00:37:35.400
Maybe five years or 10 years, we don't know.

00:37:37.119 --> 00:37:41.880
But what we can do now is apply runtime validation

00:37:42.000 --> 00:37:44.077
and then infer a type to TypeScript

00:37:44.160 --> 00:37:50.360
to try to make type as accurate as possible.

00:37:52.079 --> 00:37:54.520
It is actually what Zod has been trying to do,

00:37:55.400 --> 00:37:57.960
and other libraries as well,

00:37:58.240 --> 00:38:02.200
which I usually call "an illusion of type safety."

00:38:04.200 --> 00:38:08.759
Because this code isn't actually type safe.

00:38:09.280 --> 00:38:15.317
If we have some complex stuff and Zod has some bug,

00:38:15.400 --> 00:38:19.637
let's say Zod somehow can't check if the username

00:38:19.720 --> 00:38:20.760
is string or not,

00:38:22.240 --> 00:38:24.200
it creates a mismatch between runtime

00:38:25.000 --> 00:38:26.560
and the type level.

00:38:30.079 --> 00:38:31.319
JavaScript can't check it.

00:38:31.560 --> 00:38:33.077
So if the library has a bug,

00:38:33.160 --> 00:38:36.680
it's going to be out of sync on the type.

00:38:36.839 --> 00:38:40.800
So we actually don't have type safety built in yet,

00:38:41.000 --> 00:38:43.920
but we are almost there.

00:38:46.000 --> 00:38:48.359
We could only create an illusion,

00:38:49.480 --> 00:38:52.520
like it does look like it is type safe,

00:38:52.680 --> 00:38:55.320
but it isn't actually type safe

00:38:55.440 --> 00:38:59.280
because it isn't built into the language itself.

00:38:59.800 --> 00:39:03.880
But we are very close to making it possible.

00:39:04.680 --> 00:39:08.797
With community libraries like Zod,

00:39:08.880 --> 00:39:10.880
and companies like Prisma and Drizzle

00:39:11.440 --> 00:39:15.877
have been trying to aggressively use TypeScript

00:39:15.960 --> 00:39:18.760
to make an illusion of TypeScript

00:39:18.880 --> 00:39:21.280
look as real as possible.

00:39:23.880 --> 00:39:25.040
We are almost there.

00:39:25.240 --> 00:39:29.036
But for now, we can just rely on the library

00:39:29.119 --> 00:39:31.197
to make sure that every type stuff

00:39:31.280 --> 00:39:35.477
and every magic stuff actually works,

00:39:35.560 --> 00:39:38.600
and we can only trust the library to make it work.

00:39:39.440 --> 00:39:41.680
But how about the source?

00:39:42.400 --> 00:39:46.920
The source is... yeah, trust me, bro.

00:39:48.640 --> 00:39:51.840
But actually the source is you.

00:39:52.440 --> 00:39:55.720
The source is you because if you think about it,

00:39:56.200 --> 00:40:01.437
we are relying on open source maintainer to maintain

00:40:01.520 --> 00:40:02.720
our type, right?

00:40:02.839 --> 00:40:08.236
And if the situation that I put up like maybe

00:40:08.319 --> 00:40:11.880
the type of source are out of sync, they have some bug,

00:40:12.920 --> 00:40:16.239
you have the ability to report the bug to the maintainer

00:40:16.359 --> 00:40:22.800
to file an issue and let them fix it.

00:40:23.200 --> 00:40:27.077
That's how you can help TypeScript and JavaScript

00:40:27.160 --> 00:40:31.479
like illusion of type as real as possible because

00:40:32.520 --> 00:40:35.957
it is almost impossible to make TypeScript really

00:40:36.040 --> 00:40:37.319
type-safe.

00:40:37.640 --> 00:40:40.917
But we can take a little bit part of ourselves

00:40:41.000 --> 00:40:44.640
and trying to find an issue, trying to solve it

00:40:44.839 --> 00:40:46.480
as a community together.

00:40:46.720 --> 00:40:52.159
So we are trying to get closer and closer to that reality.

00:40:53.520 --> 00:40:58.920
And the most important part is that please file an issue,

00:40:59.040 --> 00:41:01.276
please talk to the open source maintainer,

00:41:01.359 --> 00:41:05.040
please trying to connect with the library,

00:41:05.200 --> 00:41:07.236
with the maintainer of the library you are using

00:41:07.319 --> 00:41:09.080
because it is going to help a lot.

00:41:09.760 --> 00:41:13.000
Also it doesn't have to be financially,

00:41:13.520 --> 00:41:18.477
just maybe hang around and sometimes just file a bug

00:41:18.560 --> 00:41:19.719
or something like that.

00:41:20.160 --> 00:41:24.236
But there's also something called open source pledge

00:41:24.319 --> 00:41:29.317
which say that your company does a lot of like maybe

00:41:29.400 --> 00:41:30.677
million dollar per year,

00:41:30.760 --> 00:41:33.640
maybe we can just donate a little bit like maybe

00:41:35.079 --> 00:41:38.157
$10 a month or $100 a month to open source maintainer

00:41:38.240 --> 00:41:38.996
that we are using.

00:41:39.079 --> 00:41:44.040
Because this problem are very real like if you know

00:41:45.400 --> 00:41:50.960
what does it call like XKCD or something like that.

00:41:52.040 --> 00:41:55.877
Yeah, I think we already know like XKCD also highlight

00:41:55.960 --> 00:42:01.120
that our industry are relying on some effort of

00:42:01.920 --> 00:42:05.236
part-time open source maintainer that doesn't actually

00:42:05.319 --> 00:42:06.560
get any money at all.

00:42:06.839 --> 00:42:11.440
And then if the project fail or like we can see that

00:42:12.760 --> 00:42:14.756
if the project fail like maybe the maintainer

00:42:14.839 --> 00:42:17.120
don't want to maintain the project anymore,

00:42:17.800 --> 00:42:20.117
the industry are going to collapse and then we have

00:42:20.200 --> 00:42:22.280
a supply chain attack and something like that.

00:42:22.599 --> 00:42:26.877
But please really just connect with open source maintainer

00:42:26.960 --> 00:42:28.880
that maintain that you are using.

00:42:29.400 --> 00:42:36.476
So also shout out to Scalar that we are since I am

00:42:36.559 --> 00:42:39.677
maintainer of Elysia, I also benefit from this

00:42:39.760 --> 00:42:41.319
open source pledge.

00:42:43.200 --> 00:42:45.637
There's something called Scalar which is like

00:42:45.720 --> 00:42:47.877
a Swagger UI alternative.

00:42:47.960 --> 00:42:50.319
So they trying to connect with us.

00:42:50.800 --> 00:42:53.280
At first, they trying to connect with us and then

00:42:54.000 --> 00:42:56.959
they also help us maintain our Swagger package

00:42:57.440 --> 00:43:04.276
and then also maybe they also ask like some kind of idea

00:43:04.359 --> 00:43:07.036
like how do you feel about the project,

00:43:07.119 --> 00:43:09.480
like how may we improve it or something like that.

00:43:09.640 --> 00:43:14.117
And then they also apply to the open source pledge

00:43:14.200 --> 00:43:17.877
and help me maintain and like Elysia in general.

00:43:17.960 --> 00:43:20.877
So I think that's it for today for me.

00:43:20.960 --> 00:43:25.840
So congratulations for going through like a very long time.

00:43:29.520 --> 00:43:32.840
So if you have any question, feel free to ask.

00:43:33.520 --> 00:43:37.560
Also, พี่ช้าง doesn't actually send the QR code yet.

00:43:38.839 --> 00:43:43.120
We will change the computer to have scanner over here.

00:43:43.240 --> 00:43:46.397
Okay, so if you have any question, feel free to ask.

00:43:46.480 --> 00:43:47.280
Any question?

00:43:48.720 --> 00:43:49.476
Yeah, sure.

00:43:49.559 --> 00:43:50.400
What is it?

00:43:54.559 --> 00:43:58.317
Yeah, so well as you mention your project Elysia

00:43:58.400 --> 00:44:00.600
and you mentioned code safety.

00:44:01.200 --> 00:44:04.560
When you are working on a large complex project

00:44:04.839 --> 00:44:07.797
with larger codebases like Elysia,

00:44:07.880 --> 00:44:10.640
how do you maintain code safety in your project?

00:44:12.640 --> 00:44:17.357
Yeah, actually since we have a lot of complex type

00:44:17.440 --> 00:44:20.040
like 3 to 4,000 line of type,

00:44:20.880 --> 00:44:27.717
I try to break it down from a very long line of type

00:44:27.800 --> 00:44:30.920
to maybe a little bit smaller of utility type

00:44:31.079 --> 00:44:33.317
that I can write a unit test on.

00:44:33.400 --> 00:44:38.560
So let's say that I have something like this.

00:44:39.240 --> 00:44:40.520
Give me a second.

00:44:40.960 --> 00:44:42.317
Okay, I have something like this, right?

00:44:42.400 --> 00:44:44.877
That I can input the shape of an object

00:44:44.960 --> 00:44:46.479
and then infer it to the body.

00:44:46.839 --> 00:44:50.597
So at first, I doesn't write the test

00:44:50.680 --> 00:44:53.557
or doesn't write the feature to make this possible

00:44:53.640 --> 00:44:54.360
at first.

00:44:54.480 --> 00:44:57.077
At first, I was just like I write something like

00:44:57.160 --> 00:45:00.677
𝚝.𝚘𝚋𝚓𝚎𝚌𝚝 and then trying to make a unit test

00:45:00.760 --> 00:45:02.440
with it to see if it work.

00:45:02.599 --> 00:45:06.516
If it work, then I can maybe try to generic

00:45:06.599 --> 00:45:08.919
to the method patch here to see that

00:45:09.200 --> 00:45:12.677
if it infer type from here and if it work,

00:45:12.760 --> 00:45:14.557
I write a unit test for that.

00:45:14.640 --> 00:45:18.239
And then if it work, I try to gradually apply.

00:45:18.440 --> 00:45:22.597
I think you know the concept, but I think we just like

00:45:22.680 --> 00:45:25.437
maybe if you are not sure like if you have a complex type

00:45:25.520 --> 00:45:29.800
and then we need to make it actually accurate,

00:45:29.920 --> 00:45:32.520
maybe we can write a unit test for that.

00:45:34.960 --> 00:45:36.516
Okay, thank you so much.

00:45:36.599 --> 00:45:37.797
Another question?

00:45:37.880 --> 00:45:38.357
Yep, sure.

00:45:38.440 --> 00:45:38.619
Alright.

00:45:38.799 --> 00:45:39.797
Okay, wait.

00:45:47.176 --> 00:45:47.557
Yeah sure.

00:45:47.640 --> 00:45:54.036
So you talk about your optimization on your library, right?

00:45:54.119 --> 00:45:54.519
Yeah.

00:46:08.440 --> 00:46:10.079
Yeah, in type level, right?

00:46:10.400 --> 00:46:10.917
Right right right.

00:46:11.000 --> 00:46:14.400
Okay. So there's actually a lot of stuff.

00:46:15.160 --> 00:46:18.680
The first thing first is that the big O notation.

00:46:18.880 --> 00:46:22.280
If we grind LeetCode, there's like some algorithm

00:46:22.880 --> 00:46:24.639
to like make some stuff faster,

00:46:24.960 --> 00:46:29.117
but which is is a part of what make this possible.

00:46:29.200 --> 00:46:31.717
The second one is that TypeScript actually provide

00:46:31.800 --> 00:46:35.079
a lot of stuff like there's something called

00:46:35.240 --> 00:46:39.756
invariance and covariance that it actually allowed us

00:46:39.839 --> 00:46:44.516
to like make how it is a little bit complex,

00:46:44.599 --> 00:46:47.999
but in a nutshell, it actually allowed us to like

00:46:48.200 --> 00:46:51.240
make the union and intersection a little bit faster.

00:46:51.680 --> 00:46:55.797
And since every method in Elysia somehow return

00:46:55.880 --> 00:47:00.917
a new type, a little bit of invariance that maybe

00:47:01.000 --> 00:47:06.996
boost up 20% or 30% each somehow gradually build up

00:47:07.079 --> 00:47:09.959
into a smaller type here.

00:47:10.240 --> 00:47:14.197
But we also actually have a blog post written

00:47:14.280 --> 00:47:15.157
for this as well.

00:47:15.240 --> 00:47:24.360
So like if we go to elysia.js and then we go to blog,

00:47:24.680 --> 00:47:29.197
and then in this one, and then in type inference

00:47:29.280 --> 00:47:33.717
improvement, we have oh did I wrote it here?

00:47:33.800 --> 00:47:35.557
Okay, sorry, wrong one.

00:47:35.640 --> 00:47:36.599
Okay, this one.

00:47:40.400 --> 00:47:43.960
Maybe give me a little bit of time.

00:47:44.800 --> 00:47:47.160
Maybe this one.

00:47:47.920 --> 00:47:51.360
Actually, I forgot, but it is somewhere in this

00:47:51.920 --> 00:47:55.476
Improves startup time.

00:47:55.559 --> 00:47:56.879
I think maybe this one.

00:47:58.160 --> 00:48:00.120
Yeah, but okay, here.

00:48:00.640 --> 00:48:09.160
I think it should be linked to my Twitter,

00:48:09.400 --> 00:48:12.599
but I can't find it, but it is somewhere

00:48:13.680 --> 00:48:16.276
in one of these blog posts, which I can't find,

00:48:16.359 --> 00:48:17.917
but is somewhere here.

00:48:18.000 --> 00:48:21.717
But to recap, it is actually big O notation

00:48:21.800 --> 00:48:22.677
that we can improve.

00:48:22.760 --> 00:48:26.476
And the second one is that covariance and invariance,

00:48:26.559 --> 00:48:29.077
which is some annotation called in and out.

00:48:29.160 --> 00:48:33.677
The third one are constant generic, which when you try

00:48:33.760 --> 00:48:37.077
to infer a type from an object, it is going to infer

00:48:37.160 --> 00:48:42.320
as some mutable type, but you can also say that

00:48:42.440 --> 00:48:44.157
the type doesn't have to change.

00:48:44.240 --> 00:48:48.117
It is if the type doesn't change, it can maybe help

00:48:48.200 --> 00:48:51.200
improve type inference a little bit faster.

00:48:51.640 --> 00:48:56.480
The fourth one are the generic itself.

00:48:56.920 --> 00:49:06.837
So if we go to this slide here somewhere here.

00:49:06.920 --> 00:49:07.959
Okay, somewhere here.

00:49:08.520 --> 00:49:08.840
Yeah.

00:49:09.920 --> 00:49:13.476
Actually, this one you can see that we have a lot of

00:49:13.559 --> 00:49:17.797
generic parameter here like eight or around eight

00:49:17.880 --> 00:49:19.079
parameter, right?

00:49:19.440 --> 00:49:24.359
But if you think about it, we can at first glance,

00:49:27.119 --> 00:49:28.920
we can make it just one parameter.

00:49:29.079 --> 00:49:32.440
So like why do we need to have eight parameter here?

00:49:33.000 --> 00:49:37.280
The first one is that there's something called

00:49:37.640 --> 00:49:39.957
inference constructor inference.

00:49:40.040 --> 00:49:43.397
So like let's say that if you have a constructor,

00:49:43.480 --> 00:49:47.597
let's say the constructor first we create

00:49:47.680 --> 00:49:52.036
a new instance, and then say that if this class

00:49:52.119 --> 00:49:55.599
has a prefix, we can pass it into the object, right?

00:49:56.040 --> 00:49:59.957
But in this case, if the parameter only require

00:50:00.040 --> 00:50:02.476
the type to be string, it doesn't make sense

00:50:02.559 --> 00:50:05.320
to make the object to infer the type from.

00:50:05.760 --> 00:50:09.397
So like we have to separate all of the parameter

00:50:09.480 --> 00:50:13.440
that need to be memorized into each individual field

00:50:13.640 --> 00:50:16.957
to reduce the complexity of the type and reduce

00:50:17.040 --> 00:50:23.756
the big O notation in the first thing

00:50:23.839 --> 00:50:24.756
that I mentioned.

00:50:24.839 --> 00:50:29.917
So like there's a lot of stuff to think about

00:50:30.000 --> 00:50:33.199
when you write a type like constant generic here

00:50:33.359 --> 00:50:37.557
and covariance parameter here and a lot of stuff

00:50:37.640 --> 00:50:43.077
like that which actually, you can check out

00:50:43.160 --> 00:50:45.837
the guide on the TypeScript documentation.

00:50:45.920 --> 00:50:49.157
They wrote something like tail call optimization

00:50:49.240 --> 00:50:52.077
for type and a lot of stuff that can help our time

00:50:52.160 --> 00:50:53.720
to make to get it faster.

00:50:53.839 --> 00:50:56.197
You can search it in TypeScript documentation.

00:50:56.280 --> 00:51:04.639
There's a section written for that.

00:51:05.720 --> 00:51:06.200
Thank you.

00:51:07.040 --> 00:51:09.557
Last question, me?

00:51:09.640 --> 00:51:10.397
Yeah.

00:51:10.480 --> 00:51:13.160
Anyone has a question?

00:51:13.520 --> 00:51:13.837
Again?

00:51:13.920 --> 00:51:14.519
Okay, sure.

00:51:15.839 --> 00:51:20.040
You want to ask a question?

00:51:22.359 --> 00:51:24.957
What will be the name of the next major release

00:51:25.040 --> 00:51:26.759
of Elysia?

00:51:28.760 --> 00:51:31.480
Okay, let's recap.

00:51:33.000 --> 00:51:38.280
Every release in Elysia has the name.

00:51:40.520 --> 00:51:42.279
This is inspired from Vue.js.

00:51:42.559 --> 00:51:45.357
You know that every major Vue release also have

00:51:45.440 --> 00:51:47.476
a name for that release.

00:51:47.559 --> 00:51:49.760
They name after the anime.

00:51:50.319 --> 00:51:52.480
The latest one are like
[Quintessential Quintuplets].

00:51:54.119 --> 00:51:56.720
The latest one are also name after the anime.

00:51:57.640 --> 00:52:01.276
If we look from here, from every block release

00:52:01.359 --> 00:52:04.120
version, you can see that we have some name

00:52:04.319 --> 00:52:05.560
after the version.

00:52:05.799 --> 00:52:11.317
The first one are The Blessing from YOASOBI.

00:52:11.400 --> 00:52:13.520
I think from YOASOBI, from this song.

00:52:13.640 --> 00:52:16.837
I'm not going to meme it, but I think a lot of

00:52:16.920 --> 00:52:19.239
people know the song.

00:52:21.480 --> 00:52:24.157
Every major release follow the same naming

00:52:24.240 --> 00:52:25.120
convention.

00:52:27.839 --> 00:52:28.720
Back to the question.

00:52:30.079 --> 00:52:33.240
The next major release are called Supersymmetry.

00:52:33.720 --> 00:52:37.437
They are from Supersymmetry from game called

00:52:37.520 --> 00:52:38.399
Tone Sphere.

00:52:49.480 --> 00:52:51.557
If you play some rhythm game, I think a lot of

00:52:51.640 --> 00:52:53.239
people may know it.

00:52:53.640 --> 00:52:56.400
But otherwise, it is a very nice song.

00:52:59.599 --> 00:53:02.157
The reason that I pick this name for the next

00:53:02.240 --> 00:53:05.557
version is that, in the next major release of

00:53:05.640 --> 00:53:08.597
Elysia version, we are focusing on adapter and

00:53:08.680 --> 00:53:10.200
multiple runtime support.

00:53:11.240 --> 00:53:15.920
Currently Elysia can mainly run on Bun, but maybe

00:53:16.280 --> 00:53:18.957
you can also run it in Deno if you can hack the

00:53:19.040 --> 00:53:21.319
type and hack the runtime stuff.

00:53:21.680 --> 00:53:24.276
But in the next version, we are trying to make it

00:53:24.359 --> 00:53:27.437
possible to run in Node.js as well and trying to

00:53:27.520 --> 00:53:31.476
make it possible to run in many runtime as

00:53:31.559 --> 00:53:32.279
possible.

00:53:33.160 --> 00:53:38.236
The name Supersymmetry are from some theoretical

00:53:38.319 --> 00:53:44.437
concept that, in a nutshell, there's two version

00:53:44.520 --> 00:53:45.520
of the same thing.

00:53:46.599 --> 00:53:49.437
So you have one version in Bun and you also have

00:53:49.520 --> 00:53:53.839
the other version in Node that exist in parallel.

00:53:54.640 --> 00:53:56.159
That's the name of the next version.

00:53:57.760 --> 00:53:58.000
Yay!
