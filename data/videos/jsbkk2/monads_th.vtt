WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:00.080 --> 00:00:00.480
โอเคครับ

00:00:01.280 --> 00:00:03.277
สวัสดีทุกท่านอีกรอบนึงนะครับ

00:00:03.360 --> 00:00:06.756
โอเควันนี้ผมเป็นตัวแทนจาก ODDS เนาะ

00:00:06.839 --> 00:00:08.239
มาพูดใน session ของ ODDS

00:00:08.880 --> 00:00:12.197
หัวข้อที่จะพูดในวันนี้ก็คือ Monad in JavaScript นะครับ

00:00:12.280 --> 00:00:15.077
แต่จริงๆ แล้วผมลองดูแล้ว JavaScript เนี่ย

00:00:15.160 --> 00:00:17.080
ถ้าจะอธิบาย Monad มันยากเนาะ

00:00:17.520 --> 00:00:19.917
ก็เลยขอเปลี่ยนเป็น TypeScript แทนเนาะ

00:00:20.000 --> 00:00:22.077
ทุกคนก็น่าจะคุ้นเคยกันอยู่แล้ว TypeScript

00:00:22.160 --> 00:00:24.560
เพื่อให้มันเห็น type เห็นอะไรได้มากขึ้นนะครับ

00:00:25.760 --> 00:00:29.839
โอเค ก็วันนี้ผมก็จะเล่า Monad ง่ายๆ เนาะ

00:00:30.039 --> 00:00:34.960
ให้ทุกคนที่ยังไม่รู้จักเนี่ย ได้เห็นภาพได้มากขึ้นนะครับ

00:00:35.640 --> 00:00:37.357
โอเคแนะนำตัวนะครับ

00:00:37.440 --> 00:00:39.156
ผมชื่อเจนะครับ

00:00:39.239 --> 00:00:42.277
ทำงานเป็น technical coach อยู่ที่ ODDS นะครับ

00:00:42.360 --> 00:00:48.039
ถ้าใครอยากจะ connect ก็ add Facebook นี้ได้เลยนะครับ

00:00:48.719 --> 00:00:51.119
โอเคมาเริ่มกันเลยเนาะ

00:00:51.879 --> 00:00:56.677
สำหรับคนที่เคยจะศึกษา functional programming อ่ะ

00:00:56.760 --> 00:01:00.626
พอถึงจุดๆ นึงอ่ะ เราก็คงจะเริ่มรู้จัก Monad

00:01:00.866 --> 00:01:04.479
และต้องไปหาว่า Monad คืออะไร ทำไมทุกคนพูดถึงใช่ป่ะ

00:01:05.119 --> 00:01:10.237
พอเราไปศึกษาเนี่ย สิ่งแรกที่เรา search เจอก็คือประโยคนี้ใช่ป่ะ

00:01:10.320 --> 00:01:14.760
ก็คือ "A monad is just a monoid in the category of endofunctors"

00:01:15.759 --> 00:01:17.076
มันไม่ได้บอกอะไรเราเลยเนาะ

00:01:17.159 --> 00:01:19.036
เพราะว่าเรา search ว่า Monad คืออะไรเนี่ย

00:01:19.119 --> 00:01:21.157
มันลากเพื่อนมาอีก 3-4 ตัวเนี่ย

00:01:21.240 --> 00:01:22.880
Monoid, category, endofunctor

00:01:23.640 --> 00:01:28.637
ซึ่งถ้าคนที่ไม่ได้ศึกษาทางทฤษฎีทางคณิตศาสตร์อ่ะ

00:01:28.720 --> 00:01:29.996
ก็จะไม่เข้าใจหรอกมันคืออะไร

00:01:30.079 --> 00:01:31.917
หรือว่าแม้ว่าเราจะไป search ต่อเนี่ย

00:01:32.000 --> 00:01:34.479
เราก็จะเจออะไรหน้าตาแบบนี้เนาะ

00:01:35.159 --> 00:01:37.517
มาเป็นแบบ notation ทางคณิตเต็มเลย

00:01:37.600 --> 00:01:41.800
ซึ่งถ้าเป็น developer เราก็คงไม่ค่อยมีความรู้ทางนี้มากใช่ป่ะ

00:01:42.640 --> 00:01:46.560
โอเค อ่ะ ก็จะสังเกตเห็นได้ว่า

00:01:46.920 --> 00:01:48.157
ถ้าเราเป็น developer เนี่ย

00:01:48.240 --> 00:01:50.076
การที่เราจะศึกษา functional programming

00:01:50.159 --> 00:01:53.759
โดยที่จะไม่มีแบบใครมา guide อ่ะ มันก็จะยากเนาะ

00:01:53.880 --> 00:01:55.480
มีกำแพงหนาๆ อยู่ตัวนึง

00:01:55.680 --> 00:01:57.316
เพราะฉะนั้นเดี๋ยววันนี้

00:01:57.399 --> 00:01:58.837
เราจะมาดูกันว่ามันเป็นยังไงเนาะ

00:01:58.920 --> 00:02:00.956
ให้เราวางทฤษฎีเอาไว้ก่อน

00:02:01.039 --> 00:02:03.840
เดี๋ยวมาดูอะไรง่ายๆ ที่ทุกคนน่าจะทำกันเป็นเนาะ

00:02:04.399 --> 00:02:07.237
อ่ะ ก็คือเขียนฟังก์ชันแบบง่ายๆ

00:02:07.320 --> 00:02:09.823
สำหรับคำนวณ operation ทางตัวเลขเนาะ

00:02:09.907 --> 00:02:11.557
ในนี้ผมก็จะยกตัวอย่าง 2 ตัว

00:02:11.640 --> 00:02:13.757
ก็คือมี square กับ addOne ใช่ป่ะ

00:02:13.840 --> 00:02:14.876
square ก็คือยกกำลัง

00:02:14.959 --> 00:02:18.436
addOne คือรับ input อะไรไปก็ไปบวก 1

00:02:18.519 --> 00:02:19.917
โดยที่ operation ทั้ง 2 ตัวเนี้ย

00:02:20.000 --> 00:02:24.080
ก็จะรับ input เป็น number แล้วก็ output ก็เป็น number เหมือนกัน

00:02:24.239 --> 00:02:27.199
อันนี้ก็ง่ายๆ ทุกคนน่าจะเข้าใจกันได้เนาะ

00:02:27.879 --> 00:02:30.477
แล้วพอเราได้ฟังก์ชันประมาณนี้แล้วเนี่ย

00:02:30.560 --> 00:02:32.240
เราก็เอามันไปใช้งานแบบนี้ใช่ป่ะ

00:02:33.319 --> 00:02:36.001
เราอยากจะใช้ square เราก็โยนตัวเลขเข้าไป

00:02:36.200 --> 00:02:37.840
แล้วก็ได้อะไรออกมา

00:02:38.560 --> 00:02:41.397
เราสามารถเอา output เนี่ย ไป chain กับ operation

00:02:41.480 --> 00:02:42.677
หรือฟังก์ชันอื่นๆ ได้เนาะ

00:02:42.760 --> 00:02:43.637
อันนี้ก็ไม่มีปัญหาอะไร

00:02:43.720 --> 00:02:47.522
ก็ 5 5 25 + 1 ก็ได้ 26 ตรงไปตรงมานะ

00:02:48.800 --> 00:02:49.917
แต่ถ้าในอนาคตเนี่ย

00:02:50.000 --> 00:02:54.037
เราต้องการจะ log ว่า output ของเราที่เกิดขึ้นเนี่ย

00:02:54.120 --> 00:02:57.120
มันผ่าน operation อะไรมาบ้างเนี่ย

00:02:57.360 --> 00:03:00.479
เราก็ต้องมีการแก้ code ตั้งต้นตัวนี้ของเราใช่ป่ะ

00:03:00.599 --> 00:03:01.317
เราก็ต้องแก้ว่า

00:03:01.400 --> 00:03:05.037
อ๋อแทนที่จะให้ square มัน return output

00:03:05.120 --> 00:03:07.757
ของการคูณเลขอย่างเดียวเนี่ย มันต้องทำอะไรเพิ่มนะครับ

00:03:07.840 --> 00:03:10.037
มันก็ต้อง add log เพิ่มเข้าไป

00:03:10.120 --> 00:03:12.236
แล้วก็ต้องแก้ return type เนาะ

00:03:12.319 --> 00:03:14.743
จาก number เนี่ยก็ต้องเป็น type หน้าตาประมาณนี้

00:03:14.827 --> 00:03:16.277
โอเคใช่ป่ะ

00:03:16.360 --> 00:03:18.397
อันนี้ก็ทุกคนก็น่าจะทำกันอยู่แล้วเนาะ

00:03:18.480 --> 00:03:21.357
ก็คือ refactor code เราให้มันทำงานกับ business ใหม่

00:03:21.440 --> 00:03:22.037
ที่เราต้องการ

00:03:22.120 --> 00:03:25.840
อันนี้ผมก็จะลอง refactor ดูเนาะ

00:03:27.480 --> 00:03:29.957
ผมก็จะทำการ refactor code

00:03:30.040 --> 00:03:32.440
ให้มันมี log ของ operation ที่เราทำงาน

00:03:34.200 --> 00:03:35.479
ผลลัพธ์ที่ได้ก็คือ

00:03:36.239 --> 00:03:39.356
อันที่ 1 ผมก็ต้องสร้าง type ตัวนึงใช่ป่ะ

00:03:39.439 --> 00:03:42.837
ที่บอกว่าผลลัพธ์เนี่ยมันจะประกอบไปด้วย property อะไรบ้าง

00:03:42.920 --> 00:03:44.837
ในนี้ก็ประกอบไปด้วย value

00:03:44.920 --> 00:03:47.920
ที่จะเก็บผลลัพธ์ของ operation ทางคณิตศาสตร์

00:03:48.120 --> 00:03:50.716
แล้วก็มี log อีกตัวนึงใช้เก็บ log message

00:03:50.799 --> 00:03:51.996
ที่เป็น audit log ของเราเนาะ

00:03:52.079 --> 00:03:55.879
ตัวนี้ผมตั้งชื่อว่า AuditedNumber ใช่ป่ะ

00:03:56.120 --> 00:03:58.959
แล้วเสร็จแล้วผมก็แก้ฟังก์ชัน square

00:03:59.120 --> 00:04:01.439
ให้นอกเหนือจากการคูณเลขเฉยๆ

00:04:01.799 --> 00:04:04.280
ก็มีการแปะ log message มันออกมา

00:04:04.560 --> 00:04:06.160
อันนี้ก็ตรงไปตรงมาเนาะ

00:04:06.480 --> 00:04:09.520
ก็ทำอย่างนี้กับ addOne เหมือนกัน ถูกมั้ยครับ

00:04:09.920 --> 00:04:11.957
โอเค พอเราได้อย่างนี้แล้วเนี่ย

00:04:12.040 --> 00:04:14.796
จริงๆ code มันไม่ค่อย make sense เท่าไหร่เนาะ

00:04:14.879 --> 00:04:17.159
แต่อันนี้เพื่อการอธิบายเนาะ

00:04:17.919 --> 00:04:22.960
ปัญหาที่เราเจอตรงเนี้ยก็คือ square เนี่ย 1 คือ

00:04:23.080 --> 00:04:27.676
ตอนเนี้ยพอเราแก้ result ของฟังก์ชันเนี่ย

00:04:27.759 --> 00:04:30.917
จะเห็นว่า input กับ output มันไม่เหมือนกันแล้วใช่ไหม

00:04:31.000 --> 00:04:34.040
input เป็น number output เป็น type นึง

00:04:34.800 --> 00:04:36.640
ผลที่ได้ก็คือเราเจอว่า

00:04:36.759 --> 00:04:41.040
เราไม่สามารถ chain ฟังก์ชันตัวเนี้ยเหมือนเดิมได้แล้วนะ

00:04:41.160 --> 00:04:43.396
เพราะว่า output มันเป็น audited number

00:04:43.479 --> 00:04:45.680
เราไม่สามารถเอา square เนี่ยไป chain ตัวเองได้

00:04:45.919 --> 00:04:47.920
อันนี้คือปัญหาที่ 1 ที่เราเจอนะ

00:04:48.600 --> 00:04:51.237
ปัญหาที่ 2 ก็คือ addOne เนี่ย

00:04:51.320 --> 00:04:54.477
พอเราเปลี่ยน type จาก number เป็น audited number

00:04:54.560 --> 00:04:56.400
เพื่อรับผลของ square แล้วเนี่ย

00:04:56.880 --> 00:05:00.717
มันไม่สามารถเรียกใช้ได้ด้วยค่าที่เป็น type number ปกติแล้ว

00:05:00.800 --> 00:05:04.077
โอเคนี่เป็นปัญหาที่เวลาเราแก้โค้ดเราก็จะเจอกันนะ

00:05:04.160 --> 00:05:05.116
เราก็ไม่ยากนะ

00:05:05.199 --> 00:05:07.037
อันนี้เราก็แก้ปัญหาได้ปกติทั่วไป

00:05:07.120 --> 00:05:10.277
ปัญหาที่ 1 ก็คือ ไอ้ตัว addOne เนี่ย อันเนี้ยง่าย

00:05:10.360 --> 00:05:13.400
ก็คือถ้าเราอยากจะเรียกฟังก์ชัน addOne ด้วยเลข 5

00:05:13.800 --> 00:05:16.199
เลข 5 ปกติแล้วเนี่ย เราก็ทำไงนะ

00:05:16.400 --> 00:05:18.920
เราทำฟังก์ชันใหม่ขึ้นมาตัวนึงนะ

00:05:19.280 --> 00:05:22.317
ที่สามารถ transform number ให้กลายเป็น audited number

00:05:22.400 --> 00:05:23.640
ของเราได้ใช่ไหม

00:05:23.919 --> 00:05:25.637
เราก็สามารถแก้ปัญหาว่า addOne

00:05:25.720 --> 00:05:27.560
ถ้าเราอยากจะเรียกตัวเดียวโดดๆ เนี่ยทำไง

00:05:27.759 --> 00:05:30.597
เราก็ใช้ฟังก์ชันตัวเนี้ย 𝚠𝚛𝚊𝚙𝚆𝚒𝚝𝚑𝙻𝚘𝚐 ตัวเนี้ย

00:05:30.680 --> 00:05:34.000
เป็นการสร้าง type audited number ขึ้นมาจากเลข 5 ปกติ

00:05:34.680 --> 00:05:36.836
โอเคอันนี้ก็จะแก้ปัญหาที่ 1 ได้นะ

00:05:36.919 --> 00:05:39.517
อีกปัญหานึง square เราเนี่ย

00:05:39.600 --> 00:05:41.960
ที่ input กับ output มันไม่เหมือนกันเนี่ย

00:05:42.160 --> 00:05:43.637
แล้วมันไม่สามารถ chain ตัวเองได้

00:05:43.720 --> 00:05:45.038
เราก็แก้ให้มันเหมือนกันเอง

00:05:45.160 --> 00:05:46.452
อันนี้ก็แก้ปัญหาง่ายๆ นะ

00:05:46.666 --> 00:05:49.437
เราก็จากที่เรามี 𝚠𝚛𝚊𝚙𝚆𝚒𝚝𝚑𝙻𝚘𝚐 เนี่ย

00:05:49.520 --> 00:05:53.640
เราก็สามารถสร้าง audited number เพื่อให้ใช้งานใน square ได้

00:05:53.840 --> 00:05:57.760
เราก็แก้ input type ของ square ให้กลายเป็น audited number

00:05:58.120 --> 00:06:00.556
โอเคอันนี้เราก็พอเราแก้ปัญหาได้แล้วเนี่ย

00:06:00.639 --> 00:06:03.040
ปัญหาตอนแรกที่เราเจอว่า เฮ้ยเราทำแบบนี้ไม่ได้

00:06:03.360 --> 00:06:06.600
เราก็สามารถเรียกการใช้งานฟังก์ชัน

00:06:06.960 --> 00:06:09.596
ด้วยการช่วยเหลือของฟังก์ชัน utility ตัวนี้นะ

00:06:09.679 --> 00:06:12.480
ทำให้เราสามารถมี audit log ได้แล้วว่า

00:06:12.759 --> 00:06:16.240
เราเกิดการทำงานอะไรขึ้นบ้างใน operation พวกนี้

00:06:16.880 --> 00:06:19.599
โอเค ซึ่งจริงๆ แล้วเนี่ยตรงเนี้ย

00:06:20.280 --> 00:06:23.516
มันก็โค้ดมันก็น่าจะพอขึ้น production ได้แล้วนะ

00:06:23.599 --> 00:06:26.800
เพราะว่ามันก็ทำงานได้ตาม business ที่เราต้องการ

00:06:27.240 --> 00:06:31.037
แต่จริงๆ แล้วในมุมของ software engineering เนี่ย

00:06:31.120 --> 00:06:32.840
นอกจากที่มันจะทำงานได้นะ

00:06:32.960 --> 00:06:34.680
มันก็ควรจะ make sense ด้วย

00:06:34.800 --> 00:06:36.197
โค้ดเราควรจะ make sense ด้วย

00:06:36.280 --> 00:06:38.800
เราก็เลยลองมาดูอีกว่าสิ่งที่เราทำไปเนี่ย

00:06:39.120 --> 00:06:40.519
มันเกิดอะไรขึ้นบ้างนะ

00:06:40.639 --> 00:06:44.920
โค้ด square กับ addOne เนี่ย สิ่งที่มันเกิดขึ้นคือ

00:06:45.680 --> 00:06:47.437
มันทำงานคล้ายๆ กันอยู่ใช่ไหม

00:06:47.520 --> 00:06:49.157
เรายังไม่ต้องดูว่ามันทำงานอะไรเลย

00:06:49.240 --> 00:06:50.077
แค่มองโค้ดเนี่ย

00:06:50.160 --> 00:06:52.400
เราก็จะเห็นว่าหน้าตาของโค้ดเนี่ย

00:06:52.680 --> 00:06:53.997
มันแทบจะเหมือนกันเลยใช่ไหม

00:06:54.080 --> 00:06:57.000
แสดงว่ามันอาจจะมีอะไรบางอย่าง duplicate กันอยู่

00:06:57.680 --> 00:06:59.997
โอเคนะ ซึ่งพอมัน duplicate กันเนี่ย

00:07:00.080 --> 00:07:02.959
ปกติเราก็ต้องจำแนกก่อนนะว่าอะไรดูบ้าง

00:07:03.080 --> 00:07:05.880
ในตัวอย่างเนี่ยผมจะจำแนกออกมาเป็น 3 ส่วนนะ

00:07:06.560 --> 00:07:08.839
ส่วนที่ 1 ก็คือการคำนวณเลข

00:07:09.000 --> 00:07:12.360
ทั้ง 2 operation เนี่ยมีการคำนวณเลขที่เหมือนกันเลย

00:07:13.120 --> 00:07:16.879
ส่วนที่ 2 ก็คือ มันจะทำการ concat log ของตัวเอง

00:07:17.520 --> 00:07:21.039
เข้าไปที่ input เพื่อที่จะ return ออกไป

00:07:21.879 --> 00:07:25.520
โอเคนะ เพราะงั้นไอ้พวกเนี้ยก็คือการทำงานซ้ำกัน

00:07:26.280 --> 00:07:28.999
แต่จริงๆ แล้วเรารู้กันอยู่แล้วนะว่า

00:07:30.039 --> 00:07:33.516
ฟังก์ชันที่ดีเนี่ยมันควรจะทำงานแค่อย่างใดอย่างหนึ่งใช่ไหม

00:07:33.599 --> 00:07:37.037
เพราะงั้นเราควรจะ extract โค้ดบางส่วน

00:07:37.120 --> 00:07:39.479
ที่มันไม่เกี่ยวกับฟังก์ชันนั้นออกไป

00:07:40.039 --> 00:07:43.720
โอเคนะ เราก็มาลอง refactor โค้ดกันมา

00:07:45.360 --> 00:07:46.277
ยกตัวอย่าง square นะ

00:07:46.360 --> 00:07:48.396
square addOne ตะกี้มันหน้าตาเหมือนๆ กันนะ

00:07:48.479 --> 00:07:50.760
ผมก็จะยกตัวอย่างแค่ square

00:07:51.120 --> 00:07:52.801
square เนี่ย ก่อนจะเริ่มทำการ refactor

00:07:53.319 --> 00:07:55.600
เราก็ควรจะระบุให้ได้ก่อนนะว่า

00:07:55.800 --> 00:07:58.836
จริงๆ แล้วโค้ดไหนเนี่ย เป็น logic ของ square

00:07:58.919 --> 00:08:00.839
โค้ดไหนเนี่ยไม่ใช่ของมัน

00:08:01.159 --> 00:08:03.039
ผมจะลอง refactor ให้ดู

00:08:04.599 --> 00:08:07.116
ผมแยกโค้ดออกมาและชุดที่ 1 ตรงเนี้ย

00:08:07.199 --> 00:08:09.159
ที่ผมบอกว่ามันคือ logic ของ square ก็คือ

00:08:09.560 --> 00:08:11.439
เป็นการยกกำลังเลขใช่ไหม

00:08:11.720 --> 00:08:13.877
แล้วก็มี log ของ square

00:08:13.960 --> 00:08:17.920
อันเนี้ยมันเห็นได้ชัดแล้วว่ามันเป็นโค้ดของ square จริงๆ

00:08:18.720 --> 00:08:21.836
อีกอันนึงก็คือโค้ดสำหรับ concat log ของตัวเอง

00:08:21.919 --> 00:08:25.039
ว่าทำงานอะไรออกไป ก่อนที่จะ return โค้ดออกไปนะ

00:08:25.199 --> 00:08:27.440
เคมี 2 จุดนี้นะ

00:08:28.120 --> 00:08:30.037
ซึ่งอันเนี้ย เราเห็นได้แล้วว่าไอ้เนี้ย

00:08:30.120 --> 00:08:32.436
มันไม่ make sense นะที่จะอยู่ใน square เท่าไหร่เลย

00:08:32.519 --> 00:08:34.600
เพราะว่ามันเป็นการ concat log ใช่ไหม

00:08:34.959 --> 00:08:37.400
เราก็เลยอยากจะพยายามเอามันออกไป

00:08:40.320 --> 00:08:42.959
เมื่อเรารู้แล้วว่าเราอยากจะ extract ตัวนี้ออกไป

00:08:43.120 --> 00:08:44.517
เราก็ design ฟังก์ชันนะว่า

00:08:44.600 --> 00:08:47.759
เราจะเอาฟังก์ชันแบบไหนมาลองรับการทำงานแบบนี้

00:08:48.080 --> 00:08:50.680
อันเนี้ยผมก็อยากจะตั้งชื่อมันว่า 𝚛𝚞𝚗𝚆𝚒𝚝𝚑𝙻𝚘𝚐

00:08:50.920 --> 00:08:53.397
ตัวเนี้ยผมบอกว่า ผมอยากให้เป็นฟังก์ชัน

00:08:53.480 --> 00:08:54.917
ที่รองรับการ concat log

00:08:55.000 --> 00:08:58.397
โดยที่ฟังก์ชันเนี้ย รับ input 2 ตัวนะ

00:08:58.480 --> 00:09:02.316
ตัวที่ 1 ก็คือ 𝚠𝚛𝚊𝚙𝚆𝚒𝚝𝚑𝙻𝚘𝚐 ที่รับตัวเลขอะไรบางอย่างเข้ามา

00:09:02.399 --> 00:09:04.120
เพื่อมาเป็น input parameter ตัวที่ 1

00:09:04.920 --> 00:09:09.717
อีกอันนึงคือฟังก์ชันที่จะถูก apply ด้วย parameter ตัวที่ 1 ตัวนี้

00:09:09.800 --> 00:09:12.520
เพราะฉะนั้นถ้าผมเรียกโค้ดหน้าตาแบบเนี้ย

00:09:12.800 --> 00:09:17.440
ผลที่ได้ก็คือมันจะเอา audited number ที่มีค่า 5 ใช่ไหม

00:09:18.040 --> 00:09:21.080
โยนเข้าไปในฟังก์ชัน square ได้อะไรออกมา

00:09:21.440 --> 00:09:24.000
ก่อนจะ return ให้ใส่ log ให้ด้วย

00:09:24.360 --> 00:09:26.760
โอเคไหม เพราะงั้นตอนเนี้ยโค้ดจะมีหน้าตา

00:09:27.240 --> 00:09:28.840
มีการทำงานเป็นของมันเองและ

00:09:29.880 --> 00:09:33.960
พอเรา design เสร็จแล้วนะ เราก็แยกโค้ดออกมา

00:09:34.800 --> 00:09:37.996
อันเนี้ย ตรงไปตรงมาใช่ไหมของ square ง่ายสุด

00:09:38.079 --> 00:09:41.480
แยกออกมาเลยเป็นฟังก์ชัน square เคไหม

00:09:42.240 --> 00:09:44.637
แล้วก็เราก็สร้างฟังก์ชัน 𝚛𝚞𝚗𝚆𝚒𝚝𝚑𝙻𝚘𝚐

00:09:44.720 --> 00:09:47.357
ที่รับ parameter 2 ตัวตามที่ design ไว้นะ

00:09:47.440 --> 00:09:49.037
ตัวแรกคือ audited number

00:09:49.120 --> 00:09:51.159
ตัวที่ 2 เป็นฟังก์ชัน transform

00:09:51.279 --> 00:09:54.600
แล้วก็ก่อน transform เราก็เอา logic ของการ concat log

00:09:54.959 --> 00:09:56.320
มาแปะให้มันนะ เค

00:09:58.250 --> 00:10:02.360
เราก็สามารถเรียกด้วยฟังก์ชันแบบนี้ได้แล้วใช่ไหม

00:10:02.519 --> 00:10:06.320
ตรงไปตรงมาเนาะ

00:10:07.080 --> 00:10:09.397
สุดท้าย พอเราทำเสร็จแล้วเนี่ย

00:10:09.480 --> 00:10:12.120
เราก็ไปทำกับ addOne ด้วยในภาพเดียวกันเลย

00:10:12.279 --> 00:10:14.237
เราจะได้โค้ดทั้งหมดหน้าตาประมาณนี้เนาะ

00:10:14.320 --> 00:10:17.037
เราจะมี AuditedNumber ที่เป็น type ของ result

00:10:17.120 --> 00:10:18.000
ที่เราอยากได้เนาะ

00:10:18.320 --> 00:10:22.399
เรามีฟังก์ชัน wrapWithLog ที่รับพารามิเตอร์ตัวที่ 1

00:10:22.680 --> 00:10:24.957
คือ number แล้วมันก็จะ transform ออกมาเป็น

00:10:25.040 --> 00:10:27.080
AuditedNumber โอเคไหม

00:10:27.279 --> 00:10:30.720
แล้วก็มี operation ทางคณิตศาสตร์ 2 ตัวของเราตอนแรก

00:10:31.240 --> 00:10:33.397
แล้วก็อีกอันนึงที่สำคัญคือ runWithLog

00:10:33.480 --> 00:10:36.196
ตัวนี้เป็นฟังก์ชันที่ใช้ compose ระหว่าง

00:10:36.279 --> 00:10:39.120
AuditedNumber แล้วก็ฟังก์ชันของเรา

00:10:39.360 --> 00:10:43.000
แล้วมันก็จะ concat log ออกมาให้เรา โอเคไหม

00:10:43.160 --> 00:10:45.520
เพราะฉะนั้นตอนนี้โค้ดเรา มันมีความ

00:10:45.839 --> 00:10:50.320
มีการทำงานที่เป็นของใครของมันแล้วก็ทำงานแค่อย่างเดียวจริงๆ

00:10:51.160 --> 00:10:53.196
โอเค มาถึงตรงนี้แล้วเนี่ย

00:10:53.279 --> 00:10:55.279
โค้ดตัวนี้เราทำด้วยกันเนี่ยเสร็จ

00:10:55.880 --> 00:11:00.120
แต่หลายคนอาจจะสงสัยว่า เอ๊ะ ผมกำลังพูดอะไรอยู่

00:11:00.240 --> 00:11:02.080
มันเกี่ยวกับ monad ยังไงใช่ไหม

00:11:02.519 --> 00:11:05.160
อยากจะบอกว่า สิ่งที่เราทำทั้งหมดเนี่ย

00:11:05.519 --> 00:11:11.280
มันดันไปคล้ายการทำงานของ monad ตัวนึงมาก โอเคไหม

00:11:11.440 --> 00:11:14.677
ก่อนที่เราจะไปต่อเดี๋ยวให้สร้าง checkpoint ไว้ตรงนี้ก่อน

00:11:14.760 --> 00:11:21.237
ว่าเราเพิ่งทำ type AuditedNumber ที่มีการทำงานคล้าย monad

00:11:21.320 --> 00:11:24.240
ทำ checkpoint ไว้เนาะ แล้วเดี๋ยวเราค่อยกลับมาดูมัน

00:11:25.920 --> 00:11:30.560
กลับไปตอนแรกเลยที่ผมยังไม่ได้อธิบายต่อนะว่า monad คืออะไร

00:11:31.399 --> 00:11:32.920
disclaimer ไว้ก่อน

00:11:33.279 --> 00:11:37.919
ว่าจริงๆ แล้วเนี่ย ก่อนที่เราจะศึกษาเรื่อง monad เนี่ย

00:11:38.040 --> 00:11:40.837
กว่าจะมาถึงตรงนี้ได้ถ้าเราไปอ่านหนังสือจริงๆ

00:11:40.920 --> 00:11:44.837
มันจะมีความรู้พื้นฐานอีกเต็มเลย กว่าจะมาถึงตรงนี้ได้

00:11:44.920 --> 00:11:48.946
อย่างเช่น functional programming ใช่ไหม

00:11:49.400 --> 00:11:55.637
functor applicative category theory อะไรอย่างเงี้ย

00:11:55.720 --> 00:11:56.517
เต็มไปหมดเลย

00:11:56.600 --> 00:12:00.276
ซึ่งใน session วันนี้มันเป็นไปไม่ได้เลยที่จะอธิบายทั้งหมดใช่ไหม

00:12:00.359 --> 00:12:05.876
session นี้ผมก็เลยพยายามจะดึงเฉพาะ character ของ monad

00:12:05.959 --> 00:12:10.077
ที่มันอาจจะมาช่วยในการทำงานเราในชีวิตประจำวันได้เนาะ

00:12:10.160 --> 00:12:13.316
โดยที่เราอาจจะต้องยังไม่ต้องเข้าใจ monad ทั้งหมดก็ได้ โอเคไหม

00:12:13.399 --> 00:12:16.560
มันทำให้ talk เนี่ยมันอาจจะมีเนื้อหาบางอย่างเนี่ยหายไป

00:12:17.399 --> 00:12:21.999
แต่ผมหวังว่าทุกคนน่าจะพอเห็นภาพว่า monad เนี่ยมันใช้งานยังไง

00:12:22.760 --> 00:12:24.639
โอเค ไปกันต่อ

00:12:26.360 --> 00:12:29.717
เริ่มจากจริงๆ แล้ว พอได้ยินคำว่า monad เนี่ย

00:12:29.800 --> 00:12:33.240
ทุกคนก็คิดว่า เอ๊ะ มันต้องเป็นอะไรที่แบบยาก

00:12:33.920 --> 00:12:39.000
ต้องรู้คณิตศาสตร์ ต้องรู้ category theory ใช่ไหม

00:12:39.160 --> 00:12:42.277
แต่จริงๆ แล้ว สำหรับคนที่จะเพิ่งเริ่มใช้งานน่ะ

00:12:42.360 --> 00:12:45.599
ผมอยากให้ลองวางความคิดทางทฤษฎีเอาไว้ก่อน

00:12:45.760 --> 00:12:49.037
แล้วเริ่มจากคิดว่าจริงๆ แล้ว monad เนี่ย

00:12:49.120 --> 00:12:53.120
มันเป็นแค่กล่องเนาะ

00:12:53.320 --> 00:12:57.517
ที่อาจจะมีเครื่องมือต่างๆ ที่จะมาช่วยเราในเรื่อง

00:12:57.600 --> 00:13:00.600
computation กับ value โอเคไหม

00:13:00.920 --> 00:13:07.797
โดยที่มันน่ะ สิ่งที่มันช่วยเราอ่ะ มันจะช่วยเราได้หลายอย่าง

00:13:07.880 --> 00:13:11.436
ยกตัวอย่างเช่น จะช่วยเรื่อง asynchronous

00:13:11.519 --> 00:13:14.400
ช่วยเรื่อง error handling

00:13:14.600 --> 00:13:17.316
หรือว่าช่วยเรื่องการทำ accumulate log

00:13:17.399 --> 00:13:20.000
แบบที่เราได้โชว์เห็นใน AuditedNumber เมื่อกี้เนาะ

00:13:20.360 --> 00:13:24.157
โอเค เราลองเริ่มจินตนาการก่อน

00:13:24.240 --> 00:13:28.160
จินตนาการก่อนว่า monad เนี่ยมันเป็นกล่องนึง

00:13:28.800 --> 00:13:30.320
ที่เก็บ value อยู่ข้างในนะ

00:13:32.560 --> 00:13:38.280
แล้ว monad ตัวนี้จะอนุญาตให้เราสามารถ apply

00:13:38.399 --> 00:13:41.360
ฟังก์ชันใดๆ เข้าไปกับ value ข้างในนั้น

00:13:41.600 --> 00:13:43.677
โดยที่ก่อนที่มันจะ apply ฟังก์ชันเนี่ย

00:13:43.760 --> 00:13:45.560
มันจะมี context บางอย่างมาครอบ

00:13:45.760 --> 00:13:48.320
เป็นการ control ว่าฟังก์ชันกับ value

00:13:48.600 --> 00:13:51.480
จะถูก apply กันท่าไหน โอเคไหม

00:13:51.759 --> 00:13:56.640
อันนี้ก็คือจินตนาการก่อนเนาะว่า monad มันจริงๆ มีแค่นี้แหละ

00:13:57.320 --> 00:13:59.597
แล้วก็การที่จะเป็น monad เนี่ย

00:13:59.680 --> 00:14:02.440
มันจะประกอบไปด้วย 3 component ใหญ่ๆ

00:14:02.920 --> 00:14:06.519
จริงๆ มันมีมากกว่านี้นะ แต่ยกตัวอย่างแบบหลักๆ มาเนาะ

00:14:07.000 --> 00:14:10.237
1 ก็คือ monadic type ตัวนี้เนาะ

00:14:10.320 --> 00:14:14.600
monadic type ก็คือ type ของ monad ของเรา ตรงไปตรงมา

00:14:14.800 --> 00:14:16.360
ก็คือเราก็ต้องมี type ก่อน

00:14:17.000 --> 00:14:20.079
เสร็จแล้ว อันที่ 2 ก็คือ unit operation

00:14:21.120 --> 00:14:25.040
unit operation คือ operation ที่จะรับ input

00:14:25.480 --> 00:14:29.840
เป็น plain type แล้วมันจะ return monadic value ออกมาให้เรา

00:14:30.120 --> 00:14:32.037
โอเคไหม อันนี้ก็เรียกว่า unit เนาะ

00:14:32.120 --> 00:14:34.040
บางภาษาก็จะเรียกว่า return หรือ pure

00:14:34.800 --> 00:14:37.120
แล้วแต่ว่าเราไปเจอในภาษาไหน

00:14:37.880 --> 00:14:40.399
สุดท้ายเราจะมี bind operation

00:14:40.519 --> 00:14:45.240
bind operation น่ะ มันจะเป็น operation ที่จะรับพารามิเตอร์ 2 ตัว

00:14:45.920 --> 00:14:48.720
ตัวที่ 1 ก็คือ monadic value

00:14:49.160 --> 00:14:53.079
อีกตัวนึงจะเป็นฟังก์ชันที่ใช้ transform value ตัวเมื่อกี้

00:14:53.920 --> 00:14:57.400
แล้วตัวฟังก์ชันเนี่ยจะ return monadic value ตัวใหม่ออกมาให้เรา

00:14:57.639 --> 00:15:01.560
โอเคไหม อันนี้เรียกว่า bind operation

00:15:01.680 --> 00:15:03.436
ซึ่งถ้าใครตามทันเนาะ

00:15:03.519 --> 00:15:04.717
ใครยังไม่เมาเนี่ย

00:15:04.800 --> 00:15:07.357
ก็จะเริ่มเห็นแล้วมันคล้ายกับไอ้ตัว audited number

00:15:07.440 --> 00:15:08.429
เราที่เพิ่งทำตะกี๊เนาะ

00:15:08.512 --> 00:15:12.037
หนึ่งคือ audited number เรามี type ใช่ป่ะ

00:15:12.120 --> 00:15:15.920
เรามี type ชื่อ audited number มี property ตามนี้

00:15:16.680 --> 00:15:20.919
ต่อมาเรามีฟังก์ชัน wrapWithLog ที่รับ number

00:15:21.160 --> 00:15:24.120
แล้ว return audited number ออกไป โอเคมั้ย

00:15:24.399 --> 00:15:26.477
มันจะอิงกับคล้ายๆ นิยามตัวนี้เนาะ

00:15:26.560 --> 00:15:31.660
รับ type นึง return อีก type นึงออกไปให้ โอเคมั้ย

00:15:31.870 --> 00:15:34.880
สุดท้ายเรามี runWithLog ที่รับ parameter สองตัว

00:15:35.319 --> 00:15:36.597
เหมือนนิยามตัวนี้เนาะ

00:15:36.680 --> 00:15:39.597
ตัวนึงเป็น audited number เป็น monadic value

00:15:39.680 --> 00:15:42.839
อีกอันนึงเป็นฟังก์ชันที่ใช้ transform monadic value นั้น

00:15:43.319 --> 00:15:47.999
แล้วก็ return type ใหม่ออกมา โอเคมั้ย

00:15:48.759 --> 00:15:50.240
ความคล้ายกันสูงเนาะ

00:15:50.399 --> 00:15:51.756
แต่สำหรับคนที่ยังอาจจะแบบ

00:15:51.839 --> 00:15:53.479
เอ๊ย ฟังก์ชันนี้มันอยู่แยกกันนี่

00:15:53.759 --> 00:15:56.277
ทำไมมัน เรามองเป็นไงเป็นส่วนประกอบ component มัน

00:15:56.360 --> 00:15:57.077
มันมองยากใช่ป่ะ

00:15:57.160 --> 00:16:01.159
เราลอง refactor มันให้อยู่ในรูปของ class โอเค

00:16:02.399 --> 00:16:04.236
เมื่อเวลาเรา refactor เสร็จแล้วเนี่ย

00:16:04.319 --> 00:16:06.837
เราก็จะได้ class ที่ชื่อว่า AuditedNumber

00:16:06.920 --> 00:16:08.316
จาก interface เมื่อกี๊เนาะ

00:16:08.399 --> 00:16:11.840
กลายมาเป็น class และ AuditedNumber มี property สองตัว

00:16:12.399 --> 00:16:15.277
แล้วเราก็จะมี method ที่ชื่อว่า of ตัวนี้

00:16:15.360 --> 00:16:17.519
ตัวนี้มันคือ unit operation

00:16:17.639 --> 00:16:20.759
ที่แปลงมาจากฟังก์ชัน wrapWithLog เมื่อกี๊

00:16:21.319 --> 00:16:24.320
เราก็แค่เปลี่ยนชื่อมันแล้วก็แก้ type นิดหน่อย

00:16:24.759 --> 00:16:26.316
อีกอันนึงคือ bind operation

00:16:26.399 --> 00:16:27.676
ตัวนี้เป็น bind method

00:16:27.759 --> 00:16:30.559
ก็แปลงมาจาก runWithLog ที่เราทำไปตอนแรก

00:16:31.240 --> 00:16:33.397
copy มาเลยแล้วก็เปลี่ยน type นิดหน่อย

00:16:33.480 --> 00:16:37.756
แล้วเราก็ลากพวก operation ทางคณิตศาสตร์เรามาเหมือนเดิม

00:16:37.839 --> 00:16:38.760
โอเคมั้ย

00:16:39.680 --> 00:16:41.756
ซึ่งสังเกตว่าเนี่ย ตอนนี้มันมาอยู่ด้วยกัน

00:16:41.839 --> 00:16:45.240
และทำให้การใช้งานก็จะเปลี่ยนไปนิดนึงเนาะ

00:16:45.639 --> 00:16:48.560
จากตอนแรกที่เราเรียกฟังก์ชันโยนฟังก์ชัน

00:16:48.680 --> 00:16:51.876
เราก็มาเปลี่ยนไปเป็นเราสร้าง instance ของ

00:16:51.959 --> 00:16:53.077
audited number ขึ้นมา

00:16:53.160 --> 00:16:57.196
แล้วเวลาเราจะ apply ฟังก์ชันกับตัวเลขตัวนั้นเนี่ย

00:16:57.279 --> 00:16:58.436
เราก็ใช้ฟังก์ชัน bind แทน

00:16:58.519 --> 00:16:59.663
แล้วก็โยนฟังก์ชันเข้าไป

00:16:59.747 --> 00:17:02.840
แทนที่เราจะเรียกฟังก์ชันแบบ JavaScript ปกติเนาะ

00:17:03.079 --> 00:17:04.476
อย่างเงี้ย อันนี้ยกตัวอย่างเช่น

00:17:04.559 --> 00:17:07.116
ถ้าเราต้องการจะบวกเลข 5 ขึ้นมาอย่างเงี้ย

00:17:07.199 --> 00:17:08.759
เราก็ transform ก่อน

00:17:08.919 --> 00:17:12.759
เลข 5 ให้กลายเป็น audited number ที่มีค่า 5 ใช่มั้ย

00:17:13.039 --> 00:17:14.199
เสร็จแล้วเราก็อยากจะบวก 1

00:17:14.600 --> 00:17:17.119
เราก็ bind ฟังก์ชัน addOne ให้มันเข้าไป

00:17:17.679 --> 00:17:19.439
อยากจะเอาไป square เราได้ผลลัพธ์

00:17:19.540 --> 00:17:21.521
แล้วก็ bind ฟังก์ชันมันเข้าไปเรื่อยๆ

00:17:22.079 --> 00:17:24.480
อันนี้ก็ไม่น่าจะยากเนาะ น่าจะตามกันทัน

00:17:24.679 --> 00:17:27.756
หรือในแนวทางของ functional programming เนี่ย

00:17:27.839 --> 00:17:30.317
บางทีเค้าไม่อยากจะมา declare ตัวแปรเยอะแยะเลย

00:17:30.400 --> 00:17:33.237
เค้าก็สามารถ chain operation ในมุมนี้ได้ใช่ป่ะ

00:17:33.320 --> 00:17:35.560
code มันก็จะ declarative มากขึ้นเนาะ

00:17:36.240 --> 00:17:38.800
โอเค มาถึงจุดนี้ปุ๊บ

00:17:39.400 --> 00:17:41.237
เราก็จะคิดได้ว่าเนาะ

00:17:41.320 --> 00:17:44.037
สิ่งที่ audited number หรือเราพยายามทำเนี่ย

00:17:44.120 --> 00:17:47.117
เราพยายามจะดึงความรับผิดชอบอะไรบางอย่าง

00:17:47.200 --> 00:17:48.797
ออกจาก operation พวกนี้

00:17:48.880 --> 00:17:52.520
ให้ฟังก์ชันพวกนี้มันยังทำงานแค่อย่างเดียวอยู่

00:17:53.039 --> 00:17:55.157
สิ่งที่ audited number มันทำก็คือ

00:17:55.240 --> 00:17:58.559
มันพยายามดึงเอา logic ของการ concat log เนี่ย

00:17:58.960 --> 00:18:01.040
จากภาพแรกที่เราพยายาม refactor มาเนาะ

00:18:01.559 --> 00:18:05.357
เราให้แต่ละฟังก์ชันเนี่ยมันทำการ concat log เองใช่ป่ะ

00:18:05.440 --> 00:18:07.320
ซึ่งจริงๆ แล้วมันไม่ค่อยถูกต้อง

00:18:07.600 --> 00:18:11.439
เราก็เลยดึงความรับผิดชอบนั้นออกมาอยู่ที่ audited number

00:18:11.640 --> 00:18:14.956
แล้วเมื่อเราเอา audited number ไปใช้ bind

00:18:15.039 --> 00:18:16.840
กับฟังก์ชันคำนวณต่างๆ เนี่ย

00:18:17.360 --> 00:18:20.317
ฟังก์ชันพวกนี้ไม่ต้องมีความรู้เกี่ยวกับการ concat log เลย

00:18:20.400 --> 00:18:22.160
เราเขียนให้มันเป็น pure function ปกติ

00:18:22.799 --> 00:18:25.360
แล้วความรับผิดชอบในการ concat log

00:18:25.520 --> 00:18:27.280
ก็จะมาอยู่ที่ audited number แทนเนาะ

00:18:27.480 --> 00:18:29.037
เมื่อเรามอง type เนี่ยเรา

00:18:29.120 --> 00:18:30.877
ถ้าเราใช้กันเยอะๆ อ่ะ เราก็จะรู้แล้วว่า

00:18:30.960 --> 00:18:34.720
อ๋อ audited number เนี่ยมันจะต้องมี log อยู่ ถูกป่ะ

00:18:35.039 --> 00:18:36.120
เวลาเอาไปใช้เราก็

00:18:36.280 --> 00:18:37.917
เวลาเราไป chain operation เนี่ย

00:18:38.000 --> 00:18:40.640
เราไม่ต้องคิดว่า เอ๊ย เราจะ log ที่ไหน

00:18:40.960 --> 00:18:44.480
เรารู้ว่าตัวนี้จะเป็นคนจัดการให้ โอเคนะ

00:18:44.799 --> 00:18:47.680
หรือว่าถ้าเราจะกล่าวง่ายๆ เนาะว่า

00:18:48.159 --> 00:18:50.836
ถ้าเราให้ audited number เนี่ย

00:18:50.919 --> 00:18:53.517
เรา implement ตามนิยามของ monad ทุกข้อแล้วเนี่ย

00:18:53.600 --> 00:18:55.397
เราจะหมายถึง audited number เนี่ย

00:18:55.480 --> 00:18:58.757
มันจะมี context อะไรบางอย่างที่จะมาช่วยเรา

00:18:58.840 --> 00:19:01.076
context นั้นก็คือการจัดการเรื่อง log

00:19:01.159 --> 00:19:03.999
ของ operation ที่ทำงานอยู่บน number โอเคมั้ย

00:19:04.240 --> 00:19:05.956
เรามี operation ที่ทำงานอยู่บน number เนี่ย

00:19:06.039 --> 00:19:07.557
เราไม่ต้องทำการ concat log เลย

00:19:07.640 --> 00:19:11.197
เพราะว่ามันจะทำอัตโนมัติอยู่ใน type audited number

00:19:11.280 --> 00:19:12.720
ตัวนี้เนาะ

00:19:13.760 --> 00:19:17.596
โอเค สำหรับคนที่ยังงงๆ อยู่เนาะ

00:19:17.679 --> 00:19:20.078
เดี๋ยวมาดู monad ที่ง่ายที่สุด

00:19:20.919 --> 00:19:22.797
แล้วก็ทุกคนอาจจะเคยใช้นะ

00:19:22.880 --> 00:19:24.317
สำหรับคนที่เขียนหลายภาษาอย่างเงี้ย

00:19:24.400 --> 00:19:25.840
อาจจะเคยใช้ monad ตัวนี้

00:19:26.000 --> 00:19:29.399
โดยที่ยังไม่รู้ว่าตัวนี้มันคือ monad เลยด้วยซ้ำ

00:19:29.679 --> 00:19:32.319
สิ่งนี้เราเรียกว่า maybe monad โอเคมั้ย

00:19:32.840 --> 00:19:34.557
maybe monad เนี่ยเป็น monad ตัวแรกๆ

00:19:34.640 --> 00:19:36.559
ที่เราจะได้เจอถ้าเราได้ศึกษาเรื่อง monad

00:19:37.080 --> 00:19:39.920
ซึ่งในภาษาอื่นเนี่ยเราจะเรียกมันว่า option

00:19:40.320 --> 00:19:44.843
optional หรือ nullable ใช่มั้ย

00:19:46.000 --> 00:19:49.040
optional เนี่ยน่า ผมเห็นหลายภาษามากใช้คำว่า optional

00:19:49.240 --> 00:19:53.440
โอเค ซึ่ง maybe เนี่ย ความหมายของมันก็คือ

00:19:53.559 --> 00:19:57.197
ยกตัวอย่างเช่น ถ้าเรา declare type ของตัวแปร

00:19:57.280 --> 00:19:58.080
เป็น number

00:19:58.880 --> 00:20:00.840
ความหมายที่เราจะนิยามให้ตัวแปรนั้นน่ะ

00:20:00.960 --> 00:20:03.919
มันก็คือตัวแปรนั้นเป็น number ใช่ป่ะ

00:20:05.039 --> 00:20:07.317
แต่ถ้าเราบอกว่าตัวแปรนั้นน่ะ

00:20:07.400 --> 00:20:09.679
มี type เป็น maybe number

00:20:10.760 --> 00:20:14.080
ความหมายของมันก็คือจะเป็น number

00:20:14.440 --> 00:20:17.800
หรืออาจจะไม่มีอะไรอยู่ก็เป็นได้ โอเคมั้ย

00:20:17.960 --> 00:20:19.757
ก็คืออาจจะเป็น null หรือ undefined ใช่ป่ะ

00:20:19.840 --> 00:20:25.159
ซึ่งถ้ามองในมุมของ TypeScript มันก็คือ union type ใช่ป่ะ

00:20:25.360 --> 00:20:26.480
เราทำ union type

00:20:27.159 --> 00:20:29.720
อีกอันนึงก็คือสมมติว่ามันเป็น maybe user

00:20:30.080 --> 00:20:35.320
ก็อาจจะหมายถึงว่า user หรือไม่มีอะไรก็ได้ โอเคมั้ย

00:20:36.240 --> 00:20:37.799
ซึ่งจากนิยามเมื่อกี๊

00:20:37.960 --> 00:20:39.517
เราก็จะเห็นว่าตัว maybe เนี่ย

00:20:39.600 --> 00:20:42.440
มัน represent ถึง state สองตัว

00:20:43.080 --> 00:20:47.557
ก็คือ just หมายความว่ามันมีค่าอะไรบางอย่างอยู่

00:20:47.640 --> 00:20:49.720
หรือบางภาษาจะเรียกว่า some

00:20:49.919 --> 00:20:50.917
ก็เป็นอันเดียวกันเนาะ

00:20:51.000 --> 00:20:54.000
ก็คือ maybe นั้นมีค่าอะไรบางอย่างอยู่ข้างใน

00:20:54.840 --> 00:20:56.879
อีกอันนึงคือ nothing

00:20:57.159 --> 00:21:02.639
maybe นั้นไม่มีอะไรอยู่ข้างในเลย เก็บค่า null โอเคมั้ย

00:21:03.559 --> 00:21:08.359
ซึ่งการทำงานของแต่ละ state เนี่ย มันก็จะทำงานไม่เหมือนกันเนาะ

00:21:08.720 --> 00:21:14.279
ยกตัวอย่างเช่น ผมต้องการเอา maybe 𝑚 เนี่ย ไป bind กับฟังก์ชัน 𝑔

00:21:14.799 --> 00:21:17.797
มันหมายถึงผมต้องการจะเอาค่าที่อยู่ใน 𝑚 เนี่ย

00:21:17.880 --> 00:21:19.877
ไป apply ในฟังก์ชัน 𝑔 เนาะ

00:21:19.960 --> 00:21:22.560
ก็คือ 𝑔 แล้วก็ค่าอะไรบางอย่างใช่ป่ะ

00:21:23.320 --> 00:21:25.879
อ่ะ เริ่มจากเรามี maybe 𝑚 อยู่

00:21:26.000 --> 00:21:30.317
ถ้าเราต้องการจะ apply ฟังก์ชัน 𝑔 เข้าไปเนี่ย จะ bind 𝑔 เนี่ย

00:21:30.400 --> 00:21:32.480
สิ่งที่ monad มันจะทำก่อนก็คือ

00:21:33.240 --> 00:21:37.039
มันไปเช็กก่อนว่าใน monad maybe monad อะน่ะ มีค่ามั้ย

00:21:37.720 --> 00:21:42.757
ถ้ามันมีค่าเป็น 𝑥 มันจะ return monad ตัวใหม่ออกมา

00:21:42.840 --> 00:21:44.157
ที่เป็น maybe monad นะ

00:21:44.240 --> 00:21:48.680
แล้วข้างในนั้นน่ะ ก็จะเก็บ value ของ 𝑔𝑥 ไว้ โอเคมั้ย

00:21:49.279 --> 00:21:51.358
ก็คือมีการ apply ฟังก์ชัน 𝑔 เข้าไป

00:21:51.919 --> 00:21:55.920
แต่ถ้า maybe ไม่มีค่าเลย เป็น nothing

00:21:56.200 --> 00:21:59.357
สิ่งที่มันทำก็คือ return กล่องเปล่ามาให้

00:21:59.440 --> 00:22:01.480
ก็คือ maybe nothing โอเคมั้ย

00:22:01.640 --> 00:22:03.560
อันนี้ง่ายๆ เนาะ

00:22:04.240 --> 00:22:06.479
อ่ะ มาลองดู implementation เนาะ

00:22:06.760 --> 00:22:08.959
จริงๆ แล้ว เราไม่ต้องเขียนเองนะ

00:22:09.159 --> 00:22:11.877
เพราะว่ามันมี library ให้เราเลือกใช้เยอะมาก

00:22:11.960 --> 00:22:15.237
เค้าเขียน monad มาให้เราเนี่ยเต็มไปหมดเลย

00:22:15.320 --> 00:22:16.681
เราไปเลือกหยิบมาใช้ได้

00:22:17.000 --> 00:22:20.196
แต่เนี่ย เพื่อที่จะให้เห็นภาพก็ลองมาดูว่า

00:22:20.279 --> 00:22:22.320
จริงๆ แล้ว maybe มันทำงานยังไงเนาะ

00:22:22.880 --> 00:22:27.237
ซึ่งใน code ตัวเนี้ยก็จะประกอบไปด้วย code 2 กลุ่มหลักๆ

00:22:27.320 --> 00:22:30.759
ก็คือ กลุ่มที่เป็น unit operation ใช่มั้ย

00:22:30.960 --> 00:22:32.560
monad มี unit operation ใช่มั้ย

00:22:32.720 --> 00:22:35.517
ซึ่งเป็นฟังก์ชันที่ใช้ transform plain type

00:22:35.600 --> 00:22:37.960
ให้กลายเป็น monadic type

00:22:38.480 --> 00:22:41.160
อีกกลุ่มนึงก็คือเป็น map กับ bind นะ

00:22:41.440 --> 00:22:42.557
เป็น bind operation เนาะ

00:22:42.640 --> 00:22:45.119
ก็คือเป็นการ apply ฟังก์ชันเข้าไปใน monad ตัวนั้น

00:22:45.480 --> 00:22:49.400
ซึ่ง map กับ bind เนี่ย ทำงานคล้ายกันเลย ต่างกันนิดเดียว

00:22:49.919 --> 00:22:54.040
map เนี่ย มันจะรับ input เป็นฟังก์ชันที่ return type 𝑢 นะ

00:22:54.559 --> 00:22:56.357
แล้วมันก็จะ ตัว map เองเนี่ย

00:22:56.440 --> 00:22:59.307
มันจะ return maybe 𝑢 ออกมาให้ โอเคมั้ย

00:22:59.840 --> 00:23:03.720
ฟังก์ชัน return 𝑢 ของออกจาก map จะเป็น maybe 𝑢

00:23:04.240 --> 00:23:08.759
ส่วน bind เนี่ย ฟังก์ชัน จะ return maybe 𝑢 ใช่มั้ย

00:23:09.000 --> 00:23:11.397
แต่ bind อ่ะ จะ flat maybe ออกให้ตัวนึง

00:23:11.480 --> 00:23:14.080
แล้วก็ return maybe 𝑢 เหมือนเดิม โอเคมั้ย

00:23:14.640 --> 00:23:18.476
ต่างกันแค่เนี้ย แต่มันมี use case ใช้การที่ต่างกันเนี่ยแหละ

00:23:18.559 --> 00:23:20.799
เออ ก็เลยต้องมี 2 อัน

00:23:21.679 --> 00:23:24.196
โอเค มาลองดูการใช้งานมันเนาะ

00:23:24.279 --> 00:23:28.240
สมมุติว่าเราต้องการจะใช้ maybe บวกเลข โอเคมั้ย

00:23:28.600 --> 00:23:31.476
ใช้ maybe บวกเลข เราก็ต้อง transform type

00:23:31.559 --> 00:23:34.357
ที่เป็น number เนี่ย ให้กลายเป็น maybe number ก่อน

00:23:34.440 --> 00:23:35.917
โดยการใช้ unit operation เนาะ

00:23:36.000 --> 00:23:39.997
ในที่นี้เราก็ใช้ from มันก็จะเริ่มจาก Maybe.from(10) เนี่ย

00:23:40.080 --> 00:23:43.200
เอ่อ code ชุดเนี้ย ผลของการ run

00:23:43.360 --> 00:23:46.039
ก็จะได้ maybe แล้วก็มีค่า 10 อยู่ข้างในใช่ป่ะ

00:23:46.320 --> 00:23:49.517
เค แล้วถ้าเราต้องการจะบวกเลข เช่น จะบวก 1 เนี่ย

00:23:49.600 --> 00:23:54.040
เราก็ใช้ map แล้วก็โยนฟังก์ชันบวก 1 เข้าไปให้มัน โอเคมั้ย

00:23:54.559 --> 00:23:56.076
เมื่อเรา map code ตรงนี้แล้วเนี่ย

00:23:56.159 --> 00:23:58.840
ผลที่ได้จาก code บรรทัดเนี้ยก็คือ maybe 11 ใช่มั้ย

00:24:00.200 --> 00:24:01.317
เราก็ map ได้เรื่อยๆ เนาะ

00:24:01.400 --> 00:24:03.760
จะ map กี่ทีก็ 𝑥 + 2 ก็เป็น maybe 13

00:24:04.640 --> 00:24:06.759
𝑥 + 3 ก็เป็น maybe 16 ใช่ป่ะ

00:24:06.919 --> 00:24:09.237
เพราะฉะนั้นผลของการ run code ชุดข้างบนเนี่ย

00:24:09.320 --> 00:24:10.479
ก็จะได้ maybe 16 เนาะ

00:24:11.159 --> 00:24:14.279
นี่ก็แบบ basic ทั่วไป

00:24:14.440 --> 00:24:18.240
อีกเคสนึงก็คือ ถ้าฟังก์ชันระหว่างทาง

00:24:18.520 --> 00:24:21.080
ไม่รู้มันทำอะไรอ่ะ แต่สุดท้ายมัน return ค่า null

00:24:21.200 --> 00:24:22.480
ออกมาแบบเนี้ย

00:24:23.080 --> 00:24:25.280
ผลของการ map บรรทัดเนี้ย

00:24:25.399 --> 00:24:27.920
มันจะ return maybe nothing ออกมา

00:24:28.600 --> 00:24:31.720
แล้วเมื่อเราเอา maybe nothing เนี่ย ไป map ต่อ

00:24:32.240 --> 00:24:33.277
มันก็จะไม่ทำอะไรเนาะ

00:24:33.360 --> 00:24:34.956
มันก็จะ return nothing ออกมาให้เราเลย

00:24:35.039 --> 00:24:37.397
เพราะฉะนั้นมันก็จะได้ maybe nothing เนาะ

00:24:37.480 --> 00:24:39.520
มีค่า null อยู่ข้างใน โอเคมั้ย

00:24:40.440 --> 00:24:42.720
จากตัวอย่าง 2 ตัวเนี้ย เราก็จะเห็นแล้วว่า

00:24:42.840 --> 00:24:44.279
มันมีประโยชน์เนาะ maybe

00:24:45.440 --> 00:24:50.076
มันมาช่วยเราในการทำให้เราสามารถ compose ฟังก์ชัน

00:24:50.159 --> 00:24:51.476
หรือ map ฟังก์ชันหลายๆ ตัวได้

00:24:51.559 --> 00:24:55.196
โดยที่เราไม่ต้องกังวลว่าฟังก์ชันระหว่างกลาง

00:24:55.279 --> 00:24:56.917
อันใดอันนึงเนี่ยมันจะ return null ออกมา

00:24:57.000 --> 00:24:59.600
แล้วทำให้มันได้ null pointer ใช่ป่ะ

00:24:59.799 --> 00:25:03.316
ถ้าเราไม่ได้ใช้ maybe แล้วเอาตัวเลขปกติไปบวกกัน

00:25:03.399 --> 00:25:05.517
แล้วไม่รู้ว่าสุดท้ายมีฟังก์ชันอะไรฟังก์ชันนึง

00:25:05.600 --> 00:25:07.237
มา return nothing ออกมาหรือ null เนี่ย

00:25:07.320 --> 00:25:10.677
แล้วเราไป map ต่อมันก็อาจจะเกิด error of undefined

00:25:10.760 --> 00:25:13.639
throw exception null pointer บลาๆ โอเคมั้ย

00:25:13.919 --> 00:25:15.637
อันนี้ก็เป็นประโยชน์ของ maybe เนาะ

00:25:15.720 --> 00:25:17.800
แล้วก็ตะกี้ที่ติดเรื่อง map กับ bind ใช่มั้ย

00:25:18.080 --> 00:25:22.877
map เนี่ย สมมุติว่า ถ้าเราไป apply maybe

00:25:22.960 --> 00:25:26.360
กับฟังก์ชันที่มันดัน return maybe อีกตัวนึงออกมา

00:25:27.200 --> 00:25:29.596
ผลของการ run เนี่ยมันจะได้ maybe ซ้อน maybe

00:25:29.679 --> 00:25:31.716
ซึ่งไม่ใช่โครงสร้างที่เราอยากได้เนาะ

00:25:31.799 --> 00:25:33.760
เราอยากได้ maybe ที่เก็บ value อะไรใช่ป่ะ

00:25:34.399 --> 00:25:35.557
อันนี้วิธีแก้ปัญหาก็คือ

00:25:35.640 --> 00:25:37.840
ถ้าเราเจอฟังก์ชันแบบนี้เราก็ไปใช้ bind แทน

00:25:38.159 --> 00:25:40.360
มันก็จะ flat maybe ออกให้ตัวนึง

00:25:40.480 --> 00:25:41.917
อ่านี่ก็เป็นวิธีการใช้งาน

00:25:42.000 --> 00:25:45.720
ก็ขึ้นอยู่กับว่าเราจะไป apply กับฟังก์ชันหน้าตาแบบไหน

00:25:46.480 --> 00:25:48.117
โอเค พอเรารู้จัก maybe ละ

00:25:48.200 --> 00:25:53.080
เราลองมาดูตัวอย่างที่อาจจะเจอในชีวิตประจำวันได้ง่ายมากขึ้นเนาะ

00:25:53.480 --> 00:25:55.397
เช่น ถ้าผมต้องการยกตัวอย่างว่า

00:25:55.480 --> 00:25:56.877
ผมต้องการจะสร้างฟังก์ชัน

00:25:56.960 --> 00:25:59.677
ฟังก์ชันนึงโดยที่ฟังก์ชันเนี่ย เป็น pseudocode เนาะ

00:25:59.760 --> 00:26:01.357
เราเวลาเราออกแบบฟังก์ชันต้องคิดก่อนว่า

00:26:01.440 --> 00:26:03.000
ฟังก์ชันนั้นทำงานอะไรบ้างใช่ป่ะ

00:26:03.240 --> 00:26:06.917
ฟังก์ชันเนี่ยผมบอกว่ามันคือฟังก์ชันชื่อว่า 𝚐𝚎𝚝𝙿𝚎𝚝𝙽𝚒𝚌𝚔𝚗𝚊𝚖𝚎

00:26:07.000 --> 00:26:10.840
ก็คือจะ get ชื่อสัตว์เลี้ยงออกมาจากคนๆ นึง

00:26:10.960 --> 00:26:13.476
แล้วก็จะ return ชื่อออกมาก็เป็น string ใช่ป่ะ

00:26:13.559 --> 00:26:16.760
โดยที่การทำงานเนี่ยผมอยากให้มีขั้นตอนดังนี้เนาะ

00:26:17.240 --> 00:26:19.637
1 ก็คือ จะ getCurrentUser ออกมา

00:26:19.720 --> 00:26:22.240
get คนออกมาว่าคนๆ นั้นน่ะตอนเนี้ยเป็นใคร

00:26:22.960 --> 00:26:26.457
แล้วก็ 2 ก็คือจะ get สัตว์เลี้ยงออกมาจากเขาเนาะ

00:26:26.540 --> 00:26:28.240
get pet จาก user ที่เราได้มาเมื่อกี้

00:26:28.919 --> 00:26:31.277
อ่า แล้วเสร็จแล้วพอเราได้สัตว์เลี้ยงปุ๊บ

00:26:31.360 --> 00:26:33.437
เราก็ไปเอาชื่อสัตว์เลี้ยงออกมาใช่ป่ะ

00:26:33.520 --> 00:26:36.800
อันนี้ก็เป็นเหมือนกับเป็น business logic ของฟังก์ชันนี้เนาะ

00:26:37.240 --> 00:26:40.560
ซึ่งชีวิตจริงเนี่ยเราไม่น่าได้เจออะไรง่ายๆ อย่างงี้ใช่ป่ะ

00:26:40.880 --> 00:26:44.037
เพราะว่าการ getCurrentUser เนี่ยสมมตินะ

00:26:44.120 --> 00:26:48.437
ตัวเนี้ย getCurrentUser มันอาจจะเจอหรือไม่เจอ user ก็ได้ใช่ป่ะ

00:26:48.520 --> 00:26:51.360
เช่นถ้า user ยังไม่ได้ล็อกอินก็ไม่มี user

00:26:51.640 --> 00:26:54.277
อ่า เพราะฉะนั้นสิ่งพวกนั้นน่ะเราเรียกว่า side effect

00:26:54.360 --> 00:26:57.880
ที่เกิดขึ้นในโค้ดที่เราไม่สามารถ predict ได้ว่า

00:26:58.240 --> 00:27:00.639
result มันจะออกมาเป็นอะไรกันแน่

00:27:01.399 --> 00:27:03.677
เพราะฉะนั้นจริงๆ แล้วโค้ดในชีวิตจริงอะ

00:27:03.760 --> 00:27:06.797
ถ้าเราเอา pseudocode เมื่อกี้ไป implement อะ

00:27:06.880 --> 00:27:08.399
เราจะได้โค้ดหน้าตาแบบนี้ใช่ป่ะ

00:27:08.600 --> 00:27:10.596
ก็คือ getCurrentUser เนี่ย

00:27:10.679 --> 00:27:14.200
มันก็อาจจะเจอ user หรือ undefined ก็ได้แล้วแต่

00:27:14.480 --> 00:27:16.836
แล้วปกติก่อนจะเอา user ไปใช้ต่อเนี่ย

00:27:16.919 --> 00:27:20.359
เราก็ต้องมีการ handle undefined หรือ handle null พวกนี้เนาะ

00:27:20.559 --> 00:27:21.397
เป็นกับทุกอันเลย

00:27:21.480 --> 00:27:25.319
ถ้า getUser มาแล้วเป็น undefined ก็ไม่ต้องทำก็ข้ามไป

00:27:25.960 --> 00:27:28.397
แต่ถ้าไม่เป็น null หรือ undefined มีค่าอยู่

00:27:28.480 --> 00:27:29.639
เราก็เอาไป get pet ต่อ

00:27:30.080 --> 00:27:32.716
ภาพเดียวกันเลยถ้า user คนนั้นไม่มี pet เราจะทำไง

00:27:32.799 --> 00:27:34.797
เราก็ต้อง handle ต่อไปเรื่อยๆ ใช่ป่ะ

00:27:34.880 --> 00:27:36.840
ทำให้ตอนเนี้ยโค้ดเราอะ

00:27:37.000 --> 00:27:41.276
มันมีสิ่งที่ไม่เกี่ยวกับ business logic จริงๆ เข้ามาเกี่ยวข้อง

00:27:42.200 --> 00:27:44.956
ซึ่งสมมติว่า จริงๆ ถ้าคน handle ครบ

00:27:45.039 --> 00:27:46.836
ก็อาจจะมองไม่ มันไม่ใช่ปัญหาอะไรหรอก

00:27:46.919 --> 00:27:49.000
แต่สมมติว่าเราไม่รู้ละว่า

00:27:49.279 --> 00:27:50.997
สมมติว่าเราเขียน JavaScript อะ

00:27:51.080 --> 00:27:52.519
เราไม่รู้ type ว่ามันคืออะไรอะ

00:27:53.320 --> 00:27:56.997
เราก็สามารถอาจจะลืม handle undefined หรือ null พวกนี้เนาะ

00:27:57.080 --> 00:27:59.720
ทำให้โปรแกรมมันระเบิดข้างหน้าบน production ได้

00:27:59.960 --> 00:28:02.560
โอเคมั้ย อ่า พอเรามีปัญหาแบบนี้เนี่ย

00:28:02.880 --> 00:28:05.917
ด้วยความรู้ที่เรามีเมื่อ 5 นาทีก่อนเนี่ย

00:28:06.000 --> 00:28:07.919
เรารู้จัก maybe เนาะว่า maybe อะ

00:28:08.360 --> 00:28:11.879
มันสามารถเอามาช่วยเรื่องการ handle undefined

00:28:12.159 --> 00:28:13.240
หรือ no value ได้

00:28:13.399 --> 00:28:15.960
อ่า วิธีการแก้เราคือแทนที่

00:28:16.440 --> 00:28:18.400
ฟังก์ชันแต่ละตัวของเราตรงเนี้ย

00:28:18.640 --> 00:28:20.840
จะ return type ออกมาตรงๆ

00:28:21.120 --> 00:28:23.200
เราเอามันไปครอบด้วย maybe ก่อน

00:28:23.880 --> 00:28:26.519
เมื่อเรา implement เสร็จแล้วมันจะออกมาเป็นหน้าตาแบบนี้

00:28:26.640 --> 00:28:28.880
ก็คือ getCurrentUser เนี่ย

00:28:29.240 --> 00:28:32.117
เราก็จะได้แทนที่เราจะได้ user หรือ undefined แบบนี้เนาะ

00:28:32.200 --> 00:28:33.519
เราจะได้ maybe user แทน

00:28:33.840 --> 00:28:37.960
อ่า แล้วเราก็เอา user เนี่ยไป bind กับฟังก์ชันอื่นๆ ของเรา

00:28:38.240 --> 00:28:42.120
นะก็คือการ apply ฟังก์ชันด้วย ด้วยตัวแปรตัวนี้ใช่ป่ะ

00:28:42.559 --> 00:28:45.956
แล้วอ่า ถ้าขั้นตอนใดขั้นตอนนึงเนี่ย

00:28:46.039 --> 00:28:48.840
มันไม่เจอของมัน return null หรือไม่มีอะไรเงี้ย

00:28:49.039 --> 00:28:51.840
มันก็จะไม่ impact กับฟังก์ชันข้างหลังเลยใช่ป่ะ

00:28:52.080 --> 00:28:56.320
มันทำให้เราสามารถเอาการ handle โค้ดพวกเนี้ยออกไปได้เนาะ

00:28:57.000 --> 00:28:59.757
หรือในมุมของ functional เนี่ย

00:28:59.840 --> 00:29:03.076
เราก็จะ compose ฟังก์ชันออกมาเป็นหน้าตาแบบนี้ได้เลย

00:29:03.159 --> 00:29:04.716
เพราะว่าเราไม่ต้อง handle พวกนี้แล้วอะ

00:29:04.799 --> 00:29:07.360
มันจะ declare ตัวแปรเยอะแยะทำไมใช่ป่ะ

00:29:07.480 --> 00:29:10.000
ก็ไม่ต้องเราก็เอาฟังก์ชันมา compose กัน

00:29:10.159 --> 00:29:12.479
ทำให้ฟังก์ชันเราอะมันอ่านง่ายมากขึ้นเนาะ

00:29:13.080 --> 00:29:18.917
โอเค อะ อะ ตอนเนี้ยนอกจากที่ว่าเรารู้แล้วว่า maybe อะ

00:29:19.000 --> 00:29:21.757
มันช่วยให้เราทำการจัดการ missing value

00:29:21.840 --> 00:29:23.596
หรือ null value ได้ดีขึ้นแล้วเนี่ย

00:29:23.679 --> 00:29:27.480
เพราะว่ามันจัดการเองเลยด้วย type ของตัวแปรใช่ป่ะ

00:29:28.559 --> 00:29:31.399
ผลที่ได้ตามมาแบบอัตโนมัติเลยก็คือโค้ดเราอะ

00:29:31.559 --> 00:29:32.797
อ่านได้ง่ายมากขึ้นเนาะ

00:29:32.880 --> 00:29:35.798
เพราะว่าจะมีแค่โค้ดที่เป็น business logic จริงๆ

00:29:36.120 --> 00:29:38.280
ไม่ได้มี case มีโค้ดสำหรับจัดการ null

00:29:38.879 --> 00:29:41.557
จัดการ side effect จัดการนู่นจัดการนี่ที่ไม่เกี่ยวเลย

00:29:41.640 --> 00:29:42.956
เวลาเราเห็นโค้ดรกๆ อะ

00:29:43.039 --> 00:29:45.596
ส่วนใหญ่ครึ่งนึงอะ มันจะเป็นการจัดการอะไรพวกนั้นน่ะ

00:29:45.679 --> 00:29:47.119
ไม่เกี่ยวกับ business เลยเนาะ

00:29:47.279 --> 00:29:51.839
เออ มันก็ทำให้โค้ดเราอ่านง่ายขึ้นแบบอัตโนมัตินะ

00:29:53.440 --> 00:29:57.196
สำหรับคนที่ยังงงอยู่อีกว่ามันคืออะไรกันแน่เนี่ย

00:29:57.279 --> 00:29:59.716
จริงๆ ก็อยากให้คิดง่ายๆ เนาะ

00:29:59.799 --> 00:30:02.440
ถ้าคนยังงงหรือว่าไม่เข้าใจเนี่ย ก็คิดง่ายๆ ว่า

00:30:02.880 --> 00:30:07.359
มันเป็น monad เนี่ย มันอาจจะเป็นเหมือนกับ design pattern ตัวนึงเนาะ

00:30:07.679 --> 00:30:11.320
ที่จะทำให้เราสามารถ chain operation หรือ chain function ได้

00:30:11.760 --> 00:30:14.120
โดยที่เราไม่ต้องจัดการเรื่อง side effect

00:30:14.360 --> 00:30:16.476
หรือจัดการงานอะไรนอกจาก business logic

00:30:16.559 --> 00:30:22.533
ตัว monad มันเองเนี่ย มันจะเป็นคนจัดการให้เราเอง โอเคมั้ย

00:30:22.616 --> 00:30:24.520
จริงๆ monad เนี่ย

00:30:25.799 --> 00:30:29.956
ที่เราว่ามันจัดการเองอ่ะ คือในการบอกง่ายๆ

00:30:30.039 --> 00:30:32.956
ก็คือมันสามารถ abstract งานบางอย่างออกไปให้เรา

00:30:33.039 --> 00:30:35.799
โดยที่เราไม่ต้อง aware เรื่องนั้นเองใช่ป่ะ

00:30:37.200 --> 00:30:38.757
ซึ่งแต่ละ monad แต่ละตัวเนี่ย

00:30:38.840 --> 00:30:42.439
มันก็จะทำการ abstract งานต่างๆ แตกต่างกันออกไป

00:30:42.559 --> 00:30:44.360
ขึ้นอยู่กับว่าเราใช้ monad ตัวไหนนะ

00:30:44.600 --> 00:30:47.079
ยกตัวอย่างเช่น Writer Monad

00:30:47.440 --> 00:30:51.039
ก็จัดการเรื่องการทำ log accumulation

00:30:51.640 --> 00:30:54.836
ซึ่งตอนที่เราเขียนไปตอนแรกอ่ะ คือ AuditedNumber เนี่ย

00:30:54.919 --> 00:30:57.076
ถ้าเราไปดู implementation ของ AuditedNumber

00:30:57.159 --> 00:31:00.237
กับ Writer Monad ในภาษาอื่นๆ ที่เป็น functional programming อ่ะ

00:31:00.320 --> 00:31:02.160
มันจะทำงานคล้ายๆ กันเลย โอเคนะ

00:31:03.000 --> 00:31:06.997
ต่อมาคือ Maybe เนี่ย ก็จะจัดการเรื่อง missing value ให้เรา

00:31:07.080 --> 00:31:09.240
เราไม่ต้องจัดการเอง เดี๋ยว Maybe จัดการให้

00:31:10.559 --> 00:31:11.720
ต่อมาคือ Either

00:31:12.360 --> 00:31:13.997
จัดการเรื่อง error handling

00:31:14.080 --> 00:31:15.917
ถ้าเราเขียนแบบ imperative ทั่วไปเนี่ย

00:31:16.000 --> 00:31:18.919
เราจะ throw error catch error นู่นนี่นั่นใช่ป่ะ

00:31:19.159 --> 00:31:21.956
แต่ถ้าในโลกของ functional programming เราใช้ monad เนี่ย

00:31:22.039 --> 00:31:24.960
เราใช้ Either มาจัดการเรื่อง error handling พวกนี้

00:31:25.840 --> 00:31:27.799
ตัวสุดท้ายที่ยกตัวอย่างคือ Future

00:31:28.080 --> 00:31:30.400
ตัวนี้จะจัดการเรื่อง asynchronous เนาะ

00:31:30.559 --> 00:31:32.720
ซึ่ง Future เนี่ยจริงๆ ใน JavaScript

00:31:32.880 --> 00:31:35.399
เรามีสิ่งที่คล้ายกับ Future อยู่คือ promise ใช่ป่ะ

00:31:35.519 --> 00:31:37.917
เราก็ไม่ต้องจัดการเรื่อง asynchronous เองเนาะ

00:31:38.000 --> 00:31:39.596
แต่จริงๆ promise ใน JavaScript

00:31:39.679 --> 00:31:42.040
ก็เขียนไม่ค่อยถูก 100% ตามนิยามเนาะ

00:31:42.159 --> 00:31:43.719
แต่ก็อยู่ในกรุ๊ปเดียวกันนี่แหละ

00:31:46.480 --> 00:31:50.879
โอเค สำหรับคนที่ดูแล้วยังไม่เข้าใจอีก

00:31:51.279 --> 00:31:54.879
โยนความคิดเลย โยนทิ้งไปเลย ไม่ต้องสนใจว่า monad คืออะไร

00:31:55.120 --> 00:31:58.716
เราให้คิดง่ายๆ ว่า คนๆ เนี้ย คุณ Bartosz เนี่ย

00:31:58.799 --> 00:32:01.639
เขาเคยบอกว่าถ้าไม่เข้าใจเนี่ย ให้คิดง่ายๆ เลยว่า

00:32:01.760 --> 00:32:06.039
monad เนี่ย มันก็เป็นแค่วิธีการ compose function

00:32:06.399 --> 00:32:07.364
แค่แบบนึงอ่ะ

00:32:07.447 --> 00:32:08.997
โดยที่ function ที่เราเอามา compose อ่ะ

00:32:09.080 --> 00:32:13.277
มันจะมี type ที่พิเศษกว่าชาวบ้านเค้านิดนึงเนาะ

00:32:13.360 --> 00:32:15.192
เราสามารถ compose function ต่างๆ

00:32:15.528 --> 00:32:19.560
โดยที่ทำให้ function นั้นน่ะ มันจัดการเรื่อง side effect เองได้

00:32:21.240 --> 00:32:25.637
สำหรับคนที่สนใจอยากจะศึกษาต่อเนาะ

00:32:25.720 --> 00:32:29.716
ก็ลองไปหาหนังสือเล่มนี้ Category Theory for Programmers เนาะ

00:32:29.799 --> 00:32:31.277
เขียนโดยคุณอาจารย์คนนี้แหละ

00:32:31.360 --> 00:32:36.999
เขาก็จะพยายามอธิบาย category theory ให้ developer เข้าใจได้ง่าย

00:32:38.519 --> 00:32:41.279
มีคณิตศาสตร์แหละ แต่มีน้อย

00:32:44.000 --> 00:32:46.117
คิดว่ามันน่าจะอ่านง่ายกว่า category theory

00:32:46.200 --> 00:32:49.556
สำหรับที่นักศึกษาทางคณิตศาสตร์เค้าศึกษากันนะครับ

00:32:49.639 --> 00:32:54.200
โอเค สำหรับคนที่อยากจะเข้าใจต่อก็ลองไปหาเล่มนี้มาอ่านดูเนาะ

00:32:54.880 --> 00:32:58.556
โอเค อันนี้สำหรับ talk วันนี้ผมก็มีเท่านี้ครับ

00:32:58.639 --> 00:33:02.879
ขอบคุณที่รับฟังครับ ขอบคุณครับ

00:33:03.559 --> 00:33:05.836
ฮัลโหล ขอบคุณครับพี่

00:33:05.919 --> 00:33:07.600
โอ้โห มีแฟนคลับเยอะมากเลย

00:33:07.720 --> 00:33:12.117
ก็สำหรับ section monad นี้เรียกว่าตัวผมเองก็เผลอเขียนมันไป

00:33:12.200 --> 00:33:13.517
แบบไม่รู้ตัวเหมือนกันครับ

00:33:13.600 --> 00:33:17.503
แต่ไม่กล้าพูด วันนี้งาน JavaScript พอดีเขียน Go

00:33:17.587 --> 00:33:21.640
โอเคครับ มีใครมีคำถามมั้ยครับ

00:33:22.840 --> 00:33:26.197
มีคำถาม 1 ท่านครับ เดี๋ยวซักครู่นะครับ

00:33:26.280 --> 00:33:30.477
อย่าเพิ่งหนี อย่าเพิ่งไปนะครับพี่

00:33:30.560 --> 00:33:33.836
เอิ่ม พอจะมีคำแนะนำมั้ยครับว่า

00:33:33.919 --> 00:33:36.439
ถ้าจะศึกษา functional programming เพิ่ม

00:33:36.760 --> 00:33:40.920
มีที่ไหนที่ฝึกศึกษาแล้วแบบ efficient ที่สุด

00:33:41.120 --> 00:33:45.280
จริงๆ แล้วถ้าอยากเขียน functional programming จริงๆ เลยนะ

00:33:45.760 --> 00:33:48.199
อยากให้ลองเขียนด้วยภาษา Haskell

00:33:49.679 --> 00:33:52.440
มันจะบังคับเราทุกอย่างให้เขียนเป็นแบบ functional เลย

00:33:52.639 --> 00:33:55.877
เราจะไม่มีทางหลุดจากการเป็น functional way

00:33:55.960 --> 00:33:58.956
แต่ถ้าเราศึกษาด้วยภาษาอื่น อย่างเช่น JavaScript เนี่ย

00:33:59.039 --> 00:34:00.480
มันเขียนออกทะเลอะไรยังไงก็ได้

00:34:01.120 --> 00:34:02.316
เราคุมคอนโทรลไม่ได้เลย

00:34:02.399 --> 00:34:06.280
แต่ถ้าเป็น Haskell เนี่ย เราจะได้ศึกษาทั้ง type มันเป็นยังไง

00:34:06.559 --> 00:34:09.316
monad คืออะไร เราจะสามารถใช้ monad ได้

00:34:09.399 --> 00:34:11.197
โดยที่เราไม่รู้เลยว่ามันคือ monad

00:34:11.280 --> 00:34:14.159
เพราะว่ามันมี type บังคับเราอยู่ครับ

00:34:14.599 --> 00:34:21.639
แล้วมี use case ที่ใช้งานกับแอปพลิเคชันจริงๆ

00:34:21.760 --> 00:34:28.276
ที่มันช่วยให้งานเราง่ายขึ้นนะครับ

00:34:28.359 --> 00:34:32.520
จริงๆ แล้วความง่ายขึ้นของการใช้ functional programming ก็คือ

00:34:32.800 --> 00:34:34.596
หลักๆ ของ functional programming เนี่ย

00:34:34.679 --> 00:34:37.160
core ที่หลายคนเค้าเคยศึกษา

00:34:37.480 --> 00:34:41.316
เค้าจะบอกว่ามันจะ avoid เรื่องการ mutate state

00:34:41.399 --> 00:34:42.880
หรือการสร้าง side effect ใช่มั้ย

00:34:43.240 --> 00:34:47.079
สมมติเรามี function ยาวๆ จริงๆ business logic เรายาวมากเลย

00:34:47.359 --> 00:34:50.877
แล้วเราเขียนแบบ mutate state มั่วไปมาเนี่ย

00:34:50.960 --> 00:34:54.076
อนาคตที่เรามาแก้โค้ดเนี่ย

00:34:54.159 --> 00:34:56.197
มันจะเริ่มแบบ สะกิดตรงนี้ระเบิดตรงนั้น

00:34:56.280 --> 00:34:57.680
สะกิดตรงนั้นระเบิดตรงนี้ใช่ป่ะ

00:34:58.079 --> 00:35:00.677
แต่ถ้าเราเขียนโค้ดให้มันเป็นไปในแนวทางของ

00:35:00.760 --> 00:35:02.357
functional programming ครับ

00:35:02.440 --> 00:35:06.357
มันจะมีโอกาสเกิดปัญหาจากการที่เราไปเจอ side effect

00:35:06.440 --> 00:35:08.240
พวกนั้นน่ะได้น้อยลงครับ

00:35:10.440 --> 00:35:12.597
ต้องขอบอกว่าจริงๆ แล้วการเขียนเนี่ย

00:35:12.680 --> 00:35:17.756
ไม่ใช่ทุกคนเขียนได้หรือเขียนเป็นครับ

00:35:17.839 --> 00:35:19.400
ทีมก็ต้องศึกษา

00:35:19.520 --> 00:35:24.276
จริงๆ มันต้องมีการ knowledge sharing เนาะว่า

00:35:24.359 --> 00:35:27.160
จริงๆ แล้วการเขียนโค้ดเนี่ย มันเขียนได้หลายแบบ

00:35:27.280 --> 00:35:29.800
เขียนแบบ A เป็นไง เขียนแบบ B เป็นไง

00:35:29.960 --> 00:35:31.837
OOP ก็ดี ไม่ใช่ไม่ดีนะครับ

00:35:31.920 --> 00:35:33.360
ส่วน functional ก็ดี

00:35:33.480 --> 00:35:38.652
ขึ้นอยู่กับว่าเราสามารถ apply งั้นมาในงานเราได้ยังไงบ้างเนาะ

00:35:39.093 --> 00:35:42.317
จริงๆ แล้ว ไม่รู้ว่าทุกคนเขียน JavaScript

00:35:42.400 --> 00:35:43.677
ในชีวิตประจำวันรึเปล่านะ

00:35:43.760 --> 00:35:44.756
เราเขียน JavaScript เนี่ย

00:35:44.839 --> 00:35:47.640
มันเป็นภาษาที่สามารถ allow ให้เราเขียนได้หลายท่ามาก

00:35:47.960 --> 00:35:49.516
เราก็สามารถ mix ได้เนาะว่า

00:35:49.599 --> 00:35:51.080
ตรงเนี้ยมันควรเป็น OOP นะ

00:35:51.240 --> 00:35:54.077
ส่วนตรงเนี้ย function มันเป็น pure function ได้

00:35:54.160 --> 00:35:55.599
ทำเป็นแบบ functional ได้

00:35:56.040 --> 00:35:59.520
ก็ไม่ผิดที่จะใช้ 2 อย่างรวมกันนะครับ

00:36:00.200 --> 00:36:01.320
ครับ ขอบคุณครับ
