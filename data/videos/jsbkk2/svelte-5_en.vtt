WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:00.599 --> 00:00:05.517
Okay, hello everyone.

00:00:05.600 --> 00:00:10.040
Good morning JavaScript Bangkok.

00:00:12.120 --> 00:00:13.596
à¸§à¸¹à¹‰! à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¸£à¸±à¸š

00:00:13.679 --> 00:00:19.000
Thanks for the organizer for letting me speak today.

00:00:20.920 --> 00:00:25.436
I know we have some technical issues in the morning,

00:00:25.519 --> 00:00:29.116
but I think we all should give another round of applause

00:00:29.199 --> 00:00:32.280
to all the organizers to make this happen

00:00:32.520 --> 00:00:35.399
with such a short time.

00:00:36.079 --> 00:00:38.920
So thank you for everyone.

00:00:39.879 --> 00:00:45.757
I have a few proposals to come to Bangkok.

00:00:45.840 --> 00:00:47.397
I submitted a few proposals,

00:00:47.480 --> 00:00:50.397
but Phantip told me that you guys want to have

00:00:50.480 --> 00:00:52.359
a coding talk first thing in the morning.

00:00:52.559 --> 00:00:56.760
So I hope everyone is energized and ready for it.

00:00:57.760 --> 00:00:59.119
Let me introduce myself.

00:00:59.719 --> 00:01:02.120
I'm a frontend developer at Shopee.

00:01:02.640 --> 00:01:04.319
I'm based in Singapore.

00:01:04.519 --> 00:01:07.320
But I'm born and raised in Malaysia,

00:01:07.600 --> 00:01:11.000
in a beautiful town called Bukit Mertajam in Penang,

00:01:11.360 --> 00:01:13.839
which is very close to South Thailand.

00:01:14.280 --> 00:01:18.040
My parents used to go to Hat Yai over the weekends.

00:01:18.479 --> 00:01:20.280
This is my first time in Bangkok.

00:01:20.560 --> 00:01:22.797
So let me know if you have any place

00:01:22.880 --> 00:01:26.280
that you can recommend me that I should be visiting.

00:01:26.640 --> 00:01:29.396
Outside of work, I do a bit of open source,

00:01:29.479 --> 00:01:31.160
and this is my Twitter account.

00:01:31.799 --> 00:01:38.320
I also have a YouTube channel doing content about frontend

00:01:38.560 --> 00:01:42.240
that I wish was there when I first started out.

00:01:43.560 --> 00:01:46.919
Two years ago, I talked about "Build Your Own Svelte"

00:01:47.040 --> 00:01:48.197
at a conference.

00:01:48.280 --> 00:01:49.799
Back then it was about Svelte 3.

00:01:50.719 --> 00:01:52.240
And two years later, which is now,

00:01:52.920 --> 00:01:55.877
we now have Svelte 5 at release candidates.

00:01:55.960 --> 00:01:58.839
So I want to challenge myself to do a similar talk again,

00:01:59.119 --> 00:02:00.720
but for Svelte 5.

00:02:01.119 --> 00:02:03.039
This is my first time attempting it.

00:02:03.640 --> 00:02:07.720
This is the premier in JavaScript Bangkok.

00:02:08.160 --> 00:02:10.120
So what is Svelte?

00:02:10.720 --> 00:02:14.360
Well, Svelte is a compiler-based framework.

00:02:14.800 --> 00:02:17.520
This is how you write a Svelte component.

00:02:17.640 --> 00:02:21.880
The Svelte syntax closely resembles HTML syntax.

00:02:22.519 --> 00:02:24.520
You can define variables in script tags

00:02:24.720 --> 00:02:28.239
and use it in HTML using the curly brackets.

00:02:28.519 --> 00:02:30.639
And you can define CSS in the style tag.

00:02:31.120 --> 00:02:35.880
So in this case, we've made the text in red color.

00:02:37.720 --> 00:02:39.920
To make changes to variables,

00:02:40.200 --> 00:02:43.999
you have to mark the declaration with state runes.

00:02:44.599 --> 00:02:48.560
With the $state, you can modify them directly

00:02:48.800 --> 00:02:51.880
like how you would modify a variable in JavaScript.

00:02:52.080 --> 00:02:54.560
Here we add a click event listeners with onclick,

00:02:55.040 --> 00:02:56.757
which calls the decrement function,

00:02:56.840 --> 00:02:59.239
which then modifies the counter by doing counter minus 1,

00:02:59.959 --> 00:03:01.760
and then it just works.

00:03:02.400 --> 00:03:03.760
It's that simple.

00:03:04.200 --> 00:03:07.720
Svelte is a compiler-based framework.

00:03:07.920 --> 00:03:10.600
The code you see on the left is what you write,

00:03:10.840 --> 00:03:12.917
but it's not the one that is sent to the browser

00:03:13.000 --> 00:03:14.200
to interpret.

00:03:14.400 --> 00:03:18.519
The code you write on the left goes through a compiler,

00:03:18.640 --> 00:03:21.277
which analyzes and compiles it into JavaScript,

00:03:21.360 --> 00:03:23.439
the one that you see on the right.

00:03:23.959 --> 00:03:26.079
This is what is sent to the browser.

00:03:26.519 --> 00:03:28.199
Because of this compilation step,

00:03:28.560 --> 00:03:31.080
there's a lot of magical things you can do.

00:03:31.640 --> 00:03:34.760
But sometimes more magic doesn't mean it's always better.

00:03:35.400 --> 00:03:39.716
In Svelte 4, any top-level variables is magically

00:03:39.799 --> 00:03:43.440
analyzed and tracked during compile time for reactivity,

00:03:43.640 --> 00:03:44.837
which is very magical.

00:03:44.920 --> 00:03:46.799
It works like most of the cases,

00:03:47.000 --> 00:03:51.320
maybe 90% of 95% of the case, but sometimes it doesn't work.

00:03:51.720 --> 00:03:55.440
And when it doesn't work, it can be very frustrating.

00:03:55.560 --> 00:03:57.999
In Svelte 5, we introduce runes,

00:03:58.599 --> 00:04:01.679
which is like a marker for the Svelte compiler.

00:04:01.840 --> 00:04:05.597
You have to mark the variable when you declare,

00:04:05.680 --> 00:04:08.600
you use the $state runes to mark it.

00:04:09.079 --> 00:04:12.120
And then the compiler doesn't have to guess

00:04:12.239 --> 00:04:14.677
based on heuristics to figure out whether the variable

00:04:14.760 --> 00:04:16.599
is being used or modified.

00:04:22.079 --> 00:04:27.320
We know for sure what variables need to be reactive

00:04:27.440 --> 00:04:30.560
because it's being marked by the developers using runes.

00:04:31.039 --> 00:04:34.357
By using runes, it also opens up new opportunity,

00:04:34.440 --> 00:04:36.280
which wasn't possible in Svelte 4

00:04:36.600 --> 00:04:38.159
or the previous versions of Svelte,

00:04:38.759 --> 00:04:41.440
which is universal reactivity,

00:04:41.560 --> 00:04:44.277
where you can move the code for reactive states

00:04:44.360 --> 00:04:45.836
into reusable functions.

00:04:45.919 --> 00:04:48.157
You can copy the same code, move into a function,

00:04:48.240 --> 00:04:49.239
and it will still work.

00:04:49.680 --> 00:04:51.517
You don't have to rewrite the code in a totally

00:04:51.600 --> 00:04:53.400
different way to abstract it out,

00:04:53.720 --> 00:04:55.320
like how you would do in Svelte 4

00:04:55.639 --> 00:04:57.800
or the previous versions.

00:04:58.160 --> 00:05:00.396
Or you can also move it into a separate JavaScript file,

00:05:00.479 --> 00:05:01.400
and it still works.

00:05:01.919 --> 00:05:04.757
In Svelte 4, we simply can't track reactive states

00:05:04.840 --> 00:05:06.559
beyond the Svelte components.

00:05:06.759 --> 00:05:08.879
And that is where the magic breaks down.

00:05:09.479 --> 00:05:11.760
In Svelte 5, as reactive states

00:05:11.919 --> 00:05:13.357
no longer bound to a component,

00:05:13.440 --> 00:05:15.160
it can be created anywhere.

00:05:15.560 --> 00:05:18.877
So we stop trying to figure out how state changes

00:05:18.960 --> 00:05:22.160
affects the component UI or side effects

00:05:22.319 --> 00:05:23.639
during the compilation time.

00:05:24.199 --> 00:05:27.357
And now we leave the reactive dependency tracking

00:05:27.440 --> 00:05:28.279
to runtime,

00:05:29.240 --> 00:05:31.240
which we use as a concept of signals

00:05:31.479 --> 00:05:34.400
and achieve a fine-grained reactivity.

00:05:34.600 --> 00:05:36.600
We'll talk about that later on.

00:05:37.800 --> 00:05:39.277
In this talk, we're going to talk about

00:05:39.360 --> 00:05:41.280
how to build your own Svelte,

00:05:41.720 --> 00:05:45.159
which is to implement Svelte compiler during a talk,

00:05:45.400 --> 00:05:47.637
but not learning how to use Svelte.

00:05:47.720 --> 00:05:50.442
If you are interested to learn more about how to use Svelte,

00:05:51.120 --> 00:05:52.960
you can watch my YouTube tutorial.

00:05:55.280 --> 00:05:58.560
And so we mentioned that Svelte is a compiler.

00:05:58.960 --> 00:06:01.399
The word "compiler" sounds very scary.

00:06:01.919 --> 00:06:04.480
But let me try to explain to you in simple terms.

00:06:05.000 --> 00:06:08.320
In general, this is the breakdown of what a compiler does.

00:06:09.080 --> 00:06:12.556
It takes our code, it parses it, do some analysis,

00:06:12.639 --> 00:06:14.360
and finally generates an output.

00:06:14.800 --> 00:06:16.040
Let's take a closer look.

00:06:16.919 --> 00:06:19.120
When we say compiler parses your code,

00:06:19.360 --> 00:06:22.280
it takes the code, generates a representation of code,

00:06:23.240 --> 00:06:25.277
usually in a form of a tree structure,

00:06:25.360 --> 00:06:27.760
which we call it an abstract syntax tree.

00:06:29.199 --> 00:06:32.757
It's called abstract because it contains

00:06:32.840 --> 00:06:34.240
the abstract structure of your code.

00:06:34.400 --> 00:06:37.359
It does not contain all the details such as semicolon,

00:06:37.639 --> 00:06:39.480
parenthesis, spaces, or tabs.

00:06:40.000 --> 00:06:43.000
It just contains the structure and meaning of the code.

00:06:43.680 --> 00:06:45.400
And then the compiler analyzes your code.

00:06:45.960 --> 00:06:47.999
What this means is that it recursively goes through

00:06:48.160 --> 00:06:51.197
every node of the AST to gather information

00:06:51.280 --> 00:06:53.637
such as the JavaScript scopes, variables,

00:06:53.720 --> 00:06:56.039
looking for areas for optimizations.

00:07:00.560 --> 00:07:03.880
And then the compiler, with this information...

00:07:09.800 --> 00:07:10.637
The screen is not working.

00:07:10.720 --> 00:07:11.080
Hold on.

00:07:20.160 --> 00:07:21.837
With this information...

00:07:21.920 --> 00:07:29.956
Please.

00:07:30.039 --> 00:07:30.359
Okay.

00:07:34.360 --> 00:07:37.116
With this information, the compiler is able to generate

00:07:37.199 --> 00:07:38.560
a more optimized code.

00:07:39.160 --> 00:07:42.396
Today, with the time permits, we are going to implement

00:07:42.479 --> 00:07:45.360
a very simplified version of Svelte.

00:07:45.840 --> 00:07:47.997
And this will be our components that we are going

00:07:48.080 --> 00:07:48.879
to compile.

00:07:49.319 --> 00:07:52.477
Any Svelte features that you did not find in this

00:07:52.560 --> 00:07:54.637
component will not be implemented.

00:07:54.720 --> 00:07:57.597
And this example, this is the counter example that we

00:07:57.680 --> 00:07:58.560
just saw just now.

00:07:59.199 --> 00:08:03.319
Let's take a look at my project setup.

00:08:05.840 --> 00:08:07.920
So this is my project setup.

00:08:17.400 --> 00:08:21.800
Let me hold on the mic for a while.

00:08:26.319 --> 00:08:27.597
So this is my project setup.

00:08:27.680 --> 00:08:30.920
Let me zoom in and we can take a quick look over here.

00:08:31.800 --> 00:08:36.956
The first thing is that, as you can see, this is a basic

00:08:37.039 --> 00:08:39.879
JavaScript project where we have our package.json.

00:08:40.519 --> 00:08:42.997
And I have gone ahead of time to install all the

00:08:43.080 --> 00:08:45.760
necessary dependencies that we need over here.

00:08:46.360 --> 00:08:48.719
And this is basically where we're going to write our

00:08:48.880 --> 00:08:49.600
compiler.

00:08:49.880 --> 00:08:52.837
And the source folder, this is the components that you

00:08:52.920 --> 00:08:54.440
just saw earlier on.

00:08:54.920 --> 00:08:58.240
And we're going to build this into the dist folder.

00:08:59.480 --> 00:09:03.156
So, first thing first, I think we are in a hurry so I

00:09:03.239 --> 00:09:04.320
have to type very fast.

00:09:04.880 --> 00:09:07.876
First thing is I'm going to read the file content from

00:09:07.959 --> 00:09:08.480
the app.

00:09:08.800 --> 00:09:15.996
And then we're going to do three things: parse, analyze,

00:09:16.079 --> 00:09:17.040
and generate.

00:09:17.200 --> 00:09:19.637
And after it generates the JavaScript code, we need to

00:09:19.720 --> 00:09:21.520
write it into this folder like this.

00:09:26.000 --> 00:09:30.999
So we have the parse, analyze, and generate.

00:09:31.760 --> 00:09:36.160
I think we are very delayed so I have to write very fast.

00:09:44.360 --> 00:09:48.277
We keep mentioning about Svelte compiler will compile in

00:09:48.360 --> 00:09:50.560
compile time into JavaScript.

00:09:50.680 --> 00:09:53.159
But how does that even look like?

00:09:54.519 --> 00:09:58.237
This is where it's going to be a bit different from my

00:09:58.320 --> 00:10:01.040
previous talk where we talk about Svelte 4 and the

00:10:01.200 --> 00:10:03.479
versions before and Svelte 5.

00:10:03.600 --> 00:10:05.677
If you've seen my previous talk before, or played with

00:10:05.760 --> 00:10:08.477
it, you notice that the compiled output for Svelte 5 is

00:10:08.560 --> 00:10:11.640
going to be different and much smaller.

00:10:12.800 --> 00:10:19.037
For this talk, our simplified version of Svelte 5 will be

00:10:19.120 --> 00:10:23.800
based on the output from the Svelte 5 output.

00:10:25.040 --> 00:10:27.560
Let's take a look at this button over here.

00:10:29.040 --> 00:10:31.679
What's the best way of creating a button like this?

00:10:32.120 --> 00:10:35.959
It's going to be creating an element, using the DOM API

00:10:36.160 --> 00:10:40.320
ðšŒðš›ðšŽðšŠðšðšŽð™´ðš•ðšŽðš–ðšŽðš—ðš and ðšŠðš™ðš™ðšŽðš—ðšð™²ðš‘ðš’ðš•ðš.

00:10:41.480 --> 00:10:43.556
These two methods, we're going to use many times.

00:10:43.639 --> 00:10:46.917
So, let's extract it out into element function and also

00:10:47.000 --> 00:10:49.320
extract it out to the attribute function.

00:10:49.760 --> 00:10:53.556
And we want to be able to create this component, this

00:10:53.639 --> 00:10:56.040
button, multiple times.

00:10:56.200 --> 00:10:58.520
So, let's wrap it around with a function.

00:11:00.120 --> 00:11:03.196
Then when we want to mount or create this component, we

00:11:03.279 --> 00:11:06.717
can call the add function with an element that we want

00:11:06.800 --> 00:11:09.117
to create the component in, which in this case is

00:11:09.200 --> 00:11:10.556
document.body.

00:11:12.279 --> 00:11:14.717
We're going to use this element and attribute function

00:11:14.800 --> 00:11:16.520
multiple times as well.

00:11:16.760 --> 00:11:19.159
So, we're going to move them over into a separate file

00:11:19.519 --> 00:11:20.357
that looks like this.

00:11:20.440 --> 00:11:24.243
And so, we're going to import them from runtime.

00:11:26.800 --> 00:11:29.840
I actually went ahead and created this file.

00:11:30.279 --> 00:11:34.876
If you take a look over here, I have created these

00:11:34.959 --> 00:11:36.399
functions over here as well.

00:11:38.519 --> 00:11:42.319
So this is basically what the runtime is about.

00:11:43.360 --> 00:11:47.920
Let's go back to the slides.

00:11:54.079 --> 00:11:56.157
We're going to move on to element by element, like the

00:11:56.240 --> 00:11:57.999
buttons, we have this callback.

00:11:58.160 --> 00:12:00.397
And then for this text, we're going to create the text

00:12:00.480 --> 00:12:02.200
element with the text function.

00:12:02.480 --> 00:12:03.959
And we'll move on one by one.

00:12:04.160 --> 00:12:06.720
That step's basically we go through every node.

00:12:07.079 --> 00:12:09.200
And maybe you will ask me one question.

00:12:09.680 --> 00:12:12.717
So, what happens for the counter, which is dynamic

00:12:12.800 --> 00:12:13.556
expressions?

00:12:13.639 --> 00:12:15.639
Is there any special handling that we need to do?

00:12:16.560 --> 00:12:18.800
Well, we're going to keep that thought right now.

00:12:19.199 --> 00:12:21.040
We're going to come back to it later.

00:12:21.560 --> 00:12:25.436
And maybe another question would be, this visualization

00:12:25.519 --> 00:12:30.079
looks simple from the screen, but how are you going to

00:12:30.839 --> 00:12:31.880
do it in your code?

00:12:32.880 --> 00:12:36.677
Because ultimately, the code that you see when you pass

00:12:36.760 --> 00:12:39.280
it into a compiler is just a string.

00:12:39.720 --> 00:12:42.240
How do you understand the string, what are the elements

00:12:42.440 --> 00:12:42.840
there?

00:12:43.920 --> 00:12:48.397
That's why we need to parse our code into AST, a tree

00:12:48.480 --> 00:12:49.279
structure.

00:12:50.000 --> 00:12:52.436
It will be much easier if you visualize it with a tree

00:12:52.519 --> 00:12:55.717
structure because going through element by element is

00:12:55.800 --> 00:12:59.717
basically traversing through the node one by one, using

00:12:59.800 --> 00:13:02.519
depth first search or breadth first search.

00:13:03.320 --> 00:13:07.920
Now this basically begs the question of, how do you write

00:13:08.240 --> 00:13:08.840
the parser?

00:13:09.040 --> 00:13:11.080
How do you parse the string into an AST?

00:13:11.760 --> 00:13:14.077
Like all things in programming, there's always a

00:13:14.160 --> 00:13:15.040
technique to do it.

00:13:16.320 --> 00:13:20.959
First of all, and also like all things in programming,

00:13:21.079 --> 00:13:23.040
you need to first have a PRD.

00:13:23.560 --> 00:13:26.597
A design document so that you implement exactly like the

00:13:26.680 --> 00:13:30.436
documents unless you be questioned like why you do

00:13:30.519 --> 00:13:31.600
something different.

00:13:31.800 --> 00:13:34.360
So, the PRD or the design document for

00:13:37.279 --> 00:13:41.556
A parser will be something like, use a syntax notation

00:13:41.639 --> 00:13:43.480
to describe it, right?

00:13:43.839 --> 00:13:46.597
So, a syntax notation can be, there's multiple ways

00:13:46.680 --> 00:13:48.000
of describing a syntax.

00:13:48.480 --> 00:13:50.839
You have the railroad diagram.

00:13:51.320 --> 00:13:53.679
You can have the Backus-Naur form.

00:13:54.240 --> 00:13:56.479
And in this example that I show you over here,

00:13:57.000 --> 00:14:00.360
describes how a JSON string will look like.

00:14:00.880 --> 00:14:01.196
Okay?

00:14:01.279 --> 00:14:03.397
So we know how a JSON string looks like, right?

00:14:03.480 --> 00:14:06.116
That's usually what a JSON will be passed through

00:14:06.199 --> 00:14:07.200
your API calls.

00:14:07.600 --> 00:14:10.556
And a JSON object string, right, the JSON object

00:14:10.639 --> 00:14:14.556
itself is described with, it can be either open and

00:14:14.639 --> 00:14:17.116
close curly brackets, so that describes an empty

00:14:17.199 --> 00:14:21.397
object, or the open curly brackets with a list of

00:14:21.480 --> 00:14:23.560
properties and a close curly brackets.

00:14:23.880 --> 00:14:26.440
And you ask me like, what is inside a property list?

00:14:26.639 --> 00:14:29.200
Well, the syntax for that will be either one property

00:14:29.920 --> 00:14:33.600
or multiple properties, or a property list with a

00:14:33.959 --> 00:14:36.200
comma and then a property.

00:14:36.639 --> 00:14:38.397
And you can see that there's some recursiveness in

00:14:38.480 --> 00:14:39.599
the syntax as well.

00:14:40.120 --> 00:14:42.960
And like, how do you describe the syntax for property?

00:14:43.079 --> 00:14:47.200
Can be a JSON string with a colon and then the value.

00:14:47.720 --> 00:14:51.000
Right, but so, you roughly get the idea of a syntax

00:14:51.759 --> 00:14:54.720
document, syntax notation of a JSON string.

00:14:55.240 --> 00:14:55.637
Right?

00:14:55.720 --> 00:14:58.077
And today we're going to talk about Svelte, right?

00:14:58.160 --> 00:15:00.119
So how's the syntax of Svelte?

00:15:00.639 --> 00:15:05.436
Well, for Svelte, I'm going to define it as a list

00:15:05.519 --> 00:15:06.559
of fragments.

00:15:06.759 --> 00:15:09.277
And the definition of the syntax for fragments can be

00:15:09.360 --> 00:15:13.277
one fragment or a fragment with more, one fragment,

00:15:13.480 --> 00:15:15.840
So it can be, it's recursively many numbers of

00:15:16.199 --> 00:15:16.999
fragments.

00:15:17.199 --> 00:15:19.676
And a fragment, the syntax of fragment can be the

00:15:19.759 --> 00:15:22.679
syntax of scripts and then the syntax of elements if

00:15:23.000 --> 00:15:25.679
that's available, or expressions or text.

00:15:26.279 --> 00:15:26.639
Right?

00:15:26.839 --> 00:15:29.560
And then the syntax for the script is basically the

00:15:29.920 --> 00:15:33.277
angle bracket script and a close angle brackets with

00:15:33.360 --> 00:15:35.600
some JavaScript inside and an angle bracket slash

00:15:36.199 --> 00:15:37.556
script, right?

00:15:37.639 --> 00:15:40.319
And we can basically keep going on and on, right?

00:15:40.680 --> 00:15:43.316
Like, for example, expressions could be a curly

00:15:43.399 --> 00:15:46.080
brackets with some JavaScript and a curly brackets.

00:15:46.360 --> 00:15:52.279
So this describes what's the syntax of a JavaScript,

00:15:52.639 --> 00:15:55.640
sorry, describe the syntax of Svelte, right?

00:15:56.639 --> 00:16:00.919
So, let's, I initially planned to implement this

00:16:01.079 --> 00:16:02.996
whole thing in a talk.

00:16:03.079 --> 00:16:06.116
Even if I try to type very fast, I still couldn't

00:16:06.199 --> 00:16:08.320
finish the whole talk within 40 minutes.

00:16:08.440 --> 00:16:13.436
So, if you want to see me code it live, like going

00:16:13.519 --> 00:16:16.157
through the syntax documents, you can watch my

00:16:16.240 --> 00:16:17.039
previous talk.

00:16:17.800 --> 00:16:20.756
You can search for "Build your own Svelte", but for

00:16:20.839 --> 00:16:26.159
this talk, I'm going to still do some copy pasting.

00:16:26.720 --> 00:16:30.760
That's faster than typing very fast.

00:16:31.720 --> 00:16:33.556
So, where's my cursor again?

00:16:33.639 --> 00:16:34.440
Oh, it's here.

00:16:34.600 --> 00:16:36.037
Okay, so I prepared this.

00:16:36.120 --> 00:16:37.960
So this is what I'm going to copy.

00:16:38.720 --> 00:16:39.200
Right?

00:16:40.880 --> 00:16:44.639
And I'm going to paste it over here.

00:16:45.319 --> 00:16:45.799
Right?

00:16:46.839 --> 00:16:48.519
And let's see.

00:16:50.399 --> 00:16:50.799
Right?

00:16:51.399 --> 00:16:54.277
Okay, and I also need to import Acorn as a

00:16:54.360 --> 00:16:56.640
JavaScript parser to parse the code.

00:16:57.240 --> 00:17:00.397
And basically, let me quickly go through, right?

00:17:00.480 --> 00:17:03.797
So how it looks like is that you have the functions

00:17:03.880 --> 00:17:05.397
for each of the parsing, right?

00:17:05.480 --> 00:17:07.157
You parse the fragments, fragments, scripts,

00:17:07.240 --> 00:17:08.596
elements, and stuff, right?

00:17:08.679 --> 00:17:11.637
And if you look at fragments, right, in our design

00:17:11.720 --> 00:17:13.677
previously, we say that it's either scripts,

00:17:13.760 --> 00:17:15.319
elements, expression, or text.

00:17:15.439 --> 00:17:16.679
So that's how I'm going to write it.

00:17:17.120 --> 00:17:20.637
And for expressions, it's like a curly bracket.

00:17:20.720 --> 00:17:22.996
So if it matches a curly bracket, we're going to

00:17:23.079 --> 00:17:26.517
consume a curly bracket, take in some JavaScript,

00:17:26.600 --> 00:17:28.277
and then consume another curly bracket.

00:17:28.360 --> 00:17:31.280
And that will be our expression node.

00:17:31.880 --> 00:17:32.077
Right?

00:17:32.160 --> 00:17:35.157
So, let's see.

00:17:35.240 --> 00:17:37.637
So let's try to run this code first, right?

00:17:37.720 --> 00:17:43.040
So, let me comment some of the things out, like this.

00:17:43.320 --> 00:17:48.480
And so this is what we have, and let's run.

00:17:49.400 --> 00:17:52.520
So this is the AST, the structure that we have.

00:17:52.960 --> 00:17:57.840
Let me just try to maybe save it into a file.

00:17:58.679 --> 00:18:10.479
This is me slow typing of AST or JSON.

00:18:11.159 --> 00:18:12.400
Let's save this.

00:18:13.400 --> 00:18:18.599
And basically, you can see that this is the syntax,

00:18:18.799 --> 00:18:20.917
this is the tree structure for the script as well as

00:18:21.000 --> 00:18:24.400
the HTML where we have the buttons and attributes,

00:18:24.640 --> 00:18:27.677
the text, and expressions and stuff, right?

00:18:27.760 --> 00:18:30.800
So now we have our parser.

00:18:31.200 --> 00:18:36.600
Let's try to go back and, let's see, close this.

00:18:38.760 --> 00:18:39.480
Let's reset.

00:18:39.880 --> 00:18:42.357
Let's come back and move on to the next thing,

00:18:42.440 --> 00:18:49.116
which is, why is it my, sorry.

00:18:49.199 --> 00:18:50.199
Oh, okay.

00:18:50.600 --> 00:18:51.039
Got it.

00:18:51.280 --> 00:18:54.280
So we're going to move on to generate the code,

00:18:54.480 --> 00:18:54.637
right?

00:18:54.720 --> 00:18:57.357
So to write the generate, so we're going to skip the

00:18:57.440 --> 00:18:59.956
analysis part because I think today, for the lack of

00:19:00.039 --> 00:19:03.596
time, we probably don't need to analyze too much of

00:19:03.679 --> 00:19:06.836
the code, and we jump straight to write the generate

00:19:06.919 --> 00:19:07.596
function.

00:19:07.840 --> 00:19:10.037
So I'm going to have the code that we just saw that

00:19:10.120 --> 00:19:13.157
we ran through earlier on over here on the screen,

00:19:13.360 --> 00:19:17.557
So this is the code that we need to generate, right?

00:19:17.640 --> 00:19:21.520
So let's move on to writing this.

00:19:22.559 --> 00:19:26.160
So first thing is that let me collapse this.

00:19:26.840 --> 00:19:28.357
Okay, so first thing is we're going to go through

00:19:28.440 --> 00:19:31.956
the writing the generate function.

00:19:32.039 --> 00:19:34.240
So we're going to have the string where we're going

00:19:34.400 --> 00:19:37.357
to create an array, and then we're going to join all

00:19:37.440 --> 00:19:42.237
the, we're going to push to the string array, and

00:19:42.320 --> 00:19:45.037
then we're going to join all of them into with new

00:19:45.120 --> 00:19:45.476
lines.

00:19:45.559 --> 00:19:52.880
So the first line, sorry, let me try whether I can

00:19:55.000 --> 00:19:55.240
see.

00:19:56.000 --> 00:19:57.199
Oh, okay.

00:19:57.640 --> 00:19:58.157
So I can't.

00:19:58.240 --> 00:20:01.960
Okay, anyway, so over here, I have the imports and

00:20:06.720 --> 00:20:06.960
the

00:20:07.720 --> 00:20:23.517
Okay, so here we have the elements, right?

00:20:23.600 --> 00:20:25.557
We have the import statements and a function.

00:20:25.640 --> 00:20:27.560
So that's what we're going to write first.

00:20:27.880 --> 00:20:31.840
And then we're going to close the brackets.

00:20:32.200 --> 00:20:36.037
Then we're going to walk through our AST one by one,

00:20:36.120 --> 00:20:37.160
go through every nodes.

00:20:37.440 --> 00:20:39.997
And for this, I'm going to need a library called

00:20:40.080 --> 00:20:41.160
estree-walker.

00:20:41.720 --> 00:20:44.596
And with a ðš ðšŠðš•ðš” method to walk through,

00:20:44.679 --> 00:20:48.476
we're going to basically walk the HTML, right?

00:20:48.559 --> 00:20:51.357
And it takes in two like the node that we're going to

00:20:51.440 --> 00:20:54.000
traverse through and then it takes in a state

00:20:54.200 --> 00:20:55.560
which I'm going to explain later on.

00:20:56.039 --> 00:20:58.157
And then this will be the visitor which I'm going to

00:20:58.240 --> 00:20:59.357
explain later on as well.

00:20:59.440 --> 00:21:01.840
So for the state, it's something that you can pass in

00:21:02.480 --> 00:21:05.677
as like a state of that traverser tree traversing.

00:21:05.760 --> 00:21:11.440
And we can use it when we traverse to each of the nodes.

00:21:11.679 --> 00:21:13.559
And for the states, what we're going to store here is

00:21:13.880 --> 00:21:16.599
we're going to keep basically know what is the parents

00:21:16.760 --> 00:21:19.637
that I need to insert the elements into, right?

00:21:19.720 --> 00:21:24.357
So the initial node is basically this parent that

00:21:24.440 --> 00:21:27.279
we're going to get from the function.

00:21:27.559 --> 00:21:30.157
And then for visitor, basically we can look over here

00:21:30.240 --> 00:21:31.596
what are the types of elements, right?

00:21:31.679 --> 00:21:32.997
So the first one is elements.

00:21:33.080 --> 00:21:34.400
So I'm going to visit this node.

00:21:34.720 --> 00:21:37.357
So over here, I'm going to write like elements, right?

00:21:37.440 --> 00:21:40.917
And basically we're going to create some variables

00:21:41.000 --> 00:21:44.119
to create elements and you've seen this where we can

00:21:45.080 --> 00:21:48.480
iterate through the attributes and then creates the nodes.

00:21:48.720 --> 00:21:51.557
Basically this will look exactly the one that we saw

00:21:51.640 --> 00:21:54.596
earlier on in our slides where we create an elements

00:21:54.679 --> 00:21:58.160
and attribute for the elements.

00:21:59.159 --> 00:22:02.520
Then so for the attributes, right?

00:22:03.520 --> 00:22:05.480
If you take a look over here in the AST,

00:22:06.039 --> 00:22:06.877
it's expressions.

00:22:06.960 --> 00:22:08.357
Basically it's JavaScript.

00:22:08.440 --> 00:22:12.759
So I'm going to turn JavaScript in AST into string.

00:22:13.000 --> 00:22:14.200
So that's what we're going to do.

00:22:14.400 --> 00:22:17.399
We're going to import a library called print

00:22:17.600 --> 00:22:19.199
from esrap.

00:22:19.679 --> 00:22:23.037
Basically it's a reverse of parse,

00:22:23.120 --> 00:22:25.960
that turns parse is to turn string into AST,

00:22:26.200 --> 00:22:28.640
but this is to AST into back into the string.

00:22:29.200 --> 00:22:34.836
So here we are going to call the print to print it

00:22:34.919 --> 00:22:36.240
into the string code.

00:22:36.760 --> 00:22:41.040
And then we're going to look through all the children's.

00:22:41.240 --> 00:22:43.559
And we're going to go for every node as well,

00:22:43.760 --> 00:22:46.160
the text and expressions, okay?

00:22:46.520 --> 00:22:52.999
So now with this, I think we are good to try,

00:22:53.120 --> 00:22:56.560
give it a try to run our compiler.

00:22:56.840 --> 00:22:58.677
And if you can take a look at the compiled code

00:22:58.760 --> 00:23:01.117
over here, basically it looks like this, right?

00:23:01.200 --> 00:23:02.797
So we recursively going through every nodes and

00:23:02.880 --> 00:23:04.320
generate the strings needed.

00:23:04.760 --> 00:23:09.439
And here, I think the button itself needs to deconflict,

00:23:09.679 --> 00:23:12.400
So we're going to do it real quick over here.

00:23:14.799 --> 00:23:22.880
Sorry, where's my... Hold on, where

00:23:30.520 --> 00:23:33.040
Yep, so I'm going to do this.

00:23:33.720 --> 00:23:36.160
And now, basically, the generated code,

00:23:36.520 --> 00:23:39.079
we have adding the index at the back,

00:23:39.200 --> 00:23:40.877
and this probably will create the elements

00:23:40.960 --> 00:23:46.076
that we need for our code, right?

00:23:46.159 --> 00:23:47.117
So, at the same time,

00:23:47.200 --> 00:23:49.157
I think I'm going to start the dev server,

00:23:49.240 --> 00:23:51.560
so you can look at what's the generated code so far.

00:23:52.159 --> 00:23:55.679
Let me zoom this in and also inspect elements.

00:23:56.159 --> 00:24:01.720
So, this part basically we haven't added,

00:24:02.159 --> 00:24:04.076
we've created the code,

00:24:04.159 --> 00:24:07.037
but we haven't include the definition of decrement

00:24:07.120 --> 00:24:08.757
and increment from the scripts, right?

00:24:08.840 --> 00:24:09.960
So that's what we're going to do.

00:24:10.520 --> 00:24:13.800
We're going to come over here and do that real quick.

00:24:14.080 --> 00:24:15.997
So we're going to print the script into the function

00:24:16.080 --> 00:24:16.800
as well.

00:24:17.400 --> 00:24:23.720
And basically that will give us this.

00:24:24.080 --> 00:24:27.199
I mean, I think switch this like this.

00:24:27.720 --> 00:24:29.836
Okay, so basically this gives us all the code

00:24:29.919 --> 00:24:30.600
over here.

00:24:31.000 --> 00:24:34.560
And I think it's ready to run.

00:24:35.240 --> 00:24:36.637
Oh, okay, state is not defined.

00:24:36.720 --> 00:24:39.280
Hold on, let me try to quickly fix this.

00:24:43.480 --> 00:24:46.560
I think we can add over here.

00:24:47.600 --> 00:24:49.520
And if you refresh,

00:24:49.679 --> 00:24:52.840
you can see basically we have the elements

00:24:53.279 --> 00:24:56.120
created through our compiled code in our script.

00:24:56.640 --> 00:24:58.997
Right, so although like the function is not working,

00:24:59.080 --> 00:25:00.720
but basically you can trust me that

00:25:01.240 --> 00:25:03.277
it's everything is created nicely.

00:25:03.360 --> 00:25:05.277
And the next thing we need to do is to basically

00:25:05.360 --> 00:25:10.997
figure out how to make the reactive works, right?

00:25:11.080 --> 00:25:14.479
So here, I think I need to quickly fix a bit

00:25:14.679 --> 00:25:17.520
where the part where we,

00:25:18.360 --> 00:25:20.360
I see where the part where we,

00:25:21.200 --> 00:25:23.080
oh yeah, we need to change all,

00:25:23.240 --> 00:25:24.357
we're going to walk through all the scripts

00:25:24.440 --> 00:25:28.000
and change all the things that we use the dollar states

00:25:28.320 --> 00:25:29.637
into the dollar.states, right?

00:25:29.720 --> 00:25:31.359
That's something that we just now was fixed

00:25:31.480 --> 00:25:32.440
in our output.

00:25:32.880 --> 00:25:35.476
So now we need to go back to our slides

00:25:35.559 --> 00:25:38.880
and figure out how we make the reactive if works.

00:25:39.480 --> 00:25:41.840
Right, so we are still here,

00:25:42.080 --> 00:25:43.557
trying to figure out like how do we make sure

00:25:43.640 --> 00:25:44.720
that this updates.

00:25:45.080 --> 00:25:48.119
Right, over here, we have an expressions in a template.

00:25:48.399 --> 00:25:50.397
We need to know the expressions

00:25:50.480 --> 00:25:53.440
or any variables that's being used in this expression,

00:25:54.240 --> 00:25:56.157
when does then change, right?

00:25:56.240 --> 00:25:58.397
Or whether for the variables,

00:25:58.480 --> 00:26:00.836
we need to know like how is it being used

00:26:00.919 --> 00:26:02.240
or when is it being used,

00:26:02.600 --> 00:26:04.760
so that we know when what we need to do

00:26:05.320 --> 00:26:07.199
when that variable has changed.

00:26:07.760 --> 00:26:08.200
But how?

00:26:08.799 --> 00:26:10.840
Well, let's take a step back.

00:26:11.360 --> 00:26:15.076
Right, so I know we didn't notice this,

00:26:15.159 --> 00:26:19.920
but every time when we have variables,

00:26:20.039 --> 00:26:24.397
what we would do is that when we pass variables around,

00:26:24.480 --> 00:26:26.080
we're actually doing two things at once.

00:26:26.320 --> 00:26:28.237
We're trying to get the reference of the variable

00:26:28.320 --> 00:26:31.237
and also read the value from the variable itself, right?

00:26:31.320 --> 00:26:32.277
So, for example,

00:26:32.360 --> 00:26:35.600
when you pass a variable to console.log like this,

00:26:35.960 --> 00:26:38.719
you're actually referencing to the variable itself

00:26:39.000 --> 00:26:40.600
as well as reading the value,

00:26:40.840 --> 00:26:42.160
right, and printing out to the logs.

00:26:45.039 --> 00:26:46.437
We kind of know that it will read the value

00:26:46.520 --> 00:26:47.800
from the variable object

00:26:48.080 --> 00:26:50.320
because we see the value printed out in the logs.

00:26:50.799 --> 00:26:52.039
But for the variable itself,

00:26:52.360 --> 00:26:55.280
it has no way to know whether its value is being read,

00:26:55.640 --> 00:26:55.877
right?

00:26:55.960 --> 00:26:57.877
For example, I pass this variable into a function

00:26:57.960 --> 00:26:58.601
called doSomething,

00:26:59.200 --> 00:27:02.720
I wouldn't know that whether my value is being read.

00:27:03.320 --> 00:27:05.599
And why is that important?

00:27:05.799 --> 00:27:08.677
Well, it is important for our case because

00:27:08.760 --> 00:27:09.917
for our state variables,

00:27:10.000 --> 00:27:11.997
we want to know which elements

00:27:12.080 --> 00:27:15.637
or like when or how it's being read, right?

00:27:15.720 --> 00:27:17.277
If no one is reading this value,

00:27:17.360 --> 00:27:18.557
when we update this variable,

00:27:18.640 --> 00:27:20.476
we know we don't need to do anything.

00:27:20.559 --> 00:27:21.199
That's good.

00:27:21.640 --> 00:27:24.200
But if there's one element reading its value,

00:27:24.360 --> 00:27:27.040
we need to know which element or how is it being read,

00:27:27.200 --> 00:27:30.600
so that we can precisely update only that element.

00:27:30.799 --> 00:27:34.560
And this is what we call fine-grained reactivity.

00:27:34.760 --> 00:27:36.240
So how do we implement this?

00:27:36.760 --> 00:27:39.000
Well, we're going to use the concept called signals,

00:27:39.360 --> 00:27:41.637
which separates like getting the reference

00:27:41.720 --> 00:27:44.480
and the actual reading of the value.

00:27:45.080 --> 00:27:47.280
There's many ways of implementing signals,

00:27:47.480 --> 00:27:49.836
and one of it is to have the signal implemented

00:27:49.919 --> 00:27:52.797
like an object with a get method, right?

00:27:52.880 --> 00:27:53.997
You can pass the reference,

00:27:54.080 --> 00:27:56.037
like the written object, we call it a signal.

00:27:56.120 --> 00:27:57.157
You can pass this object,

00:27:57.240 --> 00:27:59.720
reference of this object anywhere, right?

00:28:00.080 --> 00:28:03.797
You can pass it into aâ€¦

00:28:03.880 --> 00:28:08.196
Do something function and you know you're just passing in

00:28:08.279 --> 00:28:11.997
a reference and you also know when the value is being read

00:28:12.080 --> 00:28:14.956
because it has to call the ðšðšŽðš methods, right?

00:28:15.039 --> 00:28:17.237
So you know exactly when it's being called to read

00:28:17.320 --> 00:28:19.917
the value inside the signals and you can actually do

00:28:20.000 --> 00:28:23.440
something about it like making an alert.

00:28:24.200 --> 00:28:29.196
So this is a very simplified version of signals that

00:28:29.279 --> 00:28:32.160
we're going to create and we're going to pass it into

00:28:33.360 --> 00:28:35.319
we're going to make some changes to our generated code.

00:28:35.919 --> 00:28:40.079
So here in our generated code instead of passing counter,

00:28:40.200 --> 00:28:42.759
now we got the counter is a signal.

00:28:42.919 --> 00:28:45.476
So we're going to take in a function and we're going to

00:28:45.559 --> 00:28:48.159
return we're going to read the value only inside

00:28:48.360 --> 00:28:49.919
the text method over here.

00:28:50.039 --> 00:28:54.760
So only call the ðšðšŽðš when we want to create the elements,

00:28:55.200 --> 00:28:58.000
when we want to set the text content for that text node.

00:28:58.880 --> 00:29:04.879
So this statement itself, we want this statement to run

00:29:05.240 --> 00:29:08.596
whenever the counter signal is changed.

00:29:08.679 --> 00:29:10.559
The value of the counter signal has changed.

00:29:10.760 --> 00:29:14.397
And in general, basically any signal values that is being

00:29:14.480 --> 00:29:17.956
read inside the text function, whenever those signal

00:29:18.039 --> 00:29:20.677
values has changed, what we want is that we want to

00:29:20.760 --> 00:29:23.596
rerun this statement again to update the text value

00:29:23.679 --> 00:29:24.680
of our text node.

00:29:25.360 --> 00:29:28.117
And to do that, we're going to introduce another concept

00:29:28.200 --> 00:29:30.800
called effect.

00:29:31.159 --> 00:29:32.800
We're going to wrap it inside effect.

00:29:33.440 --> 00:29:36.436
So we haven't talked about what is effect, but let's

00:29:36.519 --> 00:29:38.280
just imagine that this is our goal.

00:29:38.480 --> 00:29:41.280
Our goal is that the callback function within effect,

00:29:41.840 --> 00:29:46.157
this function will be called again whenever any signals

00:29:46.240 --> 00:29:48.357
value that is being read within the effect callback

00:29:48.440 --> 00:29:49.919
function is updated.

00:29:50.559 --> 00:29:53.117
So I'm not sure whether it sounds confused, but let me

00:29:53.200 --> 00:29:54.680
try to illustrate how it works.

00:29:55.200 --> 00:29:57.760
So hopefully this makes it clearer.

00:29:58.279 --> 00:29:59.600
So this is the function.

00:30:00.679 --> 00:30:04.797
The effect function and we will first run its inner

00:30:04.880 --> 00:30:08.997
callback function which is this one which itself has

00:30:09.080 --> 00:30:10.640
one statement which is this.

00:30:11.279 --> 00:30:14.037
So when we call this statement which eventually calls

00:30:14.120 --> 00:30:18.920
the text function and eventually will try to get

00:30:19.120 --> 00:30:21.640
the counter signal, the value of the counter signal.

00:30:22.440 --> 00:30:24.797
And basically this signal knows that its value is

00:30:24.880 --> 00:30:25.596
being read.

00:30:25.679 --> 00:30:27.357
It's like, "Oh, okay. I'm being read.

00:30:27.440 --> 00:30:31.476
So may I ask like which effect callback is calling

00:30:31.559 --> 00:30:33.439
causing my value to be read?"

00:30:34.039 --> 00:30:34.800
Oh, it's this one.

00:30:35.559 --> 00:30:38.237
So I'm going to keep a reference of this function inside

00:30:38.320 --> 00:30:41.836
myself so that I will know to call this again the next

00:30:41.919 --> 00:30:43.520
time when my value has changed.

00:30:44.159 --> 00:30:47.316
So after I keep the reference and also return the value

00:30:47.399 --> 00:30:50.316
of the signals which is zero, I'm going to set the text

00:30:50.399 --> 00:30:51.800
element content to be zero.

00:30:51.960 --> 00:30:55.040
So we'll run this line and then the text you see is zero.

00:30:55.519 --> 00:30:56.479
And then this is done.

00:30:57.279 --> 00:30:59.757
Until sometime later, maybe somewhere else, someone

00:30:59.840 --> 00:31:02.080
modified the signal value to one.

00:31:02.760 --> 00:31:04.677
Now the signal will think like, "Oh, okay.

00:31:04.760 --> 00:31:05.757
My value has changed.

00:31:05.840 --> 00:31:07.679
I need to call the effect callback again."

00:31:08.000 --> 00:31:08.800
Which is this one.

00:31:08.919 --> 00:31:11.596
We're going to call this which will call the text

00:31:11.679 --> 00:31:14.196
function which will call the counter.ðšðšŽðš which will

00:31:14.279 --> 00:31:16.716
returns me the value of one and I'm going to update

00:31:16.799 --> 00:31:18.959
the text of the elements to be one.

00:31:19.639 --> 00:31:21.159
And so you get it.

00:31:21.559 --> 00:31:23.716
So the text element will update whenever the signal

00:31:23.799 --> 00:31:24.960
value has changed.

00:31:25.159 --> 00:31:28.640
Of course, this oversimplifies the complexity of signals

00:31:28.840 --> 00:31:30.639
of all the different frameworks out there.

00:31:31.039 --> 00:31:34.157
And there's also a few things that we didn't explain

00:31:34.240 --> 00:31:36.357
or handle well in this illustration.

00:31:36.440 --> 00:31:39.836
For example, we need to make sure that if we have

00:31:39.919 --> 00:31:42.997
multiple signals updating at the same time, we only want

00:31:43.080 --> 00:31:45.716
this function to be called only once or maybe there's

00:31:45.799 --> 00:31:49.877
multiple signals being read in or the next time when

00:31:49.960 --> 00:31:53.037
the effect has called and we have more or less signals,

00:31:53.120 --> 00:31:54.720
we need to update that as well.

00:31:55.080 --> 00:31:58.719
But those are not handled, but basically you get the idea.

00:31:59.559 --> 00:32:01.399
So now you know how it works.

00:32:01.679 --> 00:32:03.439
Let's quickly implement that.

00:32:07.559 --> 00:32:09.076
I think we left with 5 minutes.

00:32:09.159 --> 00:32:12.160
So let's see where's my code.

00:32:12.760 --> 00:32:14.120
This is the runtime.

00:32:21.440 --> 00:32:23.157
Okay, so we'll run this.

00:32:23.240 --> 00:32:24.839
So here is our states.

00:32:25.399 --> 00:32:28.637
So we're going to change this to like the ðšðšŽðš function

00:32:28.720 --> 00:32:29.719
that we saw just now.

00:32:30.159 --> 00:32:33.596
And next thing is that we're going to create the effect

00:32:33.679 --> 00:32:36.476
function and we need to remember what's the callback.

00:32:36.559 --> 00:32:37.716
So we need to keep the reference.

00:32:37.799 --> 00:32:40.076
So we create a variable to store it and then we call

00:32:40.159 --> 00:32:41.399
the callback function.

00:32:41.639 --> 00:32:45.079
And then so over here, we go back to our states over here.

00:32:45.240 --> 00:32:46.357
We know that okay.

00:32:46.440 --> 00:32:48.997
So we check whether what's the current effect that's

00:32:49.080 --> 00:32:49.677
been running.

00:32:49.760 --> 00:32:53.199
I'm going to store that reference within the signal itself.

00:32:54.039 --> 00:32:57.316
So with now the signal knows what are the effects that's

00:32:57.399 --> 00:32:59.800
been run whenever we call the effect.

00:33:00.320 --> 00:33:03.556
We will add another method called the ðšœðšŽðš which will

00:33:03.639 --> 00:33:07.316
basically update the value and then also call all

00:33:07.399 --> 00:33:09.920
the effects that is being stored.

00:33:10.279 --> 00:33:13.079
So that's basically the idea.

00:33:13.720 --> 00:33:16.836
And then lastly, I think we need to update the text

00:33:16.919 --> 00:33:19.039
function to do effect like this.

00:33:20.159 --> 00:33:21.560
And I think that's it.

00:33:21.679 --> 00:33:28.520
That's the basic very basic implementation for our runtime.

00:33:28.880 --> 00:33:32.840
And I think I quickly go over here to make some changes

00:33:33.000 --> 00:33:35.240
to see how it actually works.

00:33:35.399 --> 00:33:38.559
So first is that for the text function over here,

00:33:39.120 --> 00:33:42.439
now we are taking a function instead.

00:33:42.720 --> 00:33:44.000
So let me break it down.

00:33:44.399 --> 00:33:50.076
So this takes in a function and then the counter we need

00:33:50.159 --> 00:33:53.320
to call ðšðšŽðš instead of just returning the value.

00:33:53.559 --> 00:33:55.560
And over here, we need to call ðšœðšŽðš.

00:34:05.480 --> 00:34:10.159
With the counter get.

00:34:11.399 --> 00:34:13.799
So basically these are some small changes that we will

00:34:13.919 --> 00:34:15.599
implement in a compiler later on.

00:34:16.919 --> 00:34:19.877
Let's save this and let's quickly go to our browser

00:34:19.960 --> 00:34:21.320
and then refresh.

00:34:22.000 --> 00:34:23.919
I think I make a typo just now.

00:34:24.320 --> 00:34:24.880
Okay, S.

00:34:25.879 --> 00:34:26.357
Refresh.

00:34:26.440 --> 00:34:30.600
So now we figure out the runtime, which is the tracking,

00:34:30.720 --> 00:34:34.197
and then we also updated our tweak a bit of our

00:34:34.280 --> 00:34:35.079
compile code.

00:34:35.240 --> 00:34:37.960
And now if you click on this increment, right?

00:34:38.079 --> 00:34:39.556
It will just works, right?

00:34:39.639 --> 00:34:43.720
So this reactivity and all handles on the browser side.

00:34:44.119 --> 00:34:51.400
Yeah, so.

00:34:53.599 --> 00:34:57.197
I think we will last one left with one last bit,

00:34:57.280 --> 00:35:00.996
which is we need to go to the compiler and then make

00:35:01.079 --> 00:35:02.880
all these changes required.

00:35:03.400 --> 00:35:07.036
I think I will really run like breeze through as fast

00:35:07.119 --> 00:35:07.679
as I can.

00:35:07.920 --> 00:35:10.597
Basically, we're going to analyze the scope of the

00:35:10.680 --> 00:35:13.677
script that we have to make sure that we modify the

00:35:13.760 --> 00:35:16.996
right variables to add the set or like get method,

00:35:17.240 --> 00:35:21.117
So basically, if you here the assignment expression is

00:35:21.200 --> 00:35:23.317
the one that is like A equals something, we're going

00:35:23.400 --> 00:35:24.800
to add the set method to it.

00:35:25.079 --> 00:35:28.717
And also in the identifier, we're going to add the

00:35:28.800 --> 00:35:30.077
gets method as well.

00:35:30.160 --> 00:35:34.040
So we're going to read the value out from the states.

00:35:34.560 --> 00:35:36.756
And basically, we're going to add this transform.js

00:35:36.839 --> 00:35:40.917
for both expressions as well as attributes as

00:35:41.000 --> 00:35:43.601
basically anywhere we are using referencing the

00:35:43.839 --> 00:35:44.639
JavaScript.

00:35:46.280 --> 00:35:50.319
And I think that's it.

00:35:51.079 --> 00:35:54.600
And so, basically now if we run our code.

00:35:55.200 --> 00:36:00.599
One, I think some typo just now.

00:36:02.720 --> 00:36:03.040
Okay.

00:36:03.720 --> 00:36:08.036
So here, if we run our compiler again, this basically

00:36:08.119 --> 00:36:10.917
will generates the same code that you just saw I make

00:36:11.000 --> 00:36:11.996
some changes to, right?

00:36:12.079 --> 00:36:14.877
It's exactly the same, but we just make that into

00:36:14.960 --> 00:36:16.717
the compiler, right?

00:36:16.800 --> 00:36:21.280
So one last demo I want to show is that in our

00:36:21.440 --> 00:36:24.637
component, right, over here, this was what not

00:36:24.720 --> 00:36:27.996
possible previously in Svelte 4 and below, which is

00:36:28.079 --> 00:36:31.117
to create a function, right?

00:36:31.200 --> 00:36:34.276
And move all this code inside this like function,

00:36:34.359 --> 00:36:34.516
right?

00:36:34.599 --> 00:36:44.200
And to do something like universal reactivity.

00:36:44.400 --> 00:36:44.637
Right?

00:36:44.720 --> 00:36:56.080
And we're going to update this quickly.

00:36:56.520 --> 00:37:04.837
So we move all our state reactivity into a function.

00:37:04.920 --> 00:37:07.677
I'm going to use that to update to call decrement,

00:37:07.760 --> 00:37:09.477
increment, and getting the value, right?

00:37:09.560 --> 00:37:12.557
So this we're going to compile it, and we are going

00:37:12.640 --> 00:37:13.837
to run this, right?

00:37:13.920 --> 00:37:18.040
So the compile code, once again, this basically is

00:37:18.680 --> 00:37:22.240
moving all this reactivity inside a function, and

00:37:22.440 --> 00:37:26.680
it will still works as we expect, right?

00:37:30.000 --> 00:37:36.317
So that's about the compiler that we create, right?

00:37:36.400 --> 00:37:39.036
So a quick summary, right, what we have gone through

00:37:39.119 --> 00:37:39.840
in this talk.

00:37:40.240 --> 00:37:42.880
First one is that we learn about how to write a

00:37:43.000 --> 00:37:46.276
compiler, which basically have the parts, but we

00:37:46.359 --> 00:37:48.477
didn't go through the details of every step of

00:37:48.560 --> 00:37:49.477
implementation.

00:37:49.560 --> 00:37:51.477
And then we do some analysis, and then we generate

00:37:51.560 --> 00:37:53.197
into a JavaScript code, right?

00:37:53.280 --> 00:37:56.357
And then we also learn about signals and fine-grained

00:37:56.440 --> 00:37:57.240
reactivity.

00:37:57.520 --> 00:37:59.357
I think one thing to remind you is that if you take

00:37:59.440 --> 00:38:02.276
a look at the compile code, you realize that the app

00:38:02.359 --> 00:38:04.957
function we just execute once to create the entire

00:38:05.040 --> 00:38:06.557
elements, and that's it, right?

00:38:06.640 --> 00:38:09.717
And when we create elements, we actually go to set up

00:38:09.800 --> 00:38:12.317
the necessary subscriptions to register like the

00:38:12.400 --> 00:38:13.516
reactivity, right?

00:38:13.599 --> 00:38:16.197
And those subscriptions are made on the element level

00:38:16.280 --> 00:38:18.797
or the attribute level or like the text content

00:38:18.880 --> 00:38:19.516
level, right?

00:38:19.599 --> 00:38:20.877
So that's why it's fine-grained.

00:38:20.960 --> 00:38:23.837
Only those statements being rerun whenever the

00:38:23.920 --> 00:38:26.400
variables or the signals has changed.

00:38:26.760 --> 00:38:29.276
And last but not the least, there's actually a lot

00:38:29.359 --> 00:38:31.317
of things that I did not manage to cover in this

00:38:31.400 --> 00:38:35.236
talk, like all this and above, like many rules and

00:38:35.319 --> 00:38:37.317
other optimization techniques, right?

00:38:37.400 --> 00:38:39.040
So that's it for my talk.

00:38:40.200 --> 00:38:42.597
Thank you so much for listening through my talk,

00:38:42.680 --> 00:38:44.437
and thank you very much for having me here.

00:38:44.520 --> 00:38:45.040
Thank you.
