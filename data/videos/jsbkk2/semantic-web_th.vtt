WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:04.279 --> 00:00:08.039
สวัสดีครับ

00:00:08.719 --> 00:00:13.197
ผมมาเป็นตัวแทนของ MongoDB User Group นะครับ

00:00:13.280 --> 00:00:16.397
เราจะมี QR code นะครับขอโฆษณานิดหน่อย

00:00:16.480 --> 00:00:19.797
ก็คือว่าเรามี MongoDB User Group ใน Thailand นะครับ

00:00:19.880 --> 00:00:25.116
สำหรับคนที่สนใจหรือว่าใช้งานของตัว MongoDB นะครับ

00:00:25.199 --> 00:00:27.356
เผื่อต้องการที่อยากจะสอบถามปัญหานะครับ

00:00:27.439 --> 00:00:28.999
เราเป็น community นะครับ

00:00:29.439 --> 00:00:31.399
อันนี้เป็น non-commercial นะครับ

00:00:32.079 --> 00:00:38.437
โอเคนะครับ วันนี้ผมจะมาพูดถึงตัวการใช้งานของ

00:00:38.520 --> 00:00:39.757
web search นะครับ

00:00:39.840 --> 00:00:42.117
ผมเข้าใจว่าทุกท่านน่าจะรู้จัก web search

00:00:42.200 --> 00:00:42.996
อยู่แล้วนะครับ

00:00:43.079 --> 00:00:48.437
ก่อนอื่นเลยนะครับอยากสอบถามว่ามีใครที่ไม่เคยใช้

00:00:48.520 --> 00:00:50.880
MongoDB เลย

00:00:51.640 --> 00:00:54.840
อ้อ 2 ท่าน 3 ท่านนะครับ

00:00:56.000 --> 00:00:58.920
โอเคครับไม่เป็นไรครับ

00:00:59.519 --> 00:01:02.476
แสดงว่าคนส่วนใหญ่รู้จัก MongoDB มาก่อนถูกมั้ยครับ

00:01:02.559 --> 00:01:04.920
มีการลองเล่นมาเล็กๆ น้อยๆ เนาะนะครับ

00:01:05.280 --> 00:01:08.000
งั้นในวันนี้ผมก็จะไม่ได้พูดถึง MongoDB

00:01:08.479 --> 00:01:10.957
ที่เป็นส่วนของ core database นะครับ

00:01:11.040 --> 00:01:14.197
แค่กล่าวว่า MongoDB ที่ทุกท่านใช้งานอยู่ปัจจุบัน

00:01:14.280 --> 00:01:14.637
เนี่ยนะครับ

00:01:14.720 --> 00:01:16.877
สิ่งนึงที่เป็นจุดหลัก

00:01:16.960 --> 00:01:21.279
ถ้าเวลาเราพูดถึง MongoDB สิ่งที่เป็น killer feature

00:01:21.680 --> 00:01:23.119
เลยนะครับ

00:01:23.320 --> 00:01:26.639
มีใครสามารถตอบได้มั้ยว่า MongoDB killer feature

00:01:27.000 --> 00:01:29.840
เลยทำไมคนถึงนิยมใช้ MongoDB มากเพราะอะไร

00:01:32.240 --> 00:01:34.517
อาจจะไม่มีของแถมนะครับ ณ ตอนนี้

00:01:34.600 --> 00:01:36.959
แต่แค่อยากทราบว่ามีความคิดเห็นว่ายังไง

00:01:37.119 --> 00:01:40.356
เพราะว่าในห้องส่งนี้ทุกคนบอกว่าใช้ MongoDB

00:01:40.439 --> 00:01:40.880
หมดเลย

00:01:41.280 --> 00:01:44.160
ส่วนใหญ่นั่นก็หมายความว่าทุกคนต้องรู้ว่าทำไม

00:01:44.399 --> 00:01:45.400
เราถึงใช้ MongoDB

00:01:45.880 --> 00:01:47.799
อาจจะบอกบริษัทบังคับเหรอ

00:01:48.159 --> 00:01:50.437
หรือว่าเพราะว่ามันทำอะไรได้บ้างนะครับ

00:01:50.520 --> 00:01:52.240
อันนี้เลยอยากสอบถามนะครับว่า

00:01:52.920 --> 00:01:57.157
มีใครพอจะอาสาตอบได้มั้ยครับว่าทำไมคุณถึงเลือกใช้

00:01:57.240 --> 00:01:59.316
MongoDB

00:02:02.680 --> 00:02:04.240
ขอบคุณมากครับ

00:02:06.159 --> 00:02:08.439
ในความส่วนตัวคือว่าผมเองนะครับ

00:02:09.000 --> 00:02:12.680
เรามีเวลาเยอะนะ ผมก็เลยจะพูดนิดนึงนะครับว่า

00:02:12.920 --> 00:02:15.317
ปกติแล้วผมมาทำ SQL Server มาก่อน

00:02:15.400 --> 00:02:18.120
ผมเป็นสาย relational database มาก่อนประมาณ

00:02:18.560 --> 00:02:19.440
15 ปีเป็นอย่างน้อย

00:02:19.760 --> 00:02:21.677
เพราะฉะนั้นผมมาทำ MongoDB เนี่ย

00:02:21.760 --> 00:02:26.600
สิ่งนึงที่ MongoDB killer แน่นอนก็คือ flexible schema

00:02:27.120 --> 00:02:28.360
จุดชูโรงเลยนะ

00:02:28.760 --> 00:02:32.117
มากกว่าแค่ easy to development โอเคมั้ยครับ

00:02:32.200 --> 00:02:35.077
เพราะงั้นผมรู้แล้วว่ามัน easy นะเพราะมันเป็น flexible

00:02:35.160 --> 00:02:38.320
แปลว่าคุณอยากจะ insert อะไรก็ได้ทั้งนั้นแหละ

00:02:39.000 --> 00:02:42.239
ขอให้ใช้ driver แล้วกันขอให้มันลง MongoDB แล้วกัน

00:02:42.440 --> 00:02:43.957
มันก็จะมาเลย schema มาเลย

00:02:44.040 --> 00:02:45.757
เพราะฉะนั้นมันคือ flexible schema

00:02:45.840 --> 00:02:50.516
อันนี้เป็นการบอกว่า ถ้าเราไปเปรียบเทียบกับยี่ห้ออื่น

00:02:50.599 --> 00:02:55.400
อะไรล่ะที่ MongoDB รู้สึกว่าดีก็คือ flexible schema

00:02:55.800 --> 00:02:56.199
นะครับ

00:02:57.360 --> 00:03:01.597
อันนี้คือสิ่งที่เหมือนขายของนะแต่เป็นการอธิบายว่า

00:03:01.680 --> 00:03:04.040
มันแตกต่างอย่างไรนะครับ

00:03:05.760 --> 00:03:08.716
ณ ปัจจุบันครับ MongoDB เนี่ยนะครับ

00:03:08.799 --> 00:03:10.236
ไม่ใช่เป็นแค่ database อย่างเดียว

00:03:10.319 --> 00:03:15.197
MongoDB เนี่ยมี SaaS เราเรียกว่าเหมือนเป็น SaaS

00:03:15.280 --> 00:03:16.156
หรือเป็น PaaS นะครับ

00:03:16.239 --> 00:03:18.001
ของตัวเองชื่อว่า MongoDB Atlas

00:03:18.519 --> 00:03:25.960
คือใช้งานได้ฟรี limited storage นะครับบน cloud

00:03:26.400 --> 00:03:26.637
3 เจ้า

00:03:26.720 --> 00:03:28.800
ที่ทุกท่านสามารถจะเลือกใช้ได้คือฟรีนะ

00:03:29.040 --> 00:03:30.957
นอกจากเราจะ develop ใช้งานแล้วทุกคน

00:03:31.040 --> 00:03:33.277
ผมเชื่อว่าทุกคนใช้ community edition อยู่แล้ว

00:03:33.360 --> 00:03:36.039
เพราะงั้นทุกคนก็สามารถที่จะเล่นฟรี

00:03:36.319 --> 00:03:40.796
เอาสิ่งที่ตัวเอง develop ไปขายได้ ทำได้ทุกอย่างนะครับ

00:03:40.879 --> 00:03:43.679
แต่ในวันนี้ที่เราจะพูดถึงเนี่ยเป็น feature นึงที่

00:03:44.439 --> 00:03:50.557
มันก็อาจจะมีบน community edition ใน soon นะครับ

00:03:50.640 --> 00:03:53.436
แต่ ณ ปัจจุบันตอนนี้ที่เราจะมีการ demo กันเนี่ย

00:03:53.519 --> 00:03:53.920
ก็คือ

00:03:54.319 --> 00:03:57.837
เป็นการใช้ feature นึงที่ปัจจุบันเรานิยมกันพูดถึงกันมาก

00:03:57.920 --> 00:04:01.160
ก็คือการใส่ feature ที่เรียกว่า AI

00:04:01.840 --> 00:04:04.037
หรือบางทีเราจะเรียกคำว่า application ที่เป็น

00:04:04.120 --> 00:04:06.597
GenAI application นะครับ

00:04:06.680 --> 00:04:09.957
ซึ่งเดี๋ยวเรามาดูว่ามันสามารถทำงานได้เข้ากับตัว

00:04:10.040 --> 00:04:10.840
MongoDB

00:04:11.400 --> 00:04:13.197
แล้วก็เป็น web frontend ได้ยังไง

00:04:13.280 --> 00:04:15.837
โดยที่เราจะ simulate ในการ develop ทุกอย่าง

00:04:15.920 --> 00:04:17.520
บนเครื่องคอมพิวเตอร์ของเรา

00:04:17.639 --> 00:04:18.760
โอเคมั้ยครับ

00:04:18.919 --> 00:04:22.676
เราแทบจะบอกว่าเราปิดเน็ตเราก็สามารถจะ develop

00:04:22.759 --> 00:04:23.640
งานได้ครบวงจร

00:04:24.440 --> 00:04:27.277
ของการทำตัวแอป GenAI นะครับ

00:04:27.360 --> 00:04:30.396
ซึ่งผมก็จะแน่นอนครับเป็นงาน JavaScript เนาะ

00:04:30.479 --> 00:04:33.037
เพราะฉะนั้นเราก็จะเน้นไปที่ตัว JavaScript framework

00:04:33.120 --> 00:04:33.757
ทั้งหมดนะครับ

00:04:33.840 --> 00:04:40.438
ผมจะใช้ตัว Vue.js นะครับแล้วก็ตัวที่เป็น Node.js

00:04:41.400 --> 00:04:42.680
นะครับ

00:04:43.360 --> 00:04:46.760
สิ่งที่เราจะพูดกันก็คือผมจะพูดถึงการกล่าว

00:04:47.360 --> 00:04:50.157
สิ่งที่มันเกิดขึ้น ณ ปัจจุบันก็คือ semantic web คืออะไร

00:04:50.240 --> 00:04:52.556
ผมคิดว่าหลายๆ ท่านอาจจะพอรู้อยู่แล้วเนาะ

00:04:52.639 --> 00:04:54.717
ผมก็จะแบบค่อยๆ ข้ามไปนะอย่างช้าๆ

00:04:54.800 --> 00:04:56.400
แต่เรามีเวลาเยอะนะครับ

00:04:56.759 --> 00:05:00.157
ต่อไปก็คือเราพูดถึงว่าอะไรคือ Atlas Vector Search

00:05:00.240 --> 00:05:02.717
แล้วเราสามารถทำอะไรกับมันได้บนเครื่องคอมพิวเตอร์

00:05:02.800 --> 00:05:03.396
ของเรานะครับ

00:05:03.479 --> 00:05:05.437
แล้วก็มี demo ให้ดูนะครับ

00:05:05.520 --> 00:05:09.277
แล้วก็อาจจะมี code ที่ผมอัพโหลดไว้บน Git อยู่แล้ว

00:05:09.360 --> 00:05:09.517
นะครับ

00:05:09.600 --> 00:05:11.717
ซึ่งมันอาจจะยังไม่เรียบร้อยเนาะ

00:05:11.800 --> 00:05:14.439
แต่สามารถที่จะเอาตัวอย่าง code ไปลองเล่นเองได้

00:05:14.600 --> 00:05:14.836
นะครับ

00:05:14.919 --> 00:05:16.760
เป็นแบบ offline ได้ด้วยนะครับ

00:05:18.440 --> 00:05:21.797
ถ้าพูดถึงตัว semantic web นะครับ

00:05:21.880 --> 00:05:25.717
อันนี้ผมก็นะครับนิยามทุกคนทราบอยู่แล้วนะว่า

00:05:25.800 --> 00:05:26.597
semantic web

00:05:26.680 --> 00:05:29.520
ก็คือการสร้างระบบ web search บางอย่าง

00:05:29.919 --> 00:05:31.743
ผมเน้น focus ที่ search แล้วกันเนาะ

00:05:31.827 --> 00:05:34.960
search บางอย่างที่มันสามารถที่จะฉลาดพอที่รู้เรา

00:05:35.080 --> 00:05:38.920
ที่รู้สิ่งที่เราพิมพ์ไปเนี่ยหมายถึงอะไรที่ไม่ใช่

00:05:39.520 --> 00:05:40.840
matching exactly

00:05:41.120 --> 00:05:43.080
ก็คือหมายความว่า คุณ search คำว่า car

00:05:43.440 --> 00:05:45.757
มันไม่ได้สนใจเป็นคำว่า car เป๊ะๆ

00:05:45.840 --> 00:05:49.959
มันอาจจะเป็นบริบทที่มันรู้เองจากที่คุณรู้เรื่องนะครับ

00:05:50.080 --> 00:05:52.077
เราเรียกว่าเป็น semantic web หรือ web

00:05:52.160 --> 00:05:53.520
ที่เน้นความหมายของมัน

00:05:54.120 --> 00:05:57.197
นะครับซึ่งมันอาจจะเป็นเรื่องที่เก่ามาหลายปีแล้ว

00:05:57.280 --> 00:06:00.320
แต่ผมคิดว่าปัจจุบันมันเป็นการ implement จริงมากขึ้น

00:06:00.440 --> 00:06:00.556
นะครับ

00:06:00.639 --> 00:06:03.000
เพราะงั้นมันก็จะพูดถึงแบบ smart search เนาะ

00:06:03.120 --> 00:06:06.396
มันก็จะมีเรื่อง core feature หลักของตัว semantic web

00:06:06.479 --> 00:06:08.317
ที่เรารู้จักกันเนี่ยก็คือหมายความว่า

00:06:08.400 --> 00:06:10.676
มัน search มันรู้จัก by context

00:06:10.759 --> 00:06:14.637
เช่นตัวอย่างข้างบนก็คือ คำว่า jaguar เนาะ

00:06:14.720 --> 00:06:19.800
jaguar มันสามารถที่จะรู้บริบทของเรานะครับได้ว่า

00:06:20.000 --> 00:06:21.637
โอเค smart search มันคืออะไร

00:06:21.720 --> 00:06:24.160
คือรู้ว่าเราพูดถึง jaguar ที่เป็นอะไร

00:06:24.840 --> 00:06:26.917
มันอาจจะมีการเก็บสิ่งต่างๆ รอบตัวเรา

00:06:27.000 --> 00:06:29.116
ที่เราเข้าไปในเว็บไซต์หรือระบบ search engine

00:06:29.199 --> 00:06:29.760
ที่สามารถ

00:06:29.880 --> 00:06:32.157
เก็บข้อมูลทุกอย่างที่เรารู้ได้นะครับ

00:06:32.240 --> 00:06:35.040
เพราะงั้นมันก็จะรู้เรื่องของแบบ smart search เนาะ

00:06:35.160 --> 00:06:40.836
รู้ว่าเราพูดถึง brand หรือเราพูดถึงปี

00:06:40.919 --> 00:06:42.000
สัตว์นะครับ

00:06:42.199 --> 00:06:45.477
นี่คือสิ่งที่เรียกว่าเป็น semantic search นะของ semantic web

00:06:45.560 --> 00:06:50.797
อย่างที่สองมันสามารถที่จะรู้ได้ว่าถ้าเราต้องการอยากจะพิมพ์ space

00:06:50.880 --> 00:06:54.040
มันรู้ว่า space เนี่ยหมายถึงอะไรอย่างเงี้ยครับเป็นต้น

00:06:54.240 --> 00:06:56.997
อันนี้คือความหมายของ semantic web

00:06:57.080 --> 00:06:59.800
คือมันสามารถที่จะ connect the dots ได้ในความหมาย

00:06:59.940 --> 00:07:01.956
แน่นอนครับมันไม่ใช่แค่เราพิมพ์ประโยคเดียวแล้วมันจะรู้นะ

00:07:02.039 --> 00:07:05.440
เราอาจจะพิมพ์แบบยาวๆ แล้วมันก็จะเรียนรู้ของเราว่าโอเค

00:07:05.759 --> 00:07:08.077
ตอนนี้คุณเข้ามาในหมวดเช่น

00:07:08.160 --> 00:07:10.959
เช่นสมมติเราพูดถึงเว็บ Amazon นะที่เป็นเว็บไซต์

00:07:11.120 --> 00:07:13.937
ที่เป็นเว็บขายหนังสือขายอะไรก็แล้วแต่ที่เราเข้าไป

00:07:14.020 --> 00:07:16.757
แล้วพิมพ์บางอย่างมันรู้ว่าเรากำลังเข้าหมวดเนี้ย

00:07:16.840 --> 00:07:19.956
ถ้าเราถามคำแบบเนี้ย มันน่าจะหมายถึงหมวดนี้

00:07:20.039 --> 00:07:22.956
ไม่ใช่แบบครอบจักรวาลแล้วมาตอบเราหลายแบบถูกไหมครับ

00:07:23.039 --> 00:07:26.877
เพราะฉะนั้นเราจะรู้สึกว่าทุกอย่างมันเป็นการเชื่อมโยงกัน

00:07:26.960 --> 00:07:29.239
แล้วออกแบบมาเป็นเว็บที่เรียกว่า semantic

00:07:29.680 --> 00:07:33.717
ก็คือเว็บที่ค้นหาข้อมูลแล้วเป็นรู้ความหมายของเรา

00:07:33.800 --> 00:07:35.560
รู้ context ที่เราต้องการ

00:07:35.759 --> 00:07:38.836
รู้ว่าคำที่เราค้นหาเนี่ยมันน่าจะเป็นอะไร

00:07:38.919 --> 00:07:42.717
แล้วพอเราคลิกเข้าไปในลิงก์ที่มันโชว์เนี่ย

00:07:42.800 --> 00:07:48.600
มันก็จะรู้ว่าอ๋อ คุณนั่นเองเนี่ยที่สนใจเรื่องราวของความหมายแบบนี้

00:07:49.159 --> 00:07:51.080
ทำให้มันเก็บข้อมูลเข้าไปอีก

00:07:51.400 --> 00:07:54.480
ทำให้ระบบของเรามันก็คือการ learning ไปเรื่อยๆ

00:07:54.800 --> 00:07:59.480
มันนำไปสู่โลกปัจจุบันที่เราเรียกว่ามันเป็นการใช้เครื่องมือ

00:07:59.639 --> 00:08:02.199
ที่เป็น AI มากขึ้นหรือเป็น generative AI มากขึ้น

00:08:02.360 --> 00:08:04.919
เพราะว่ามันได้สะสมข้อมูลมาเพียงพอแล้ว

00:08:05.440 --> 00:08:08.120
ถึงจุดที่มันสามารถจะรู้จักเราได้มากขึ้น

00:08:08.599 --> 00:08:10.197
ถูกไหมครับมันรู้จักเรามากขึ้น

00:08:10.280 --> 00:08:15.079
นั่นคือสิ่งที่ตัวแอปพลิเคชันที่เราถูกพัฒนาในปีเนี้ยมากขึ้น

00:08:15.240 --> 00:08:18.157
หรือคนพูดถึงมากขึ้นนะครับ

00:08:18.240 --> 00:08:19.877
ซึ่งแน่นอนมันจะมีคนใช้งานอยู่แล้ว

00:08:19.960 --> 00:08:21.597
งั้นสำคัญก็คือเราต้องมีข้อมูล

00:08:21.680 --> 00:08:24.717
ดังนั้นพอเราพูดถึงข้อมูลเราต้องมี data ที่เก็บนะ

00:08:24.800 --> 00:08:29.400
ในที่นี้ผมก็เลยจะมาพูดว่าตัว MongoDB

00:08:30.520 --> 00:08:33.316
เราสามารถเก็บอะไรได้บ้างและทำอะไรได้บ้างนะครับ

00:08:33.399 --> 00:08:36.960
ในมุมมองของ semantic web search นะครับ

00:08:37.640 --> 00:08:42.956
โอเคนะครับ

00:08:43.039 --> 00:08:46.519
ต่อมาก็คือบน MongoDB เนี่ยครับจะมี feature นึง

00:08:46.680 --> 00:08:49.077
นะครับเรียกว่า vector search

00:08:49.160 --> 00:08:52.237
ก่อน vector search เนี่ยนะครับมันจะมีการ search ข้อมูลนะ

00:08:52.320 --> 00:08:54.597
ทุกคนรู้จักวิธีการ query ข้อมูลถูกไหมครับ

00:08:54.680 --> 00:08:58.480
ก็คือ select ข้อมูลเข้ามาค้นหาข้อมูลตาม condition ต่างๆ

00:08:58.800 --> 00:09:01.040
เรียกว่าเป็นการ search ทั่วๆ ไปนะครับ

00:09:01.160 --> 00:09:03.077
แต่พอเราอยาก search text มากขึ้นเนี่ย

00:09:03.160 --> 00:09:05.760
มันจะมีอีกตัวนึงที่เราเรียกว่า full-text search

00:09:06.000 --> 00:09:07.721
full-text search ก็คือเป็นการ search

00:09:07.959 --> 00:09:10.560
แบบค้นหาคำๆ นี้อยู่ในข้อมูลมหาศาลอย่างไร

00:09:10.959 --> 00:09:16.077
เรียกว่าเป็นการค้นหาไม่ใช่เป็นคำเฉพาะตรงเป๊ะๆ

00:09:16.160 --> 00:09:20.397
แต่อาจจะเป็นแบบมีคำนี้อยู่ในข้อความนั้นหรือเปล่านะครับ

00:09:20.480 --> 00:09:22.477
อันนี้เราจะเรียกว่าเป็นตัว full-text search

00:09:22.560 --> 00:09:26.477
จนมาถึงยุคที่เป็น generative AI นะครับ

00:09:26.560 --> 00:09:29.320
เราเลยเรียกกระบวนการนั้นมากขึ้น

00:09:29.600 --> 00:09:31.557
ก็คือเรียกว่า vector search นะครับ

00:09:31.640 --> 00:09:33.237
ใน vector search เนี่ยนะครับ

00:09:33.320 --> 00:09:37.037
สิ่งที่ทุกคนเห็นก็คือข้อมูลมันจะมีการทำแบบนึง

00:09:37.120 --> 00:09:40.080
ที่เราเรียกว่าปัจจุบันมันจะมี 2 คำที่ทุกคนรู้จัก

00:09:40.320 --> 00:09:43.240
ที่เรียกว่าเป็น model ก็คือ embedding model

00:09:43.399 --> 00:09:45.880
กับ large language model

00:09:46.120 --> 00:09:50.440
มันจะมี 2 คำที่ ณ ปัจจุบันเนี่ยเรามีการพูดถึงกันมากเลย

00:09:50.560 --> 00:09:52.436
แต่ผมจะโฟกัสที่เรียกว่า embed นะครับ

00:09:52.519 --> 00:09:57.237
embed ก็คือมันอาจจะเป็นเรื่องที่ทุกคนแบบฟังมาแล้วเยอะเนาะ

00:09:57.320 --> 00:10:00.957
ผมแค่ปูให้เข้าใจจนไปถึงว่า MongoDB ทำอะไรได้บ้างนะครับ

00:10:01.040 --> 00:10:04.277
เพราะฉะนั้นง่ายๆ ก็คือเราแปลงในตัวอย่างนี้

00:10:04.360 --> 00:10:05.880
ก็คือเรามีรูปภาพครับ

00:10:06.000 --> 00:10:08.717
รูปภาพเราเป็น binary เนาะ ถูกไหมครับ

00:10:08.800 --> 00:10:10.319
ภาพ 1 ภาพมีชื่อภาพ

00:10:10.600 --> 00:10:14.399
เราก็แปลง content ของภาพที่เป็น binary ทั้งหมดเนี่ยนะครับ

00:10:14.640 --> 00:10:16.080
ให้มันกลายเป็นตัวเลข

00:10:16.760 --> 00:10:18.077
ตัวเลขมันเรียงกันเป็นกลุ่ม

00:10:18.160 --> 00:10:20.920
แล้วเรียกกลุ่มที่เรียงเป็นตัวเลขยาวๆ เนี่ยว่า vector

00:10:21.360 --> 00:10:23.316
ซึ่ง vector มีหลายรูปแบบครับ

00:10:23.399 --> 00:10:27.117
ปัจจุบันเนี่ยถูกพัฒนา algorithm ที่เป็น core พื้นฐานเนี่ย

00:10:27.200 --> 00:10:29.479
ลดทอนจากเลขทศนิยมแบบเนี้ย

00:10:29.760 --> 00:10:33.077
ให้เหลือแค่ 0 กับ 1 หรือค่าที่ต่ำกว่า

00:10:33.160 --> 00:10:36.436
เพราะเหตุผลเพราะว่ายิ่งมีค่าที่มากกว่าเท่าไหร่เนี่ย

00:10:36.519 --> 00:10:38.436
มันจะใช้ compute engine เยอะ

00:10:38.519 --> 00:10:43.520
แล้วปัจจุบันเนี่ยนะครับมันอยู่ในยุคที่เราจะเริ่มใช้ device compute

00:10:44.040 --> 00:10:45.677
แปลว่ามันก็ต้องมี size ที่เล็กลง

00:10:45.760 --> 00:10:47.037
มีตัวเลขที่คำนวณน้อยลง

00:10:47.120 --> 00:10:48.800
น้อยลงแต่แม่นยำต้องมากขึ้น

00:10:49.040 --> 00:10:51.797
เพราะว่าเราใช้ mobile เราคำนวณได้นะครับ

00:10:51.880 --> 00:10:53.797
หรือใช้แค่ browser คำนวณได้

00:10:53.880 --> 00:10:57.717
นั่นคือเหตุผลที่ algorithm เนี่ยก็คือมันถูกพัฒนานะครับ

00:10:57.800 --> 00:11:01.237
นั่นก็หมายความว่าเรากำลังพยายามแปลงสิ่งที่คนรู้เรื่อง

00:11:01.320 --> 00:11:02.237
ให้คอมรู้เรื่อง

00:11:02.320 --> 00:11:04.880
คอมรู้เรื่องก็คือตัวเลข

00:11:05.560 --> 00:11:07.597
เพราะมันชื่อคอมพิวเตอร์เนาะ

00:11:07.680 --> 00:11:09.436
เพราะฉะนั้นแปลว่ามันก็คือการคำนวณครับ

00:11:09.519 --> 00:11:11.037
บวกลบคูณหารอะไรก็ว่ากันไปนะ

00:11:11.120 --> 00:11:12.279
ผมไม่ได้ลงตรงนั้น

00:11:12.800 --> 00:11:16.436
เพราะฉะนั้น embedding model คือการแปลงอะไรก็ตาม

00:11:16.519 --> 00:11:19.200
ที่มนุษย์อ่านรู้เรื่องให้คอมอ่านรู้เรื่อง

00:11:19.320 --> 00:11:20.797
เพื่อมาทำสูตรคำนวณบางอย่าง

00:11:20.880 --> 00:11:23.078
ซึ่งมีนักวิจัยทำไว้หมดแล้วมากมาย

00:11:23.480 --> 00:11:28.000
ดังนั้นเรามีหน้าที่แค่จะทำยังไงก็ตามให้มันแปลงเป็นเลขให้ได้

00:11:28.680 --> 00:11:32.397
เราจึงไปเลือกหาตัวที่เรียกว่า embedding model

00:11:32.480 --> 00:11:35.597
หลากหลายมากปัจจุบันมี มีแบบโอ้ มาก

00:11:35.680 --> 00:11:36.876
มหาศาลนะครับ

00:11:36.959 --> 00:11:37.597
มีหลายค่าย

00:11:37.680 --> 00:11:38.717
ออกมาทุกอาทิตย์

00:11:38.800 --> 00:11:39.840
ออกมาทุกเดือน

00:11:40.240 --> 00:11:41.436
เล็กเข้าไปเล็กเข้าไป

00:11:41.519 --> 00:11:42.480
ดีขึ้นดีขึ้น

00:11:42.639 --> 00:11:45.480
แต่ถ้าเราไม่รู้ว่าเราไปทำอะไรมันก็ไม่มีประโยชน์ถูกไหมครับ

00:11:45.600 --> 00:11:45.837
โอเค

00:11:45.920 --> 00:11:48.996
เพราะฉะนั้นเดี๋ยวเรามาดูกันว่ามันจะมีประโยชน์อย่างไรนะครับ

00:11:49.079 --> 00:11:51.277
เพราะฉะนั้นตัว embedding model เนี่ยก็คือ

00:11:51.360 --> 00:11:54.316
เราเก็บ MongoDB เนี่ยมีตัวนึงก็คือ

00:11:54.399 --> 00:11:57.360
มันสามารถจะเก็บ data type ที่เป็นตัวเลขได้

00:11:58.079 --> 00:12:02.756
ภาพที่เห็นเนี่ยมันก็คือ data type ที่เป็น square bracket

00:12:02.839 --> 00:12:05.837
มองออกอยู่แล้วว่ามันคือ array นะครับ

00:12:05.920 --> 00:12:08.517
มันเก็บ array ที่เป็นตัวเลขไม่มีอะไรแปลกเลยนะครับ

00:12:08.600 --> 00:12:10.117
มันเก็บ array ตัวเลขเท่านั้นเอง

00:12:10.200 --> 00:12:12.238
MongoDB ทำหน้าที่เก็บ array ตัวเลข

00:12:12.680 --> 00:12:13.996
แต่สิ่งที่มันมากกว่านั้นก็คือ

00:12:14.079 --> 00:12:17.680
มันจะมี feature นึงใน MongoDB ชื่อว่า vector search

00:12:18.040 --> 00:12:20.959
คือเราไม่ต้องมีความรู้ในระดับ

00:12:22.519 --> 00:12:26.717
บางอย่างเรา apply ถนัดกว่าเราต้องการเป็นผู้สร้างในบางอย่างนะ

00:12:26.800 --> 00:12:30.196
ผมไม่ได้บอกว่าเราจำเป็นจะต้องเป็นผู้ apply อย่างเดียว

00:12:30.279 --> 00:12:30.918
หรือเป็นผู้สร้างก็ได้

00:12:31.160 --> 00:12:33.759
แต่ในเชิงประยุกต์ใช้งาน MongoDB บอกว่า

00:12:33.920 --> 00:12:35.357
เราสามารถประยุกต์ใช้งานได้

00:12:35.440 --> 00:12:39.839
มันมีลูกเล่นให้เราทำในระดับที่เราไม่ต้องใช้เวลา

00:12:40.040 --> 00:12:42.277
เป็นหลายๆ ปีเพื่อเข้าใจมันมากขึ้น

00:12:42.360 --> 00:12:49.839
แต่เราสามารถทำผลิตภัณฑ์ออกสู่ market ได้เร็วขึ้นได้นะครับ

00:12:50.120 --> 00:12:52.556
ดังนั้นตัวนี้เราจะเรียกว่า vector search

00:12:52.639 --> 00:12:57.240
vector search เป็น feature ที่อยู่บน MongoDB Atlas นะครับ

00:12:57.399 --> 00:12:59.436
ก็คือเราสามารถใช้งาน free เหมือนกัน

00:12:59.519 --> 00:13:00.917
ทุกอย่าง free หมดนะครับ

00:13:01.000 --> 00:13:02.717
แต่แค่ limit นะครับ

00:13:02.800 --> 00:13:03.756
limit ก็หมายความว่า

00:13:03.839 --> 00:13:07.756
เช่น Atlas เนี่ยมี free tier ที่ทุกคนสามารถใช้งาน free ได้

00:13:07.839 --> 00:13:09.680
ไม่ต้องกรอกบัตรเครดิตใดๆ เลย

00:13:09.959 --> 00:13:11.237
สมัครเข้าไปใช้งานได้เลย

00:13:11.320 --> 00:13:15.157
free tier 512 MB นะครับ

00:13:15.240 --> 00:13:16.436
free 512 MB

00:13:16.519 --> 00:13:18.436
ถ้าใช้เกินกว่านั้นก็แค่ใช้ไม่ได้นะ

00:13:18.519 --> 00:13:20.320
หรือคุณก็ค่อยไปเลือก tier อื่นนะ

00:13:20.440 --> 00:13:22.397
แต่มันเป็น tier ที่เป็น free นะครับ

00:13:22.480 --> 00:13:24.599
เพราะฉะนั้นเรากำลัง embed นะครับ

00:13:25.279 --> 00:13:27.278
ฝั่งซ้ายก็คือมันเก็บข้อมูล

00:13:27.399 --> 00:13:29.240
ฝั่งขวาก็คือเวลาเรา search ครับ

00:13:29.440 --> 00:13:32.797
หน้าตาอันนี้แน่นอนหลายๆ คนที่ใช้ MongoDB อยู่แล้ว

00:13:32.880 --> 00:13:36.240
มักจะคุ้นมันคือ Mongo Query Language

00:13:36.399 --> 00:13:39.876
ปกติเรารู้จัก SQL ก็คือ Structured Query Language

00:13:39.959 --> 00:13:40.397
ถูกไหมครับ

00:13:40.480 --> 00:13:43.116
เป็นคำที่แบบ select star from where order by

00:13:43.199 --> 00:13:46.397
grouping group by having นะครับ

00:13:46.480 --> 00:13:50.436
อันนี้ก็จะเหมือนกันมันก็จะใช้คำว่า aggregate เนี่ยนะครับ

00:13:50.519 --> 00:13:53.917
ประโยคนี้เป็นประโยคที่ถ้าเราใช้งาน MongoDB อยู่แล้วรู้จัก

00:13:54.000 --> 00:13:56.517
มันคือเรียกว่า aggregation framework

00:13:56.600 --> 00:13:59.517
ก็คือเขียน query แบบเป็น stage นะครับ

00:13:59.600 --> 00:14:01.357
เพราะฉะนั้นมันก็ใช้คำว่า search ครับ

00:14:01.440 --> 00:14:07.480
แต่ search ของ MongoDB ถ้าเป็น search แบบแนว AI

00:14:07.959 --> 00:14:09.756
หรือเรียกว่าเป็น similarity นะ

00:14:09.839 --> 00:14:13.556
ตรงนี้ผมจะเขียนว่าเป็นการทำ similarity search นะครับ

00:14:13.639 --> 00:14:17.837
ก็คือหาข้อมูลที่มีความหมายคล้ายกันด้วยเอาตัวเลขไป match กัน

00:14:17.920 --> 00:14:18.316
นะครับ

00:14:18.399 --> 00:14:20.637
เราจะเรียกว่า vector search นะครับ

00:14:20.720 --> 00:14:22.196
เพราะฉะนั้นนี่คือความหมายนะ

00:14:22.279 --> 00:14:25.000
vector search เราจะใช้ feature นี้นะครับ

00:14:25.440 --> 00:14:28.196
อันนี้คือรูปแบบก็คือ data เก็บเป็นตัวเลขให้ได้

00:14:28.279 --> 00:14:30.157
ไปใช้เครื่องมือ open source ตัวไหนก็ได้

00:14:30.240 --> 00:14:32.637
ในที่นี้เราจะใช้ Ollama ให้ดูนะครับ

00:14:32.720 --> 00:14:38.237
ว่าเป็นตัว local language model ที่เป็นแบบ small นะครับ

00:14:38.320 --> 00:14:40.319
เพื่อจะ embed ข้อมูลชุดนี้

00:14:40.720 --> 00:14:44.640
แล้วก็เอา vector search ไป search ค้นหาข้อมูลนะครับ

00:14:45.120 --> 00:14:47.319
นั่นคือเหตุผลที่ฝั่งซ้ายคือ data

00:14:47.440 --> 00:14:49.479
ฝั่งขวาก็คือ search feature

00:14:49.639 --> 00:14:50.996
ซึ่ง Atlas มีให้อยู่แล้ว

00:14:51.079 --> 00:14:52.116
เราไม่ต้องคิดค้นอะไรใหม่

00:14:52.199 --> 00:14:54.556
ก็เหมือนเราใช้ database ยี่ห้อนึง

00:14:54.639 --> 00:14:57.876
แล้วกดคำสั่งว่าโอเคต้องการ search แบบ similarity search

00:14:57.959 --> 00:14:58.479
ให้หน่อย

00:14:59.160 --> 00:15:02.839
ก็มันก็จะ search ให้อัตโนมัติตาม feature ที่เราสร้างนะครับ

00:15:03.519 --> 00:15:04.800
โอเคนะครับ

00:15:07.000 --> 00:15:07.719
ต่อไปนะครับ

00:15:08.079 --> 00:15:10.837
เมื่อกี้เป็นให้ดูว่า vector search มันทำงานยังไงเนาะ

00:15:10.920 --> 00:15:12.116
มันจะเก็บตัวเลขเฉยๆ

00:15:12.199 --> 00:15:13.120
แล้วก็มี feature

00:15:13.320 --> 00:15:15.876
ต่อไปเรามาพูดถึงวิธีการให้คะแนนครับ

00:15:15.959 --> 00:15:18.717
เพราะว่าการ search similarity หรือโลกปัจจุบันก็คือ

00:15:18.800 --> 00:15:19.637
เรา search similarity

00:15:19.720 --> 00:15:21.077
หมายความว่าเรา search เหมือนนะ

00:15:21.160 --> 00:15:22.079
เราไม่ได้ search เป๊ะ

00:15:22.279 --> 00:15:27.640
พอไม่มีคำว่าเป๊ะแปลว่าไม่มีตัวเลขแน่ชัดว่า 100% เป็นยังไง

00:15:27.880 --> 00:15:28.957
โอเคไหมครับ

00:15:29.040 --> 00:15:29.880
ไม่มีตัวเลขแน่ชัด

00:15:30.079 --> 00:15:33.720
เราเป็นผู้กำหนดว่าอะไรที่แปลว่า 100% สำหรับมุมมองของเรา

00:15:34.360 --> 00:15:34.839
นะครับ

00:15:35.079 --> 00:15:37.357
ดังนั้นมันก็จะมีคำว่า search score แทน

00:15:37.440 --> 00:15:38.436
มันจะให้ score ของคุณ

00:15:38.519 --> 00:15:42.239
แล้วคุณก็เชื่อเองว่าคุณเป็นผู้ตัดสินว่า score เนี่ย

00:15:42.720 --> 00:15:44.999
ในบริบทของ application ของคุณ

00:15:45.279 --> 00:15:46.400
คุณเชื่อถือหรือไม่

00:15:46.639 --> 00:15:47.637
โอเคไหมครับ

00:15:47.720 --> 00:15:48.720
มันไม่มีความเป๊ะนะ

00:15:49.040 --> 00:15:53.717
เพราะฉะนั้นตัว score เนี่ยใน vector search ของ MongoDB Atlas

00:15:53.800 --> 00:15:56.959
เนี่ยมันก็จะมีอยู่ 3 ประเภทเป็น by default เลย

00:15:57.480 --> 00:16:00.876
ผมเชื่อว่าอันนี้เป็น standard ของ application

00:16:00.959 --> 00:16:02.519
ประเภทนี้ของทุกเจ้า

00:16:03.160 --> 00:16:05.637
เบื้องหลังมันก็จะมี cosine similarity

00:16:05.720 --> 00:16:08.556
สูตรก็ว่ากันไปมี dot product มี Euclidean distance

00:16:08.639 --> 00:16:09.397
ซึ่งแน่นอนครับ

00:16:09.480 --> 00:16:17.040
พื้นฐานของ similarity วิธีที่ง่ายที่สุดก็คือมันชื่อว่า KNN เนาะ

00:16:17.720 --> 00:16:19.717
ตัว nearest neighbor นะครับ

00:16:19.800 --> 00:16:22.999
เพราะฉะนั้นมันก็จะใช้หลักการว่าอะไรคล้ายกัน

00:16:23.680 --> 00:16:25.277
เอามา search ด้วยกันหน่อย

00:16:25.360 --> 00:16:27.837
แล้วคุณก็เลือกเอานะว่าคุณจะเลือกประเภทนี้หรือเปล่า

00:16:27.920 --> 00:16:30.556
ด้วย score ที่คุณยอมรับได้ไหมนะครับ

00:16:30.639 --> 00:16:33.477
อันนี้คือ search score ใน MongoDB Atlas

00:16:33.560 --> 00:16:35.720
จะมี search score pattern ให้คุณเลือก algorithm

00:16:36.000 --> 00:16:38.157
ผมก็จะเขียนไว้ว่า use case แต่ละอันครับ

00:16:38.240 --> 00:16:42.599
ควรเลือกประเภทไหนสำหรับบริบทของการใช้ MongoDB Atlas

00:16:43.319 --> 00:16:44.436
อันนี้ผมไม่ได้ไปที่อื่นนะ

00:16:44.519 --> 00:16:46.277
ผมพูดถึง Atlas 100% นะครับ

00:16:46.360 --> 00:16:50.440
เพราะฉะนั้น cos ถ้าเราใช้ feature ว่า cosine score

00:16:50.680 --> 00:16:53.037
จะเหมาะสำหรับ text search หรือ recommendation

00:16:53.120 --> 00:16:54.717
ถ้าคุณใช้ dot product นะครับ

00:16:54.800 --> 00:16:57.996
เหมาะสำหรับการทำ collaborative filter นะครับ

00:16:58.079 --> 00:16:59.917
ถ้าคุณใช้แบบ Euclidean distance

00:17:00.000 --> 00:17:04.197
ก็คุณเหมาะสำหรับพวกที่เป็น clustering หรือตัว detect นะครับ

00:17:04.280 --> 00:17:05.836
แล้วแต่คุณเลือกนะครับ

00:17:05.919 --> 00:17:07.999
คุณสามารถกำหนดได้นะครับ

00:17:08.280 --> 00:17:09.920
อันนี้คือ score

00:17:10.400 --> 00:17:13.119
เพราะเราจะเป็นคนกำหนดว่า score ไหนเราพอใจ

00:17:13.559 --> 00:17:18.080
แล้วแต่ละ score เหมาะสำหรับ application ประเภทไหนนะครับ

00:17:19.160 --> 00:17:20.956
โอเค ต่อไปนะครับ

00:17:21.039 --> 00:17:26.679
พอเรามาพูดถึงการใช้ score ในการ search

00:17:26.959 --> 00:17:30.039
มันก็จะมีวิธีใน MongoDB มีหลายวิธีมาก

00:17:30.760 --> 00:17:32.560
วันนี้ผมจะพูดถึงวิธีล่างสุด

00:17:33.160 --> 00:17:35.037
ซึ่งผมเชื่อว่าทั้ง 3 อันเนี่ย

00:17:35.120 --> 00:17:37.197
ไป search ในโลกอินเทอร์เน็ตก็มีหมด

00:17:37.280 --> 00:17:39.480
มีคำอธิบาย advance อยู่แล้วว่าแบบไหน

00:17:39.640 --> 00:17:40.919
เขาใช้เหมือนๆ กัน

00:17:41.320 --> 00:17:44.480
เพียงแต่ว่า MongoDB build มันอยู่บน database เลย

00:17:45.120 --> 00:17:46.600
เพื่อให้เราหยิบมาใช้เลย

00:17:46.720 --> 00:17:49.040
เราแค่กำหนดเองนะครับ

00:17:49.160 --> 00:17:51.760
แน่นอนปัจจุบันมีอยู่ 3 แบบ

00:17:52.039 --> 00:17:54.716
ก็คือแบบ ANN นะ

00:17:54.799 --> 00:17:59.277
ANN ก็คือหมายความว่า มีสินค้าอยู่ประเภทนึง

00:17:59.360 --> 00:18:00.479
เช่น เราพูดถึงแอปเปิ้ล

00:18:00.600 --> 00:18:02.956
แอปเปิ้ลพูดถึงสีและรูปทรงโอเคไหมครับ

00:18:03.039 --> 00:18:05.836
แอปเปิ้ลพูดถึงสีแดงและมีรูปทรงออกห้าเหลี่ยม

00:18:05.919 --> 00:18:08.520
เขาบอกว่ามีรูปใดก็ตามที่เหมือนแอปเปิ้ล

00:18:08.720 --> 00:18:10.877
แปลว่าเราไม่ต้องสนใจทั้ง 2 feature

00:18:10.960 --> 00:18:16.277
ผมเรียกคุณสมบัติของสีแดงกับคุณสมบัติของรูปทรงห้าเหลี่ยม

00:18:16.360 --> 00:18:17.840
สมมติเนาะว่า feature

00:18:18.080 --> 00:18:21.677
แปลว่า ANN เนี่ยไม่สนใจให้มัน match ทีเดียวทั้ง 2 feature

00:18:21.760 --> 00:18:23.797
ไม่จำเป็นโอเคไหมครับ

00:18:23.880 --> 00:18:25.757
ANN บอกว่าอันใดอันหนึ่งก็ได้

00:18:25.840 --> 00:18:27.520
อันนี้คือสมมติให้เห็นภาพเนาะ

00:18:27.679 --> 00:18:31.920
มันแปลว่า approximate ก็คือแค่ประมาณการนะครับ

00:18:32.039 --> 00:18:37.120
แต่ถ้าเป็น exact แปลว่า 2 feature เนี่ยต้องเหมือน

00:18:38.640 --> 00:18:40.956
อันนี้ให้เรามองเห็นภาพ concept ที่มันดูยากๆ

00:18:41.039 --> 00:18:41.797
ให้มันง่ายลงเนาะ

00:18:41.880 --> 00:18:43.716
แต่มันมี in detail มันอยู่แล้วนะครับ

00:18:43.799 --> 00:18:45.960
เพราะฉะนั้นนี่คือความหมายของ ANN

00:18:46.120 --> 00:18:49.920
เพราะฉะนั้น ANN จะเหมาะสำหรับข้อมูลขนาดใหญ่ครับ

00:18:50.600 --> 00:18:54.037
แต่ ENN จะเหมาะสำหรับข้อมูลขนาดเล็ก

00:18:54.120 --> 00:18:56.476
อันนี้คือสิ่งที่เป็น limited ของ vector search

00:18:56.559 --> 00:18:57.159
ของ MongoDB

00:18:57.559 --> 00:19:01.039
บอกว่าถ้ามีข้อมูลมากกว่า 10,000 document

00:19:01.679 --> 00:19:03.320
ให้เปรียบเสมือนว่า 10,000 row

00:19:04.000 --> 00:19:05.640
ถ้าเราต้องการค้นหาข้อมูล 10,000 row

00:19:06.139 --> 00:19:07.637
เราต้องการแบบ match จริงๆ

00:19:07.720 --> 00:19:11.757
เพื่อเพิ่มความแม่นยำของเรา เราใช้แบบ ENN ไปนะครับ

00:19:11.840 --> 00:19:13.917
ส่วนอันสุดท้ายเริ่มนิยมมากขึ้น

00:19:14.000 --> 00:19:17.959
ก็คือเป็นการ fusion เราเรียกว่า hybrid

00:19:18.559 --> 00:19:20.200
ก็คือ search แบบ AI

00:19:20.400 --> 00:19:22.519
อย่าง search คือ search แบบเหมือน

00:19:23.000 --> 00:19:24.920
ผสมกับค่าที่ search แบบเป๊ะ

00:19:25.320 --> 00:19:26.840
แล้วมารวมค่ากัน

00:19:27.600 --> 00:19:29.600
แล้วดูว่าให้ score แบบไหน

00:19:29.760 --> 00:19:31.838
เพื่อค้นหาแบบ อันนี้ก็แม่นยำ

00:19:32.120 --> 00:19:33.476
อันนี้ก็แบบประมาณการ

00:19:33.559 --> 00:19:35.640
ลองดูซิ 2 ค่านี่รวมกันแล้วแบบ

00:19:35.799 --> 00:19:36.596
เพราะอะไรครับ

00:19:36.679 --> 00:19:40.277
เพราะว่าบางครั้งเราอยากจะรู้ว่าสินค้าบางอย่าง

00:19:40.360 --> 00:19:42.720
หรือข้อมูลบางอย่างเนี่ยต้องการแบบ

00:19:43.200 --> 00:19:44.640
ต้องการการผสมผสานนะ

00:19:45.080 --> 00:19:46.877
เพื่อความมั่นใจว่าข้อมูลเนี้ย

00:19:46.960 --> 00:19:50.200
จะมีความใกล้เคียงกับสิ่งที่เราต้องการมากยิ่งขึ้น

00:19:50.720 --> 00:19:55.277
จึงเป็นที่มาของ algorithm ตัวที่ 3 ที่มีใช้นะครับ

00:19:55.360 --> 00:19:56.679
ปัจจุบันเนี้ยมีตัวที่ 4

00:19:56.960 --> 00:19:59.920
ก็คือตัวผมจำชื่อไม่แม่น คือเป็น quantize เนาะ

00:20:00.159 --> 00:20:01.517
ที่คนเริ่มนิยมมากขึ้นนะครับ

00:20:01.600 --> 00:20:04.437
เพราะฉะนั้นทีม MongoDB ก็จะ develop งานวิจัย

00:20:04.520 --> 00:20:07.840
พอๆ กับที่ค่ายอื่นเขาทำกันเหมือนกันนะครับ

00:20:08.520 --> 00:20:12.080
โอเคนะ นี่คือ query มีทั้งหมด 3 แบบนะครับ

00:20:12.919 --> 00:20:16.039
โอเคนะครับ ต่อมาก็คือ

00:20:16.679 --> 00:20:18.197
ในวันนี้ที่ผมจะมี demo

00:20:18.280 --> 00:20:19.517
ซึ่งผมเตรียมมาแล้วบางส่วน

00:20:19.600 --> 00:20:22.037
เพราะว่ามันใช้เวลาในการ develop นะครับ

00:20:22.120 --> 00:20:23.836
เพราะฉะนั้นผมจะ base ตัว Mac

00:20:23.919 --> 00:20:25.677
เพราะผมใช้เครื่อง Mac เป็นหลักนะครับ

00:20:25.760 --> 00:20:27.956
ผมก็เลยคิดว่าถ้าบางท่านใช้เครื่องอื่น

00:20:28.039 --> 00:20:30.000
แล้วมันเกิด fail เวลาเราไป copy code มา

00:20:30.880 --> 00:20:31.836
มันอาจจะมีเป็นไปได้

00:20:31.919 --> 00:20:34.677
ผมไม่ได้ test ทุก OS เนาะนะครับ

00:20:34.760 --> 00:20:37.919
เพราะฉะนั้นผม test บนบริบทที่ผมมีบนเครื่องนี้นะครับ

00:20:38.480 --> 00:20:40.836
แล้วก็สิ่งที่ลงที่เครื่องของเราเนี่ยนะครับ

00:20:40.919 --> 00:20:42.797
เราสามารถที่จะลงไปตามลิงก์ได้

00:20:42.880 --> 00:20:44.680
คือ 1 เราลง Atlas CLI

00:20:44.880 --> 00:20:47.637
ก็คือตัวจำลองให้เครื่องคอมพิวเตอร์ของเราเนี่ย

00:20:47.720 --> 00:20:49.557
เหมาะสำหรับ run MongoDB ทุกอย่าง

00:20:49.640 --> 00:20:51.000
ที่เป็นแบบ offline ได้เลย

00:20:51.320 --> 00:20:53.640
เน้นย้ำนะครับ เป็น offline นะครับ

00:20:54.000 --> 00:20:55.279
แล้วก็ 2 ก็คือตัว Ollama

00:20:55.840 --> 00:20:57.716
Ollama ก็คืออย่างที่ทุกคนทราบ

00:20:57.799 --> 00:21:03.680
คือเป็นตัวที่สามารถทำ run model ได้บนเครื่องตัวเอง

00:21:04.440 --> 00:21:06.279
ในข้อมูลที่จำกัด เลือกได้

00:21:06.559 --> 00:21:10.357
มากกว่า 100 model นะครับ

00:21:10.440 --> 00:21:12.397
มีเยอะแยะมากมาย size เล็ก size ใหญ่

00:21:12.480 --> 00:21:15.160
ก็แล้วแต่ RAM ที่คนเลือกนะครับ

00:21:15.360 --> 00:21:16.557
โอเคนะครับ

00:21:16.640 --> 00:21:20.159
แล้วก็ตัวนี้ก็จะเป็นตัวนะครับ step

00:21:20.640 --> 00:21:23.757
ก็คือ query Ollama ไปปุ๊บ backend มา Mongo นะครับ

00:21:23.840 --> 00:21:26.599
มีทั้งหมด 6 step นะครับ

00:21:26.960 --> 00:21:29.157
โอเค อันนี้ก็จะเป็นคำอธิบายแต่ละ step

00:21:29.240 --> 00:21:30.879
ก็ดู simple เนาะนะครับ

00:21:31.559 --> 00:21:33.557
โอเค เพื่อไม่เป็นการเสียเวลานะครับ

00:21:33.640 --> 00:21:36.200
เราก็จะมา demo ที่ผมทำไว้แล้วเนาะ

00:21:36.640 --> 00:21:37.720
โอเค แป๊บนึงนะครับ

00:21:41.440 --> 00:21:44.277
หลักการเตรียม demo ต้องเตรียมให้ครบก่อนนะครับ

00:21:44.360 --> 00:21:46.956
เราไม่ต้องการพัง ณ ขณะ demo นะครับ

00:21:47.039 --> 00:21:50.343
เพราะฉะนั้นหลักการนี้มันเป็น data ที่มีอยู่แล้วเนาะ

00:21:50.427 --> 00:21:51.637
คุณไปดาวน์โหลดมาได้นะครับ

00:21:51.720 --> 00:21:53.637
ถ้าดูจากคู่มือ เรามี reference อยู่

00:21:53.720 --> 00:21:56.840
ก็คือผมกำลังจะทำการ search Star Wars

00:21:57.360 --> 00:21:59.517
อันนี้เป็นข้อมูลที่เรามีอยู่แล้ว

00:21:59.600 --> 00:22:00.836
เรา copy ใส่นะครับ

00:22:00.919 --> 00:22:02.679
ซึ่งในตัว search Star Wars เนี่ยนะครับ

00:22:06.640 --> 00:22:11.196
โอเค อันนี้นะครับ search Star Wars

00:22:11.279 --> 00:22:14.157
เนี่ยผมก็ search บนเครื่องตัวเองล้วนๆ

00:22:14.240 --> 00:22:15.476
ทุกอย่างอยู่บนเครื่องหมดเลย

00:22:15.559 --> 00:22:17.200
แม้กระทั่ง embedding นะครับ

00:22:17.320 --> 00:22:19.277
เสร็จแล้วมันจะมี score 2 อันตรงนี้นะครับ

00:22:19.360 --> 00:22:22.080
หลักการก็คือเรา search คำว่า Star Wars

00:22:22.600 --> 00:22:25.277
มันก็จะไปค้นดู title นะครับ

00:22:25.360 --> 00:22:28.000
อันนี้คือ title เป็น Star Wars

00:22:28.520 --> 00:22:30.836
มันจะมีคำว่า VS score กับ FT score

00:22:30.919 --> 00:22:31.997
ก็คือผมสร้าง index

00:22:32.080 --> 00:22:33.440
ทุกอย่างต้องสร้าง index ก่อน

00:22:33.720 --> 00:22:36.760
database จะเร็วไม่เร็วอยู่ที่ index ด้วยเป็นส่วนหนึ่ง

00:22:37.240 --> 00:22:38.600
100% นอกจาก modelling design

00:22:38.720 --> 00:22:40.240
ดังนั้น index เป็นจำเป็น

00:22:40.400 --> 00:22:41.919
ผมสร้าง index ขึ้นมา 2 ตัว

00:22:42.240 --> 00:22:44.836
1 ก็ VS ย่อมาจาก vector search

00:22:44.919 --> 00:22:48.437
FTS ย่อมาจาก full text search โอเคไหมครับ

00:22:48.520 --> 00:22:50.920
ดังนั้นคะแนนของใครเอามารวมกันนะ

00:22:51.520 --> 00:22:53.840
เพราะฉะนั้นในบริบทนี้

00:22:54.600 --> 00:22:56.677
แล้วก็ทำการ sorting score ครับ

00:22:56.760 --> 00:22:58.320
sorting จากมากไปน้อย

00:22:58.600 --> 00:23:01.677
ข้อมูลชุดนี้บ่งบอกว่า vector search score

00:23:01.760 --> 00:23:03.277
ให้เป็น 0 ไม่มีคะแนน

00:23:03.360 --> 00:23:05.480
เพราะว่า embed แล้วไม่รู้มันจะได้มายังไง

00:23:05.679 --> 00:23:10.917
แต่พอ search ด้วย FTS นะครับ ได้คะแนน โอเคไหมครับ

00:23:11.000 --> 00:23:13.836
อันนี้ความหมายคือ FTS ก็คือ search แบบ full text search

00:23:13.919 --> 00:23:14.640
ผ่าน title

00:23:14.840 --> 00:23:18.196
แล้วก็ vector search search ผ่าน embedding รวมกันนะครับ

00:23:18.279 --> 00:23:18.596
ประมาณนี้

00:23:18.679 --> 00:23:20.836
เพราะฉะนั้นนี่คือเหตุผลที่ข้อมูลเนี่ย

00:23:20.919 --> 00:23:22.317
ก็จะได้ออกมานะครับ

00:23:22.400 --> 00:23:24.117
เป็นการ scrolling ไปเรื่อยๆ นะครับ

00:23:24.200 --> 00:23:26.679
จะเห็นว่าแล้วมันมีคะแนนประเภทที่

00:23:29.159 --> 00:23:32.117
นี่ครับ vector เห็นไหมครับ

00:23:32.200 --> 00:23:34.800
อันนี้จะได้ vector แต่ไม่ได้ full text นะ

00:23:35.039 --> 00:23:36.637
แต่สุดท้ายเรา sort คะแนนรวมกัน

00:23:36.720 --> 00:23:39.239
เอา 2 คะแนนเนี่ยรวมกันแล้ว sort จากมากไปน้อย

00:23:39.480 --> 00:23:41.917
อันนี้คือท่าที่ MongoDB สามารถจะทำให้

00:23:42.000 --> 00:23:42.880
เรียกว่าเป็นการ hybrid

00:23:43.440 --> 00:23:45.596
เรา search บางสิ่งบางอย่างด้วย similarity

00:23:45.679 --> 00:23:47.877
ผสมกับ exactly ของสิ่งที่เราต้องการ

00:23:47.960 --> 00:23:50.200
แล้วให้มัน sorting ขึ้นมานะครับ

00:23:50.400 --> 00:23:52.280
อันนี้ก็คือความหมายเนาะนะครับ

00:23:52.960 --> 00:23:55.277
โอเคนะครับ เสร็จแล้วก็

00:23:55.360 --> 00:23:57.757
เพราะฉะนั้นก็คืออันนี้คือหลักนะครับ

00:23:57.840 --> 00:24:02.879
สุดท้ายนะครับ เพราะมันเป็น live talk เนาะ

00:24:03.640 --> 00:24:06.120
อันนี้ก็คือให้เห็นภาพว่าเราสามารถที่จะ

00:24:06.320 --> 00:24:08.237
MongoDB มี tool นึงชื่อว่า Compass

00:24:08.320 --> 00:24:10.677
สามารถ break down แล้วก็ run ได้เลยนะครับผม

00:24:10.760 --> 00:24:12.596
พอเรารันปุ๊บก็จะได้คำตอบแบบนี้

00:24:12.679 --> 00:24:16.397
ผมก็เอาคำตอบเนี้ยมาใส่หน้าเว็บ แสดงผลเฉยๆ

00:24:16.480 --> 00:24:19.160
แต่ทุกอย่างทำบน offline หมดนะครับ

00:24:19.559 --> 00:24:23.920
สุดท้ายนะครับ ก็คือ reference นะครับ

00:24:24.279 --> 00:24:26.316
ก็คือถ้าใครสนใจก็ไปดาวน์โหลดนะครับ

00:24:26.399 --> 00:24:27.477
แต่ยังไม่มี repo ผมเฉยๆ

00:24:27.560 --> 00:24:30.559
แต่ดาวน์โหลดมันก็จะมีตัวอย่างให้ทำได้เลยนะครับผม

00:24:31.240 --> 00:24:32.760
ก็จะประมาณนี้นะครับ

00:24:33.399 --> 00:24:36.318
สำหรับเรื่องของตัวการใช้ vector search

00:24:36.440 --> 00:24:40.559
แล้วก็ local model ที่เป็น offline 100% นะครับผม

00:24:40.960 --> 00:24:43.680
ขอบคุณมากครับ

00:24:44.880 --> 00:24:45.637
ขอบคุณครับ

00:24:45.720 --> 00:24:47.080
ขอบคุณพี่ปิติครับ
