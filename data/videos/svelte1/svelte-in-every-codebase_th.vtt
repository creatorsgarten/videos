WEBVTT

00:00:22.400 --> 00:00:24.633
โอเคเดี๋ยวทอล์คต่อไปจะเริ่มแล้วครับ

00:00:24.900 --> 00:00:31.933
Svelte in Every Code Base ครับ ขอเสียงตบมือหน่อยครับ

00:00:32.400 --> 00:00:39.133
โอเคๆ ก็สวัสดีทุกคนในงาน ไม่ได้พูดมานานมาก

00:00:39.200 --> 00:00:44.233
โอเคก็วันนี้มาพูดเรื่อง Svelte in Every Code Base เนาะ

00:00:44.300 --> 00:00:48.933
ไมค์ไม่ดังไปเนาะ ก็ก่อนพูดก็เดี๋ยวแนะนำตัวนิดนึงเนาะ

00:00:49.500 --> 00:00:52.533
ผมชื่อออมนะครับ ทำงานอยู่ที่ Brikl

00:00:53.100 --> 00:00:54.433
เป็น part-time platform engineer

00:00:54.500 --> 00:00:58.333
แล้วก็มีโปรเจคงานเล็กๆ เป็น open source ในเวลาว่างเนาะ

00:00:59.200 --> 00:01:02.833
จริงๆ แล้วไม่คิดเหมือนกันว่าจะมาในสภาพนี้

00:01:02.900 --> 00:01:06.933
เพราะว่าจริงๆ แล้วปกติถ้าผมมางานปกติ

00:01:07.000 --> 00:01:10.233
มันก็จะเป็นแบบนี้มากกว่า

00:01:12.500 --> 00:01:15.433
แต่ว่าที่มาในสภาพนี้ก็เพราะว่า

00:01:15.500 --> 00:01:20.933
มันมีคน มี organizer คนนึงเอาภาพนี้มาขึ้นนะฮะ

00:01:24.300 --> 00:01:25.933
แล้วรู้มั้ยตอนที่ผมจะเปลี่ยน

00:01:26.000 --> 00:01:28.333
ตอนที่ผมยังไม่ได้ลงข้อมูลอะไรเลย

00:01:30.000 --> 00:01:31.133
ตอนที่กำลังจะลงข้อมูลใช่มั้ย

00:01:31.200 --> 00:01:34.933
มี messenger นึง inbox มา แท็กผมแล้วก็บอกว่า

00:01:35.000 --> 00:01:36.733
อ่าไม่ต้องส่งรูปภาพนะ ไม่เปลี่ยนให้

00:01:36.800 --> 00:01:40.032
ก็โอเค ก็เลยมาในสภาพนี้ก็ได้ฮะ อะไรประมาณนี้

00:01:44.500 --> 00:01:48.933
ก็โอเค ก่อนเริ่มก็เดี๋ยวเราพูดถึงเรื่อง software กันก่อนเนาะ

00:01:49.000 --> 00:01:52.633
ปกติแล้วเนี่ย ในนี้เราคิดว่าทุกคนน่าจะเป็นโปรแกรมเมอร์เนาะ

00:01:52.700 --> 00:01:53.733
ก็น่าจะเคยเขียน software กัน

00:01:53.800 --> 00:01:56.233
บางคนอาจจะเขียน server บางคนอาจจะทำ hardware

00:01:56.300 --> 00:01:58.532
แต่ว่าส่วนใหญ่ก็ในนี้ก็น่าจะทำ software เนาะ

00:01:58.600 --> 00:01:59.933
เพราะงานก็ธีม software

00:02:00.000 --> 00:02:03.133
เรารู้จักอันนี้มั้ยฮะ เผื่อใครไม่รู้จักเนาะ

00:02:03.200 --> 00:02:06.032
ใครไม่ได้ใช้ Mac อันนี้คือตัว setting ของ Mac นะฮะ

00:02:06.100 --> 00:02:07.333
คือหน้าตาเป็นแบบนี้เลย

00:02:07.400 --> 00:02:08.733
ปกติแล้วเนี่ย ใน Windows ใน Mac เนี่ย

00:02:09.400 --> 00:02:11.132
มันก็จะใช้ภาษาแบบ native ใช่มั้ย

00:02:11.200 --> 00:02:13.233
อย่าง Windows ก็อาจจะใช้ C# ในการเขียน

00:02:13.300 --> 00:02:15.632
หรือว่าใน Mac เนี่ย ก็จะใช้ Swift ในการเขียน

00:02:15.700 --> 00:02:18.333
ตัว interface ของตัว system เนาะ

00:02:18.400 --> 00:02:20.533
ยิ่งอันนี้มันเขียนโดย Apple เองแล้ว

00:02:20.600 --> 00:02:22.333
มันก็คงจะต้องเขียนด้วย Swift แหละ

00:02:22.400 --> 00:02:24.933
แต่ว่ารู้อะไรมั้ยว่า จริงๆ แล้วเนี่ย

00:02:25.000 --> 00:02:27.833
ที่คนเห็นแบบนี้เนี่ย มันไม่ได้เขียนด้วย Swift เพียวๆ

00:02:27.900 --> 00:02:29.833
แต่ว่าเราสามารถทำอย่างงี้ได้

00:02:29.900 --> 00:02:31.733
เรากดคลิกขวาแล้ว inspect element

00:02:31.800 --> 00:02:34.333
แล้วมันก็จะมี Home Depot ขึ้นมา

00:02:36.000 --> 00:02:38.333
เนี่ยที่ตรงนี้มันทำได้เนี่ย

00:02:38.400 --> 00:02:39.933
เพราะว่าจริงๆ แล้วเนี่ย ตัวนี้มันเขียนด้วย Swift แหละ

00:02:40.000 --> 00:02:41.733
แต่ว่ามีบางส่วนเนี่ย มันถูกเขียนด้วย web view

00:02:41.800 --> 00:02:44.132
อย่างเช่นตัวตรง title ตรงนี้

00:02:44.200 --> 00:02:48.433
มันถูก fetch data แล้วก็เอา web เข้ามาเลย

00:02:48.500 --> 00:02:49.933
มันก็คือแบบตรงๆ ไม่ต้องทำอะไรมาก

00:02:50.000 --> 00:02:51.433
เพราะฉะนั้นเนี่ย บางส่วนเนี่ย

00:02:51.500 --> 00:02:52.632
ต่อให้มันเป็น native software เนี่ย

00:02:52.700 --> 00:02:55.433
เราอาจจะใช้มานานแล้วไม่ได้สังเกตเลย

00:02:55.500 --> 00:02:59.033
แต่ว่าจริงๆ แล้วเนี่ย มันเร็วเหมือนกับว่า native software เลย

00:02:59.100 --> 00:03:01.333
เพราะฉะนั้นเนี่ย จริงๆ แล้ว web เนี่ย

00:03:01.900 --> 00:03:03.132
มันไม่ได้แบบว่าช้าขนาดนั้น

00:03:03.200 --> 00:03:05.533
คือแบบว่าในขนาดแบบ มันอยู่ตรงนี้มานานแล้ว

00:03:05.600 --> 00:03:06.533
ยังไม่มีใครรู้เลยว่ามันเป็น web

00:03:06.600 --> 00:03:09.833
จนกระทั่งแบบว่า Mac macOS เวอร์ชันแบบต้นปีที่ผ่านมาเนี่ย

00:03:09.900 --> 00:03:12.233
เพราะฉะนั้นเนี่ย จริงๆ แล้ว ตัว web เนี่ย

00:03:12.300 --> 00:03:13.733
มันอยู่เกือบทุกที่เลย

00:03:13.800 --> 00:03:15.733
ไม่ว่าจะเป็นแบบว่าใน Windows ใน Mac

00:03:16.000 --> 00:03:19.433
แม้แต่ขนาดแบบว่า ตัว native system ของ Mac เอง

00:03:19.500 --> 00:03:20.632
ก็ยังใช้ web view อยู่เลย

00:03:20.900 --> 00:03:23.333
ซึ่งถ้าเราไม่รู้ว่าตัว web เนี่ยมันมีอะไรบ้าง

00:03:23.400 --> 00:03:26.533
ก็ตรงหน้าเนี่ย ทั้งหมดเนี่ยถูกเขียนด้วย web หมดเลย

00:03:26.600 --> 00:03:28.433
ตัว Discord ถูกเขียนด้วย Electron

00:03:28.500 --> 00:03:29.933
browser ก็ใช้ JavaScript อยู่แล้ว

00:03:30.200 --> 00:03:31.833
Slack ก็เขียนด้วย Electron

00:03:33.200 --> 00:03:34.533
Postman ก็เขียนด้วย Electron

00:03:34.900 --> 00:03:37.733
แล้วก็ล่าสุดก็คือ VS Code ก็เขียนด้วย Electron เหมือนกัน

00:03:37.800 --> 00:03:39.833
ซึ่งมันเยอะมากเลย

00:03:39.900 --> 00:03:42.632
มันมีตั้งแต่แบบ mobile desktop เลย สามารถใช้ web ได้เนี่ย

00:03:42.700 --> 00:03:45.433
ซึ่งเราก็เดี๋ยวนี้เราสามารถใช้ Electron

00:03:45.800 --> 00:03:47.132
ในการสร้าง desktop app ได้

00:03:47.800 --> 00:03:50.333
แล้วก็นอกจาก Electron แล้วเนี่ย บน desktop app

00:03:50.400 --> 00:03:52.833
เดี๋ยวนี้ก็มี Tauri ที่เพิ่งประกาศเป็นเวอร์ชัน stable

00:03:52.900 --> 00:03:53.632
เมื่อสัปดาห์ที่แล้ว

00:03:53.700 --> 00:03:56.632
ก็ Tauri คือ มันคือ Electron แต่เร็วกว่า

00:03:56.700 --> 00:03:58.132
แทนที่จะเอา Chromium เนี่ย

00:03:58.200 --> 00:04:00.333
เราใช้เป็น native web view ตัวเลย

00:04:00.400 --> 00:04:03.533
อย่างเช่นของ Windows ก็จะใช้เป็นตัว Microsoft Edge

00:04:03.800 --> 00:04:05.933
ของ Mac ก็จะใช้เป็น Safari

00:04:06.000 --> 00:04:08.233
ก็คือแบบเราไม่ต้อง ship browser อะไรทั้งนั้น

00:04:08.300 --> 00:04:09.533
เพราะฉะนั้นมันจะขนาดเล็กมาก

00:04:09.600 --> 00:04:13.533
ตัวนี้เนี่ย เป็นตัว software ที่ผมเขียนขึ้นเองชื่อ Lagrange

00:04:13.600 --> 00:04:16.733
มันคือแบบอารมณ์ประมาณว่า Postman แต่ว่าเร็วกว่า

00:04:16.800 --> 00:04:17.832
เดี๋ยวมาเอาให้ดูเนาะ

00:04:19.600 --> 00:04:23.433
Lagrange ปึ๊บ ไม่รู้ว่าจะมองเห็นป่ะนะ ปึ๊บ

00:04:25.800 --> 00:04:29.133
ตัวนี้เป็น ถ้าไม่ชัวร์ก็คือ

00:04:29.200 --> 00:04:30.733
โห หน้าตามันเล็กมากเลยอ่ะ

00:04:31.100 --> 00:04:33.133
หลักๆ คือมันคือ Postman แต่ว่ามันคือ

00:04:33.200 --> 00:04:35.033
แบบว่าเขียนด้วยตัว Tauri มากกว่า

00:04:35.100 --> 00:04:38.832
ถ้าเราลองกด send ดู ปึ๊บ ได้ๆๆ

00:04:48.200 --> 00:04:53.233
โอเค thank you ก็ถ้าเราลองกด send ดูตรงนี้

00:04:53.300 --> 00:04:57.633
เห็นมั้ย ตรงนี้เป็น web เนาะ เป็น API endpoint

00:04:57.900 --> 00:04:58.832
ส่วนตรงนี้เป็นตัว GraphQL

00:04:58.900 --> 00:05:03.433
ถ้าเรากดส่งมันก็จะได้ข้อมูลแบบเหมือนตัว Postman เลย

00:05:03.500 --> 00:05:05.933
เดี๋ยวเราลองเปลี่ยน variable ดูแล้วกัน

00:05:07.200 --> 00:05:09.033
เป็น page 2 แล้วกันเนาะ

00:05:09.100 --> 00:05:13.332
โอเค enter มันก็จะ fetch ข้อมูลมาจากตัว API

00:05:13.600 --> 00:05:17.233
ตรงนี้ด้วย GraphQL ซึ่งตรงนี้เป็น Postman แบบย่อมๆ

00:05:17.300 --> 00:05:19.233
ซึ่งขนาดเนี่ยมันแค่ 7 MB ตัว bundle size ทั้งหมด

00:05:19.900 --> 00:05:21.633
แค่ 7 MB แล้วมันเปิดเร็วมาก

00:05:21.700 --> 00:05:23.733
เดี๋ยวผมเปิดให้ดูเลยแล้วกันเนาะ

00:05:23.800 --> 00:05:27.133
ดูนะ ไม่น่าถึง 0.1 วินาที ก็น่าจะเปิดเสร็จแล้ว

00:05:27.200 --> 00:05:28.933
เรียบร้อย เร็วมาก

00:05:29.000 --> 00:05:31.033
ถ้าเราลองเทียบกับ Postman นะ ที่เขียนด้วย Electron

00:05:31.100 --> 00:05:32.832
อันนี้ Postman เป็น M1 Native แล้ว

00:05:41.500 --> 00:05:45.233
ประมาณเกือบ 8 วินาทีมั้ง น่าจะประมาณเนาะ

00:05:45.300 --> 00:05:47.533
เพราะฉะนั้นเดี๋ยวนี้มันมีอะไรใหม่มาเยอะมาก

00:05:47.600 --> 00:05:49.533
โดยเฉพาะในโลกของ web

00:05:49.600 --> 00:05:52.133
เดี๋ยวนี้เราก็ไม่ต้องมานั่งรอ Electron

00:05:52.200 --> 00:05:53.233
ที่แบบว่าช้าขนาดนั้นอีกแล้ว

00:05:53.600 --> 00:05:56.933
ก็โอเค มาต่อเลย ก็เดี๋ยวนี้มันก็มี Tauri เนาะ

00:05:57.000 --> 00:06:00.332
แล้วก็ตัว mobile ก็มีตัว Ionic Capacitor

00:06:00.400 --> 00:06:02.033
ที่แบบว่าเราเอามาเขียน mobile ได้

00:06:03.100 --> 00:06:08.133
แล้วก็รู้มั้ยว่าตู้เต่าบินเนี่ย จริงๆ แล้วเนี่ย

00:06:08.200 --> 00:06:09.832
มันไม่ใช่ embedded มันเป็น Android

00:06:09.900 --> 00:06:13.233
แล้วก็ตัวของมันจริงๆ เนี่ย มันเขียนด้วย Ionic

00:06:13.300 --> 00:06:17.033
ถ้าถามว่ารู้ได้ไง จริงๆ แล้วมันมี endpoint expose ออกมา

00:06:17.100 --> 00:06:20.033
เราสามารถเข้าไปเช็กได้เลย มันเป็น Ionic แท้ๆ เลย

00:06:20.100 --> 00:06:25.633
แต่ว่า fix UI แล้วก็เราสามารถใช้ Svelte ในการนั่นแหละ

00:06:26.500 --> 00:06:31.133
จริงๆ แล้วเนี่ย เดี๋ยวนี้มันมี web เยอะมากเลย

00:06:31.200 --> 00:06:32.332
เห็นมั้ยว่ามันมีทุกที่เลย

00:06:32.400 --> 00:06:35.933
ไม่ว่าจะในตู้เต่าบิน ในตัวแบบ ใน TV system เนี่ย

00:06:36.000 --> 00:06:37.533
เดี๋ยวนี้มันก็มี web เต็มไปหมดเลย

00:06:37.600 --> 00:06:40.832
แต่คำถามก็คือ สมมติว่าเราเขียนโปรเจคนึงเสร็จแล้วเนี่ย

00:06:40.900 --> 00:06:43.233
แล้วในโปรเจคใหม่เราต้องการใช้ component ตัวเดิม

00:06:43.300 --> 00:06:46.533
หรือต้องการ reuse เนี่ย คำถามคือเราจะจัดการยังไง

00:06:47.000 --> 00:06:51.533
เดี๋ยวนี้เนี่ย หลักๆ เราก็จะเขียนด้วย 3 framework เนาะ

00:06:51.600 --> 00:06:54.733
ใน web ก็จะมี Angular, React แล้วก็จะมี Vue

00:06:54.800 --> 00:06:57.033
อีกตัวนึงที่อยู่ในนี้เนาะ

00:06:57.100 --> 00:07:00.933
มีใครเขียน web แล้วไม่เคยใช้ 3 ตัวนี้บ้างมั้ยฮะ เป็นหลัก

00:07:02.600 --> 00:07:04.832
ไม่มีนะ โอเค

00:07:05.400 --> 00:07:09.533
ก็คำถามก็คือ เห็นมั้ยว่าเนี่ยเดี๋ยวนี้มันแบบว่า

00:07:10.900 --> 00:07:15.233
80% ใช้ React 54% ใช้ Angular แล้วก็ 51% ใช้ Vue

00:07:15.300 --> 00:07:20.433
ใน 2021 ใช่ อันนี้มาจาก State of JS เนาะ

00:07:21.000 --> 00:07:23.633
คำถามก็คือ ในเมื่อเรามี framework ที่คนใช้เยอะขนาดนี้แล้ว

00:07:23.700 --> 00:07:26.133
แล้วทำไมเราถึงยังต้องสร้าง framework อะไรใหม่ๆ

00:07:26.200 --> 00:07:27.332
หรือ library อะไรใหม่ๆ อีก

00:07:27.800 --> 00:07:31.633
ก็อันนี้ตอบง่ายมากฮะ มีใครเคยใช้ตัวนี้มั้ยฮะ

00:07:31.700 --> 00:07:35.633
เนี่ย มีใครยังใช้อันนี้อยู่มั้ย ไม่มีเนาะ

00:07:37.400 --> 00:07:40.433
โอเค นั่นคือ เพราะฉะนั้นเนี่ย ผมไม่จำเป็นต้อง

00:07:40.500 --> 00:07:41.733
ที่จะอธิบายอะไรมาก

00:07:41.800 --> 00:07:43.633
คือพอมันมีของที่ดีกว่าเนี่ย

00:07:43.700 --> 00:07:46.033
เราไม่จำเป็นที่จะต้องทนใช้ของเดิม

00:07:46.100 --> 00:07:48.033
เพราะว่าในอนาคตเนี่ยมันจะมีเครื่องมือที่ดีกว่า

00:07:48.100 --> 00:07:49.433
มาแทนที่เสมอ

00:07:49.700 --> 00:07:52.033
เมื่อก่อนเราอาจจะใช้ webpack กับ browserify

00:07:52.100 --> 00:07:54.733
Grunt หรือว่า Rollup ซึ่ง 2 ตัวนี้ก็ยังมีใช้อยู่เนาะ

00:07:54.800 --> 00:07:57.033
เดี๋ยวนี้ก็ยังมีใช้อยู่ เช่น Next.js ก็ยังใช้อยู่

00:07:57.100 --> 00:07:59.533
แต่ว่า Next.js ก็เริ่มที่จะย้ายมาเป็น SWC

00:07:59.800 --> 00:08:01.233
แล้วเดี๋ยวนี้ก็ Vite ก็ใช้ esbuild

00:08:01.300 --> 00:08:03.233
แล้วก็จะมีอีกตัวนึงที่เรียกว่า Bun.js

00:08:03.500 --> 00:08:04.533
ซึ่งยังเป็น closed source อยู่

00:08:04.600 --> 00:08:08.533
ซึ่งมันเร็วกว่า SWC ประมาณเกือบ 10 เท่าได้

00:08:08.600 --> 00:08:09.633
ทั้งๆ ที่มันยังเขียนด้วย Rust อยู่

00:08:09.700 --> 00:08:13.832
แต่ว่า โอเค ถ้าเราลองมาดูกราฟตัวนี้เนาะ

00:08:13.900 --> 00:08:15.533
ตัวนี้เนี่ยมันคือ satisfaction

00:08:15.600 --> 00:08:18.433
ก็คือเราใช้ library อะไรแล้วแบบพอใจขนาดไหน

00:08:18.500 --> 00:08:20.733
จะสังเกตว่าตัว 3 framework เนี่ย

00:08:21.700 --> 00:08:22.832
3 framework เมื่อกี้อ่ะ

00:08:22.900 --> 00:08:23.933
ไม่ใช่อันดับ 1 อันดับ 2 อันดับ 3 อีกแล้ว

00:08:24.000 --> 00:08:26.633
เดี๋ยวนี้ ตัวจากปีที่แล้วเนี่ย

00:08:26.700 --> 00:08:28.933
ตัวที่คนพอใจในการเขียนมากสุดคือ Solid

00:08:29.000 --> 00:08:32.033
รองลงมาคือ Svelte แล้วก็อันดับ 3 เนี่ยคือ React

00:08:32.100 --> 00:08:34.433
เห็นมั้ยว่ามันไม่ได้แบบว่าคงอยู่คงที่เสมอ

00:08:34.500 --> 00:08:37.533
เพราะฉะนั้นเนี่ย ไม่ว่าเราจะชอบ library อะไรก็ตามเนี่ย

00:08:37.600 --> 00:08:39.433
สุดท้าย library ที่เราชอบมันจะตายอยู่ดี

00:08:39.500 --> 00:08:42.232
jQuery ก็ตาย ไม่ว่าจะอะไรก็ตามเนี่ย

00:08:42.299 --> 00:08:44.733
คนอาจจะเห็นว่า React เนี่ย คนเรียนตอนนี้

00:08:45.100 --> 00:08:48.233
คนอาจจะได้ใช้แบบ 5 ปี อาจจะ 10 ปี

00:08:48.300 --> 00:08:50.233
แต่ว่าในอีก 20 ปีก็อาจจะไม่อยู่แล้วก็ได้

00:08:50.300 --> 00:08:55.433
เพราะฉะนั้นเนี่ย แต่ว่าในการที่แต่ละอย่างเนี่ยมันเกิดขึ้น

00:08:55.700 --> 00:08:57.333
อย่างย้ายจาก jQuery มาเป็น React เนี่ย

00:08:57.400 --> 00:09:00.333
เราใช้เวลาก็ใช้เวลาเยอะมาก

00:09:00.400 --> 00:09:02.333
อย่างเช่นแบบอาจจะ 10 ปี หลัก 10 ปีขึ้นไป

00:09:02.400 --> 00:09:02.933
อะไรประมาณนี้

00:09:03.300 --> 00:09:08.033
แล้วก็รู้มั้ยครับว่าตอนนี้ jQuery เนี่ย

00:09:08.100 --> 00:09:11.033
บนเว็บไซต์ทั่วโลก จากสถานะตอนนี้

00:09:11.100 --> 00:09:12.033
jQuery ยังมีคนใช้อยู่ 80%

00:09:12.700 --> 00:09:14.533
จากเว็บไซต์ทั้งหมดที่ยัง hot อยู่ตอนนี้

00:09:14.600 --> 00:09:17.133
แต่ว่าเห็นมั้ยว่าเดี๋ยวนี้ก็ไม่มีใครเขียน jQuery แล้ว

00:09:17.200 --> 00:09:18.533
เพราะฉะนั้นเนี่ย ไม่ว่าจะเกิดอะไรขึ้นเนี่ย

00:09:18.600 --> 00:09:21.833
มันใช้เวลาเสมอในการที่จะ transition จากสิ่งนึงไปสิ่งนึงเนาะ

00:09:21.900 --> 00:09:25.933
แต่ว่า เวลาที่เราเขียนอะไรเนี่ย บางทีเนี่ย

00:09:26.000 --> 00:09:27.933
เราธุรกิจเนี่ยมันไม่สามารถที่จะรอได้

00:09:28.000 --> 00:09:31.833
เราจะแบบว่า framework ใหม่ เราเขียนขึ้นมาเลย

00:09:31.900 --> 00:09:34.533
แล้วก็แบบในอีก 2 ปี แล้วก็ธุรกิจไม่สามารถรอแบบนั้นได้

00:09:34.600 --> 00:09:36.733
เราไม่สามารถ migrate จาก whole React ทั้งหมด

00:09:36.800 --> 00:09:38.433
ไปเป็น Svelte ในวันพรุ่งนี้ได้

00:09:38.500 --> 00:09:40.433
หรือว่าในสัปดาห์นี้ได้ อะไรประมาณนั้น

00:09:40.500 --> 00:09:42.533
แต่ว่าสิ่งที่เราทำได้เนี่ย

00:09:42.600 --> 00:09:46.333
คือเราสามารถค่อยๆ ขยับมันขึ้นมาได้ทีละส่วนๆ

00:09:48.100 --> 00:09:52.533
แล้วก็ถ้าจะให้พูดวิธีเนี่ย เราอาจจะแบบ โอเค

00:09:52.600 --> 00:09:57.233
เราไม่เขียนใหม่ละ เราจะค่อยๆ เขียนใหม่ทีละส่วนเนาะ

00:09:57.300 --> 00:09:58.833
วิธีการเขียนใหม่ทีละส่วนเนี่ย มันมีหลายวิธีมากเลย

00:09:58.900 --> 00:09:59.533
อย่างเช่น ทำ proxy ทำ micro architecture

00:09:59.900 --> 00:10:02.933
ทำ monorepo micro frontend

00:10:03.200 --> 00:10:05.533
หรือว่าจะสร้าง project ใหม่ทั้งหมดเลยก็ได้เหมือนกัน

00:10:05.600 --> 00:10:11.133
แต่ว่า คำถามก็คือ ตอนนี้เนี่ย มี 3 framework ละ

00:10:11.200 --> 00:10:13.633
แล้วทำไมเราถึงมาในงานที่ชื่อว่า SvelteJS

00:10:14.400 --> 00:10:21.033
ทำไมเราถึงควรที่จะใช้ Svelte เนาะ

00:10:21.100 --> 00:10:23.633
โอเค อย่างแรกที่ผมจะพูดมาก่อนเลย

00:10:23.700 --> 00:10:25.933
นี่คือสิ่งที่ทุกคนน่าจะเห็นด้วยก็คือ

00:10:26.000 --> 00:10:28.233
เดี๋ยวนี้เนี่ย ขนาด bundle size ของ web เนี่ย

00:10:28.300 --> 00:10:31.133
average ในปี 2021 อยู่ที่ประมาณ 2 MB

00:10:31.200 --> 00:10:33.133
ซึ่งถ้าเราดูจากตรงนี้แล้วเนี่ย

00:10:33.200 --> 00:10:34.333
ตัว framework ที่เราใช้เนี่ย

00:10:34.400 --> 00:10:35.833
โอเค ตอนนี้มันอาจจะดูไม่เยอะหรอก

00:10:35.900 --> 00:10:39.733
แต่ว่า ใครจะไปรู้ว่า สมมติผมใช้ React เป็นหลักเนาะ

00:10:39.800 --> 00:10:43.533
ใน React เนี่ย เรามีใครแบบลง React เพียวๆ ไหม

00:10:43.600 --> 00:10:46.033
ก็ไม่มีใช่ไหม ทุกคนต้องแบบว่าลง library เพิ่ม

00:10:46.100 --> 00:10:49.433
อย่างเช่น state management ก็ใช้ Redux, Recoil

00:10:49.900 --> 00:10:52.033
หรือว่า Jotai หรือว่าแล้วแต่คนชอบเนาะ

00:10:52.600 --> 00:10:54.333
บางทีก็มีอยาก fetch GraphQL ก็ลง GraphQL

00:10:54.400 --> 00:10:57.133
แล้วก็ลง React Query หรือ useSWR มาอีก

00:10:58.700 --> 00:10:59.933
ไม่ว่าเราจะเห็นแบบแค่เนี้ย

00:11:00.000 --> 00:11:02.333
แต่ว่าจริงๆ แล้วเนี่ย ใน codebase ของเราเนี่ย

00:11:02.400 --> 00:11:03.933
มันไม่ได้ใช้แค่นี้หรอก

00:11:04.000 --> 00:11:05.833
มันจะต้องใช้แบบว่า library ที่แบบช่วยพวกนี้เอง

00:11:05.900 --> 00:11:09.733
ซึ่งผมว่าอย่างน้อยเนี่ย แต่ละ node module

00:11:09.800 --> 00:11:13.133
ของแต่ละคนเนี่ย ก็คงแบบว่าเกินหลัก GB ละ

00:11:13.200 --> 00:11:14.433
ถ้าอยู่ในบริษัทเนาะ

00:11:17.100 --> 00:11:24.033
ทีนี้เนี่ย สมมติว่าเราจะย้ายจาก React ไป Angular

00:11:24.100 --> 00:11:25.533
หรือว่าย้ายจาก Angular ไป React เนี่ย

00:11:25.600 --> 00:11:29.233
มันเท่ากับว่า สมมติเรามีทั้ง 2 อันเนี่ย

00:11:29.300 --> 00:11:30.433
ใน project เดียวกันเนี่ย

00:11:30.500 --> 00:11:32.333
ก็เท่ากับว่าเราจะต้องเอา bundle size

00:11:33.000 --> 00:11:37.033
อย่างน้อยที่สุดก็คือ 60 KB กับ 40 KB มารวมกัน

00:11:37.100 --> 00:11:40.533
ซึ่งมันก็แบบว่ามีขนาดแบบ 106 KB ละ

00:11:40.600 --> 00:11:43.033
แล้วก็ถ้าเราไป run มัน page speed เนี่ย

00:11:43.100 --> 00:11:44.233
ก็คงแบบไม่ได้ถึง 100 แน่นอน

00:11:44.300 --> 00:11:49.133
เพราะแค่เอา framework เข้ามามันก็แบบ 100 กว่า KB แล้ว

00:11:49.200 --> 00:11:51.433
ถ้า bundle size จริงรวมจริงก็คงแบบว่า

00:11:51.500 --> 00:11:54.333
ทำแบบ web dashboard หรือว่า web back office เนี่ย

00:11:54.400 --> 00:11:56.533
อย่างนั้นก็คงแบบ 300 GB ขึ้นไปแล้วขนาดนี้

00:11:56.600 --> 00:11:59.333
แต่ว่า คุณรู้ไหมครับว่า Svelte เนี่ย

00:11:59.400 --> 00:12:01.233
มันมีขนาดแค่ 1.7 KB แค่นั้นเอง

00:12:02.700 --> 00:12:05.033
ถ้าเราลองใช้ Svelte เนี่ย รวมกับ React

00:12:05.100 --> 00:12:07.133
เราค่อยๆ migrate ตัว React ไปเป็น Svelte เนี่ย

00:12:07.200 --> 00:12:09.533
จะเห็นว่าเนี่ย bundle size ของ React ทั้งหมดมีแค่ 44

00:12:10.300 --> 00:12:13.433
แต่ว่าพอเอามารวมกับ Svelte แล้วมีแค่ 46 แค่นั้นเอง

00:12:14.500 --> 00:12:16.633
เราสามารถใช้ Svelte ได้เหมือนกับว่า

00:12:16.700 --> 00:12:17.833
มันไม่ได้มีอะไรอยู่ตรงนั้นเลย

00:12:17.900 --> 00:12:20.633
เพราะว่า ขนาด bundle size มันเล็กมากๆ

00:12:20.700 --> 00:12:23.133
อันนี้คือ 1 footprint ที่มันจะไม่มาแน่นอน

00:12:23.200 --> 00:12:25.433
ในเวลาที่เรา migrate ทุกอย่างเป็น Svelte เนาะ

00:12:25.800 --> 00:12:30.533
แล้วก็ลองคิดดูว่าสมมติว่าเราค่อยๆ migrate จนเสร็จ

00:12:30.600 --> 00:12:33.033
แล้วเนี่ย เท่ากับว่าเราจะสามารถ reduce

00:12:33.100 --> 00:12:34.633
ออกตัว 44 KB ตรงนี้หายไปได้เลย

00:12:34.700 --> 00:12:36.933
ยิ่งถ้าใช้ NextJS ด้วยแล้วมันจะมี bundle size

00:12:37.000 --> 00:12:38.733
อยู่ประมาณอย่างน้อย 60-70 KB

00:12:38.800 --> 00:12:40.433
ในการสร้าง web ใหม่เนาะ

00:12:40.500 --> 00:12:42.033
ซึ่งมันก็แบบว่าหายไป

00:12:42.100 --> 00:12:43.733
เราก็จะได้คะแนน performance มาฟรีๆ เลย

00:12:43.800 --> 00:12:46.533
เพราะฉะนั้นเนี่ย เดี๋ยววันนี้จะลองพูดถึง

00:12:47.300 --> 00:12:48.833
วิธีการ migrate ตัว Svelte

00:12:48.900 --> 00:12:51.933
แบบว่า 4 วิธีในการที่ migrate code เป็น Svelte เนาะ

00:12:53.200 --> 00:12:56.433
อย่างแรกก็ทุกคนน่าจะรู้จัก web component อยู่ละ

00:12:56.500 --> 00:12:59.233
web component เนี่ย เผื่อใครไม่รู้จักเนาะ

00:12:59.300 --> 00:13:02.233
web component มันคือ เราสามารถเอา JavaScript

00:13:02.800 --> 00:13:05.833
bundle ไปเป็น HTML element ได้ 1 อันเลย

00:13:05.900 --> 00:13:07.933
เหมือนกับว่า เราเขียน code มาแล้วปุ๊บ

00:13:08.000 --> 00:13:09.533
แล้วเราก็เอา code ทั้งหมดเนี่ย

00:13:10.600 --> 00:13:13.333
ไปรวมเป็น HTML tag 1 อัน

00:13:13.400 --> 00:13:17.233
ซึ่งในสมัยนี้เนี่ย ตัว library ที่เรานิยมใช้

00:13:17.300 --> 00:13:19.933
หลักๆ มีอยู่ 2 ตัวคือ Stencil แล้วก็ LitElement

00:13:20.500 --> 00:13:24.533
แต่ว่า โอเค ในเมื่อเรามี 2 อันนี้อยู่แล้ว

00:13:24.600 --> 00:13:26.933
แล้วก็คนใช้เยอะมากสำหรับในการทำ web component

00:13:27.000 --> 00:13:28.733
อยู่แล้ว ทำไมเราถึงยังต้องใช้ Svelte อยู่

00:13:29.000 --> 00:13:33.533
คำตอบแรกก็คือ ตัว library 2 ตัวนี้เนี่ย

00:13:33.600 --> 00:13:35.133
มัน limit อยู่ที่ web component เท่านั้น

00:13:35.200 --> 00:13:37.133
เราไม่สามารถ compile เป็นแบบว่า

00:13:37.200 --> 00:13:38.833
แบบไม่มี web component ได้

00:13:38.900 --> 00:13:40.633
อย่างเช่นสมมติเราสร้าง React เนาะ

00:13:40.700 --> 00:13:41.433
เราก็สามารถ compile ทั้งหมด

00:13:41.800 --> 00:13:43.433
เป็นแบบว่า DOM ปกติได้เลย

00:13:43.500 --> 00:13:46.633
แต่ว่า React เนี่ยก็สามารถ compile เป็น web component

00:13:46.700 --> 00:13:49.033
ได้เหมือนกัน แต่ถ้าเราใช้ library 2 ตัวเนี้ย

00:13:49.100 --> 00:13:52.633
มันไม่มีวิธีที่ง่ายซักเท่าไหร่ในการที่แบบเปลี่ยนทุกอย่าง

00:13:52.700 --> 00:13:54.233
ให้กลายเป็น native HTML เนาะ

00:13:56.000 --> 00:13:58.733
นี่คือเหตุผลที่เราควรใช้ Svelte เหตุผลที่ 2

00:13:59.000 --> 00:14:01.633
ก็คือเราลองดู performance graph ตรงนี้แล้วกัน

00:14:01.700 --> 00:14:04.133
ตรงนี้เนี่ย performance graph ของอันเนี้ยเนี่ย

00:14:04.200 --> 00:14:07.233
มันคือเอามาจากตัว jsPerf เนาะเผื่อใครไม่เคยเห็น

00:14:07.300 --> 00:14:09.133
หลักๆ มันคือ

00:14:09.400 --> 00:14:13.233
เปรียบเทียบระหว่าง LitElement Svelte แล้วก็ Stencil

00:14:13.300 --> 00:14:14.733
ตัว Svelte อยู่อันที่ 2 เนาะสีส้มเนาะ

00:14:14.800 --> 00:14:19.033
จะเห็นว่าตรงนี้เนี่ย Svelte เนี่ยมันเร็วเป็นอันดับ 2 เลย

00:14:19.100 --> 00:14:19.433
ปึ๊บ

00:14:21.300 --> 00:14:23.533
ถ้าเทียบกับ Stencil พอเทียบกับ LitElement เนี่ย

00:14:23.600 --> 00:14:25.533
Svelte เนี่ยใกล้เคียงกับตัว LitElement มาก

00:14:25.600 --> 00:14:28.133
มันเร็วแบบเกือบจะเท่ากันเลย

00:14:28.200 --> 00:14:32.033
ทีนี้เนี่ยเผื่อใครไม่รู้ เผื่อใครไม่ get ว่ามันเร็วแค่ไหนเนาะ

00:14:32.100 --> 00:14:35.133
เดี๋ยวเราลอง compare เราลองเอาไปเทียบกับตัว Angular

00:14:35.200 --> 00:14:36.433
React แล้วก็ Vue ดูแล้วกัน

00:14:37.500 --> 00:14:41.933
โอเค อันนี้คือ graph ในการเทียบเนาะ

00:14:42.000 --> 00:14:45.533
อันแรกคือ Svelte ลองลงมาเป็น Vue อันที่ 3 เป็น Angular

00:14:45.600 --> 00:14:48.733
แล้วก็อันที่ 4 เป็น React อันนี้เป็นเวอร์ชั่นล่าสุดเนาะ

00:14:48.800 --> 00:14:49.333
ทั้งหมดเลย Svelte 3.4 Vue 3.2

00:14:49.900 --> 00:14:54.533
3.2 เป็นล่าสุดรึเปล่าไม่แน่ใจ แล้วก็ Angular 13 ล่าสุดละ

00:14:55.200 --> 00:14:56.433
แล้วก็ React เป็น React 18

00:14:56.900 --> 00:14:58.333
แต่ถ้าเราลองมาเทียบแล้วเนี่ยจะเห็นว่า

00:14:58.400 --> 00:15:01.733
ไม่ว่าจะ graph ไหนเนี่ย Svelte เร็วสุดเกือบจะเสมอ

00:15:01.800 --> 00:15:05.033
อย่างเช่น graph ตัวนี้แล้วกัน ตัวอันนี้

00:15:06.700 --> 00:15:10.233
เราสร้าง 10,000 row จะเห็นว่าตัว React เนี่ย

00:15:10.300 --> 00:15:17.633
ใช้เวลา 1,400 ms มัน millisec เนาะ ก็คือ 1.4 วินาที

00:15:17.700 --> 00:15:25.033
ในการแบบว่าสร้างขนาด 10,000 แถวโดยที่เป็น HTML เปล่าๆ

00:15:26.500 --> 00:15:26.733
โอเค

00:15:27.700 --> 00:15:31.233
ทีนี้เนี่ย มันมีข้อเสียอยู่อย่างนึงของ virtual DOM

00:15:31.300 --> 00:15:34.433
ก็คือ virtual DOM เนี่ยมันเป็น runtime ก็เท่ากับว่า

00:15:34.900 --> 00:15:38.033
เราลองคิดภาพ สมมติเราจะใช้ตัว Node.js แล้วกันเนาะ

00:15:38.100 --> 00:15:40.433
เวลาจะใช้ Node.js เนี่ยสมมติเราเขียน script ง่ายๆ

00:15:40.500 --> 00:15:41.633
เลยแบบประมาณ 3-4 บรรทัด

00:15:41.700 --> 00:15:44.533
ก่อนที่เราจะใช้ได้เนี่ย เราจะต้องลงตัว Node.js

00:15:44.600 --> 00:15:46.633
ก่อนแล้วค่อยเอามา run เนาะ เพราะ Node.js เป็น runtime

00:15:46.700 --> 00:15:51.433
แต่ถ้าเราเขียนด้วย C หรือ Go หรือว่าเป็น Rust แล้วกัน

00:15:51.700 --> 00:15:52.833
ภาษาพวกเนี้ยเป็นภาษา compile

00:15:53.400 --> 00:15:55.433
เพราะฉะนั้นเนี่ยพวกเนี้ยมันสามารถที่จะแบบว่า build

00:15:56.500 --> 00:15:59.433
ออกมาแล้วก็ไม่จำเป็นต้องใช้ตัวภาษามันในการจัดการให้แล้ว

00:15:59.500 --> 00:16:01.533
เพราะว่ามันแบบ compile ทุกอย่างเป็น source code

00:16:01.600 --> 00:16:03.633
ที่สามารถเอาไป run ได้เลย ไม่จำเป็นต้องลงอะไรเพิ่ม

00:16:04.700 --> 00:16:06.633
เพราะฉะนั้น ทีนี้เนี่ย virtual DOM

00:16:06.700 --> 00:16:09.133
เนี่ยมันมีปัญหาอย่างนึงก็คือในการที่จะใช้ component

00:16:09.500 --> 00:16:10.833
ที่เขียนด้วย virtual DOM ได้เนี่ย

00:16:10.900 --> 00:16:13.633
มันจะต้องลงตัว library ของมันก่อน

00:16:13.700 --> 00:16:14.733
อย่างเช่นใน React เนาะ

00:16:14.800 --> 00:16:18.833
แล้วก็ อย่างที่เราเอามาเทียบแล้วกันว่าเรามี React

00:16:18.900 --> 00:16:21.233
component ตัวนึง แล้วเราจะใช้ React

00:16:21.300 --> 00:16:22.733
เนี่ยเขียน component อันนึงแล้วกัน

00:16:22.800 --> 00:16:25.133
สมมติเอาเป็น stateless card อันนึงแล้วกัน

00:16:25.200 --> 00:16:27.133
เป็นแบบ card material component ปกติเลย

00:16:27.200 --> 00:16:29.733
แบบว่าแบบใส่ภาพใส่ title อะไรได้

00:16:29.800 --> 00:16:32.333
ทีนี้เนี่ยเราลองดู bundle size ของ React แล้วกัน

00:16:32.400 --> 00:16:34.233
มันอยู่ประมาณที่ 64 KB

00:16:34.300 --> 00:16:37.133
แล้วถ้าสมมติว่าเราเอาตรงนี้เนี่ย เอา graph

00:16:37.400 --> 00:16:40.333
ตรงนี้เนี่ยไป run ใน codebase อื่นที่ไม่ได้ใช้ React เนี่ย

00:16:40.400 --> 00:16:42.733
เท่ากับว่าเราจะต้อง ship 64 KB

00:16:43.000 --> 00:16:44.733
บวกกับ bundle size ของ stateless card

00:16:44.800 --> 00:16:45.533
ที่เราเขียนเพิ่มขึ้นมา

00:16:45.600 --> 00:16:48.633
ซึ่งคำถามก็คือเราจะเอา virtual DOM

00:16:48.700 --> 00:16:51.833
ไปทำไมในเมื่อเราต้องการใช้แค่ component เดียว

00:16:53.400 --> 00:16:56.633
ตัว virtual DOM เนี่ยมันไม่ใช่ว่าไม่ดีนะ

00:16:56.700 --> 00:17:00.133
แต่ว่ามันมี อันนี้คือ graph อุปสงค์อุปทานนะ

00:17:00.200 --> 00:17:03.133
มันคือ มันจะมีปัญหาอยู่อย่างนึงก็คือ

00:17:03.200 --> 00:17:05.433
ยิ่งเราใช้ React เยอะเท่าไหร่เนี่ย

00:17:05.500 --> 00:17:07.032
มันจะยิ่งคุ้มค่ามากขึ้นเท่านั้น

00:17:07.099 --> 00:17:09.433
เพราะว่าถ้าเราเขียนแค่แบบว่า Hello World ธรรมดา 1

00:17:09.800 --> 00:17:11.233
หน้าเนี่ย มันจะ ship bundle size มา 64

00:17:11.700 --> 00:17:14.032
แต่ว่าถ้าเราเขียนมากขึ้นๆ เนี่ย

00:17:14.099 --> 00:17:15.433
ตัว bundle size ตรงเนี้ยมันจะหาย

00:17:15.700 --> 00:17:18.633
มันจะแบบว่าแทบจะน้อยกว่า code ที่เราเขียนด้วยซ้ำ

00:17:18.900 --> 00:17:23.333
ทำให้แบบว่ามันได้ graph ที่แบบว่ามันมีความน่าคุ้ม

00:17:23.400 --> 00:17:24.133
ที่จะแบบว่าใช้มากกว่า

00:17:24.200 --> 00:17:27.733
ทีนี้เนี่ย แต่ปัญหาก็คือ ตัว Svelte เนี่ย

00:17:27.800 --> 00:17:28.833
มันไม่ได้มี runtime

00:17:28.900 --> 00:17:30.533
เพราะฉะนั้นเนี่ยไม่ว่าเราจะเขียนน้อยเขียนเยอะเนี่ย

00:17:30.600 --> 00:17:32.633
มันก็ตัว effort มันไม่ต่างกัน

00:17:32.700 --> 00:17:34.233
ตัว performance ไม่ต่างกันเลย

00:17:34.300 --> 00:17:38.933
มันมีปัญหาอีกอย่างนึงก็คือในการที่เรา ship runtime

00:17:39.000 --> 00:17:41.133
ทั้งหมดเนี่ย มันขนาดมันใหญ่มาก

00:17:41.200 --> 00:17:42.733
แล้วบางอย่างเราไม่จำเป็นต้องใช้

00:17:42.800 --> 00:17:45.233
อย่างเช่น เราเขียน Node.js นึงแบบว่า CLI ปกติ

00:17:45.300 --> 00:17:46.633
แค่แบบ fetch ของปกติเลย

00:17:46.700 --> 00:17:48.833
แล้วเราต้องแบบ install Node.js มันก็ไม่ใช่เรื่อง

00:17:48.900 --> 00:17:51.533
ทำไมเราไม่แค่แบบว่าใช้แบบภาษา compile

00:17:51.600 --> 00:17:54.433
หรือใช้ shell script ก็ได้ เขียนอะไรง่ายๆ

00:17:55.000 --> 00:17:58.033
แต่ว่าตัว Svelte เนี่ยมันไม่มี runtime เลย

00:17:58.100 --> 00:18:04.133
คำถามก็คือ แป๊บนึงนะ โอเค ทำไม Svelte

00:18:04.200 --> 00:18:05.333
มันถึงไม่มี runtime ใช่มั้ย

00:18:05.400 --> 00:18:08.633
ตัว Svelte เนี่ยมันไม่มี runtime เนาะ

00:18:08.700 --> 00:18:10.133
เพราะฉะนั้น ขอแป๊บนึงนะ

00:18:10.200 --> 00:18:12.933
เหมือนว่าสไลด์จะหลุดแป๊บเดียว

00:18:13.000 --> 00:18:13.233
โอเค

00:18:14.600 --> 00:18:16.533
ตัว Svelte เนี่ยมันไม่มี runtime

00:18:16.600 --> 00:18:19.733
เพราะว่าเหมือนที่พี่ speaker เมื่อกี้พูดมาก่อนเนาะ

00:18:19.800 --> 00:18:22.833
ก็คือตัว Svelte เนี่ย มันไม่ได้ใช้ virtual DOM

00:18:22.900 --> 00:18:24.833
แต่ว่ามันใช้ compiler ในการเช็กว่า

00:18:24.900 --> 00:18:28.233
ในการ mutate DOM 1 รอบเนี่ย

00:18:28.300 --> 00:18:30.533
ในการ update DOM เนี่ย มันจะต้องใช้อะไรบ้าง

00:18:30.600 --> 00:18:33.333
แล้วมันจะใช้ compiler ในการตัดสินใจว่า

00:18:34.000 --> 00:18:35.733
มันค่อยๆ mutate DOM ไปเรื่อยๆ

00:18:35.800 --> 00:18:38.633
เพราะฉะนั้นเนี่ย ยิ่งสมมติว่าเราใช้ stateless เนี่ย

00:18:38.700 --> 00:18:40.233
เรามันก็จะไม่มีการ mutate DOM เลย

00:18:40.300 --> 00:18:41.433
ตัว compiler มันก็จะรู้ว่าโอเค

00:18:41.500 --> 00:18:42.733
เราไม่จำเป็นต้อง mutate อะไร

00:18:42.800 --> 00:18:45.433
ตัว Svelte เนี่ยมันจะ compile ทุกอย่างไปเป็นแบบว่า

00:18:45.500 --> 00:18:47.633
document.getElementById แล้วก็แบบว่า text node

00:18:47.700 --> 00:18:50.533
แล้วก็แบบ move insert insert child อะไรพวกนั้น

00:18:50.600 --> 00:18:53.133
ถ้าเราเขียน vanilla JS ตัว Svelte

00:18:53.200 --> 00:18:53.933
จะ compile เป็นอย่างงั้นเลย

00:18:54.000 --> 00:18:57.233
มันจะมี runtime เล็กๆ น้อยๆ ก็คือในการแบบว่า

00:18:58.200 --> 00:19:01.133
ย่อขนาดของตัว function อย่างเช่นแบบมี function

00:19:01.200 --> 00:19:03.133
ที่ยาวเช่น document.getElementById

00:19:03.200 --> 00:19:05.633
แล้วก็แบบย่อเป็น function แบบ d อะไรประมาณนี้

00:19:05.700 --> 00:19:08.633
ทำให้มันเหมือนว่าจะมี runtime แต่จริงๆ มันคือไม่มี runtime

00:19:08.700 --> 00:19:13.433
มันแค่แบบว่าทำให้ syntax มันสั้นลงในการใช้มากขึ้น

00:19:14.700 --> 00:19:16.333
เพราะฉะนั้นเนี่ย พอมันเป็นอย่างงี้เนี่ย

00:19:16.400 --> 00:19:18.233
ตัว Svelte เนี่ยมันเหมาะกับการที่จะเขียน

00:19:18.300 --> 00:19:22.333
อะไรที่มันเล็กๆ มาก อย่างเช่น component ที่จะใช้ในบางที่

00:19:23.600 --> 00:19:25.633
เพราะฉะนั้นเนี่ย ตัว component เนี่ย

00:19:25.700 --> 00:19:26.933
พอเราลองคิดถึงแล้วเนี่ย

00:19:28.800 --> 00:19:30.333
1 ทางเลือกที่จะใช้ component ใน web

00:19:30.400 --> 00:19:32.033
เนี่ยมันก็คือการใช้ web component

00:19:32.100 --> 00:19:34.233
ซึ่งตัว web component เนี่ยหลักๆ

00:19:34.300 --> 00:19:35.633
มันคือการทำ encapsulation

00:19:35.700 --> 00:19:36.933
มันคือจะเอา logic ทั้งหมด style ทั้งหมด

00:19:37.000 --> 00:19:41.233
ไป compile ไปเป็น HTML 1 tag ปกติเลย

00:19:41.300 --> 00:19:43.733
ถ้าคิดไม่ออกมันจะหน้าตาเป็นประมาณนี้ อันนี้คือตัว

00:19:44.100 --> 00:19:47.033
Polymer ซึ่งก็ตายไปแล้วแหละ

00:19:47.100 --> 00:19:48.833
แต่ว่ามันเอามาเป็น example ที่ได้ดี

00:19:48.900 --> 00:19:52.533
เนี่ยเห็นมั้ยว่าตัวเนี้ย ตัว HTML เนี่ยมันมีอยู่แค่นี้เอง

00:19:52.600 --> 00:19:55.833
มีแค่แบบ paper-dropdown paper-listbox

00:19:55.900 --> 00:19:59.033
แล้วก็ paper-item มันใช้แค่นี้ในการสร้างพวก list item

00:19:59.100 --> 00:19:59.933
ออกมาแบบนี้

00:20:00.000 --> 00:20:01.833
ซึ่งจริงๆ แล้วเนี่ยถ้าเราไม่ได้ใช้ web component เนี่ย

00:20:01.900 --> 00:20:04.033
เราก็ต้องแบบว่าเขียน JavaScript ในการ addEventListener

00:20:04.900 --> 00:20:07.133
แล้วก็แบบ animate ตัวมันเนาะ

00:20:07.200 --> 00:20:08.933
แล้วก็แบบ จะเห็นว่ามันมี CSS ด้วย

00:20:09.000 --> 00:20:10.733
ทั้งๆ ที่ในนี้แบบว่ามันแบบไม่ได้ใช้อะไรเลย

00:20:10.800 --> 00:20:13.433
มันเหมือนกับว่าใช้แค่ HTML เปล่าๆ ปกติเลย

00:20:13.500 --> 00:20:14.833
อันนี้คือ web component

00:20:15.200 --> 00:20:18.933
ซึ่งข้อดีของ web component ก็คือมัน support

00:20:19.400 --> 00:20:26.333
กับเกือบทุก library ก็ถ้าที่เรากังวลก็คงเป็นแบบว่า

00:20:26.400 --> 00:20:27.133
Angular React แล้วก็ Vue

00:20:27.200 --> 00:20:29.333
แต่ว่าจริงๆ แล้วเนี่ย web component

00:20:29.400 --> 00:20:31.633
มันแทบจะเท่ากับตัว HTML ปกติเลย

00:20:31.700 --> 00:20:33.533
ถ้าแค่มัน run HTML ได้แล้วก็ run JavaScript

00:20:33.600 --> 00:20:35.133
ได้มันก็เอาไปใช้ได้แล้ว

00:20:36.700 --> 00:20:39.833
เพราะฉะนั้นเนี่ย เดี๋ยวเราลอง proof concept ตรงนี้แล้วกัน

00:20:39.900 --> 00:20:42.933
ด้วยการเราลองมาสร้างมันเลยแล้วกันเนาะ สักอันนึง

00:20:43.000 --> 00:20:47.733
ตัว Svelte เนี่ย ถ้ากลัวว่ามันจะเขียนยากอะไรขนาดนั้น

00:20:47.800 --> 00:20:50.633
ตัว Svelte เนี่ยของ compiler มันมี flag อันนึง

00:20:50.700 --> 00:20:52.233
ที่ชื่อว่า customElement แล้วปรับเป็น true

00:20:52.300 --> 00:20:55.233
แล้วพอเรา build ออกมา มันก็จะได้เป็น web component เลย

00:20:55.300 --> 00:20:56.833
ไม่ต้องทำอะไรมาก มันทำแค่นี้เลย

00:20:56.900 --> 00:21:00.833
แล้วก็เดี๋ยวเราลอง Svelte component สั้นๆ

00:21:01.100 --> 00:21:02.233
สักอันขึ้นมาดูแล้วกันเนาะ

00:21:02.300 --> 00:21:05.133
อันนี้เป็น counter ปกติ 1 อัน เป็นแบบว่า counter เลย

00:21:05.200 --> 00:21:09.533
แบบว่าเหมือนแบบว่า view counter แบบกดเพิ่มค่า กดลดค่า

00:21:09.600 --> 00:21:12.833
ปกติเลยมีแค่ button เนาะ แล้วก็แบบมีแสดงค่า

00:21:12.900 --> 00:21:14.733
กดอันนึงเพิ่ม กดอันนึงออก

00:21:14.800 --> 00:21:17.833
วิธีการทำ web component ใน Svelte เนี่ย

00:21:17.900 --> 00:21:19.733
เราไม่จำเป็นต้องไปแต่งอะไรเลย

00:21:19.800 --> 00:21:22.033
มันมี built-in อยู่ในตัว Svelte แล้ว

00:21:22.800 --> 00:21:25.733
เราแค่เพิ่ม tag พิเศษอันนึงที่ชื่อว่า Svelte:options

00:21:26.000 --> 00:21:27.633
ปึ๊บ แล้วเราก็ตั้งชื่อ

00:21:27.900 --> 00:21:32.133
เราเอาเนี่ย ตัว tag เนี่ย ไปใส่ในตัว web component เมื่อกี้

00:21:32.200 --> 00:21:34.633
แล้วก็ตั้งชื่อ tag ก็คือแบบเราอยากให้เป็น HTML tag อะไร

00:21:34.700 --> 00:21:35.533
ก็ตั้งไป ปึ๊บ

00:21:35.600 --> 00:21:38.233
เพราะฉะนั้นเนี่ย สุดท้ายแล้วจะได้ออกมาเป็นแบบนี้

00:21:38.300 --> 00:21:40.833
แล้วเดี๋ยวเราลองเพิ่ม CSS สักหน่อยแล้วกัน

00:21:40.900 --> 00:21:44.133
ตัว web component เนี่ยมันมี selector พิเศษที่ชื่อว่า :host

00:21:44.200 --> 00:21:48.333
คือถ้าสังเกตเนี่ย ตัวเนี้ยเห็นมั้ยว่ามันไม่ได้มีอะไรครอบเลย

00:21:48.400 --> 00:21:50.033
แต่ว่าตัว layout เนี่ยเราสามารถจัดการ

00:21:50.100 --> 00:21:52.333
ปกติแล้วเนี่ยเราจะจัดการ layout ด้วยกันแบบว่า

00:21:53.400 --> 00:21:56.933
เอา children ไปใส่ใน div แล้วก็แบบตั้ง div เป็น flex

00:21:57.000 --> 00:21:58.033
ตั้งเป็น grid หรืออะไรก็ตาม

00:21:58.100 --> 00:22:02.233
ซึ่งตัว web component เนี่ยมันสามารถจัดการ

00:22:02.700 --> 00:22:04.433
ด้วยความที่แบบมันเป็น HTML tag อยู่แล้วเนี่ย

00:22:04.500 --> 00:22:07.933
เราสามารถเอา tag ตัวมันเองเนี่ย ไปเป็นตัว layout มันได้

00:22:08.000 --> 00:22:10.633
ด้วยการที่แบบเราเลือกแค่แบบว่า เลือกคำว่า :host

00:22:10.700 --> 00:22:12.233
แล้วก็ตั้งไปว่าเราอยากได้อะไร

00:22:12.300 --> 00:22:14.933
อันนี้ผมก็ตั้งเป็น flex แล้วก็แบบตั้งเป็น row ปกติเลย

00:22:15.000 --> 00:22:16.333
เหมือนกับ flex ปกติ

00:22:16.400 --> 00:22:18.933
แล้วเราก็หยิบเอาไปใช้ก็แค่แบบว่า paper-counter

00:22:19.000 --> 00:22:22.133
แล้วเราก็จะได้ component แบบหน้าตาแบบนี้ออกมา

00:22:22.200 --> 00:22:24.633
กดได้ปกติเลย เหมือนกับตัว component ปกติ

00:22:24.700 --> 00:22:28.433
แต่ว่า สิ่งที่เราต้องการในการเรียกใช้ก็แค่เรียก tag แค่นี้เอง

00:22:29.800 --> 00:22:33.033
ทีนี้เนี่ย เดี๋ยวเราลองเอาที่มันยากขึ้นมาหน่อยแล้วกัน

00:22:33.100 --> 00:22:36.533
ตัว component เนี่ย ปกติเราเขียน Svelte เนาะ

00:22:36.600 --> 00:22:38.933
เราก็จะสามารถรับ props ผ่าน props เข้าไปใน component ได้

00:22:39.000 --> 00:22:42.233
ตัววิธีในการแบบว่าผ่าน props เข้าไปใน web component เนี่ย

00:22:42.300 --> 00:22:43.833
ก็ทำเหมือน Svelte เลย คือแบบว่า

00:22:43.900 --> 00:22:46.733
เราแค่ export แล้วมันก็จะรับค่าเข้ามา ปึ๊บ

00:22:46.800 --> 00:22:50.333
แล้วก็จะได้เอาค่าเข้าไปใส่ในแบบนี้

00:22:50.400 --> 00:22:51.233
อันนี้เป็น web component เนาะ

00:22:51.300 --> 00:22:53.533
ถ้าเป็น Vue ถ้าเป็น Svelte ปกติแล้วแค่แบบว่า

00:22:53.600 --> 00:22:54.933
เขียนแบบ tag Svelte ปกติเลย

00:22:55.000 --> 00:22:56.933
เห็นมั้ยว่ามันแทบไม่ต่างกันเลย

00:22:57.000 --> 00:22:58.633
แล้วก็จะได้หน้าตา component แบบนี้ออกมา

00:23:00.200 --> 00:23:02.833
เห็นมั้ยว่ามันเขียนไม่ต่างจากตัว Svelte เลย

00:23:02.900 --> 00:23:05.033
แต่ว่ามันสามารถเอาไปแบบว่า compile ไปเป็นแบบ

00:23:05.100 --> 00:23:06.733
web component แล้วเราสามารถเอาตัว build

00:23:07.600 --> 00:23:08.933
ตรงนี้เนี่ยไปใช้ในที่อื่นได้

00:23:09.200 --> 00:23:12.233
อ่า มีอีกพิเศษอีกอันนึงก็คือตัว slot เนาะ

00:23:12.300 --> 00:23:14.133
ถ้าใครเคยเขียน Svelte มาก่อน

00:23:14.200 --> 00:23:16.333
อ่า ใน React จะไม่มีเนาะ

00:23:16.400 --> 00:23:18.433
ตัวนี้ถ้าเคย ใครเคยเขียน Vue มาก่อนเนี่ย

00:23:18.500 --> 00:23:20.833
เราสามารถผ่าน children เข้าไปแล้วบอกว่า

00:23:20.900 --> 00:23:23.033
เออ ให้มันไปโผล่ตรงนี้ด้วยการตั้งชื่อมันได้

00:23:23.100 --> 00:23:26.933
ซึ่งใน Svelte เนี่ยมันก็มีของที่เหมือนกับตัว Vue เลย

00:23:27.000 --> 00:23:28.733
ก็คือใช้ slot แล้วก็ตั้งชื่อมา

00:23:28.800 --> 00:23:32.933
ทีนี้เวลาเราจะเอา สมมุติอันนี้ผมมี component อันนึง layout เนาะ

00:23:33.000 --> 00:23:34.233
แล้วก็มี divider ตรงกลาง

00:23:34.300 --> 00:23:36.333
ถ้าผมต้องการแบบว่า เออ ผ่านอันนึงไปแบบว่า

00:23:36.400 --> 00:23:38.933
ให้มันอยู่ข้างบนตัว divider อันนึงอยู่ด้านล่าง

00:23:39.000 --> 00:23:41.333
ผมก็ตั้งชื่อ name="up" name="down" เข้ามา

00:23:41.400 --> 00:23:44.833
แล้วก็เอา component เข้าไปใส่ ก็จะเป็นประมาณนี้

00:23:44.900 --> 00:23:47.533
อันนี้ก็คือส่วน up อันนี้เป็นส่วน down

00:23:47.600 --> 00:23:49.933
ข้างบนจะเป็น card ข้างล่างเป็นตัว counter

00:23:50.000 --> 00:23:51.833
พอหน้าตาออกมาก็จะหน้าตาแบบนี้

00:23:51.900 --> 00:23:53.733
จะเห็นว่ามันมี divider อยู่ตรงกลาง

00:23:53.800 --> 00:23:56.233
แล้วก็แบบว่ามันเหมือนกับที่เราเขียนไว้เมื่อกี้เลย

00:23:56.300 --> 00:23:59.533
ซึ่งตัวนี้เนี่ย จริงๆ แล้วเนี่ย concept ตัว slot เนี่ย

00:23:59.600 --> 00:24:01.833
มันไม่ได้มาจากไหนเลย มันมาจากตัว web component

00:24:01.900 --> 00:24:05.233
web component เป็นที่แรกที่เอา propose ตัว syntax ตรงนี้เข้ามา

00:24:05.300 --> 00:24:07.833
แล้วตัว framework อย่างเช่น Vue เนี่ย

00:24:07.900 --> 00:24:08.833
ค่อยเอาไปใส่ในอีกทีนึง

00:24:08.900 --> 00:24:12.233
เพราะว่ามัน built-in มาในตัว web component เรียบร้อยแล้ว

00:24:12.300 --> 00:24:13.333
เราก็สามารถไปใช้ตรงๆ ได้เลย

00:24:13.800 --> 00:24:17.833
ทีนี้เนี่ยเผื่อเราไม่รู้ว่าขนาดมันอยู่ประมาณเท่าไหร่เนาะ

00:24:17.900 --> 00:24:18.833
เดี๋ยวเราเอาให้ดูแล้วกัน

00:24:18.900 --> 00:24:21.333
อันนี้คือ run ผ่าน rollup-bundle-analyzer

00:24:21.600 --> 00:24:24.533
ซึ่งถ้าเราลองดูแล้วเนี่ย bundle size ทั้งหมดเนี่ย

00:24:24.600 --> 00:24:25.833
เมื่อกี้ผมเขียน 3 component เนาะ

00:24:25.900 --> 00:24:29.333
ก็มี counter paper แล้วก็ตัว compound เนาะ

00:24:29.400 --> 00:24:30.833
ก็คือตัว layout ตรงนี้ ปึ๊บ

00:24:31.800 --> 00:24:33.833
จะเห็นว่าขนาดเนี่ยมันอยู่ประมาณเท่านี้

00:24:33.900 --> 00:24:35.433
แต่ถ้าไม่เก็ตว่ามันประมาณเท่าไหร่ก็

00:24:35.500 --> 00:24:37.233
จะอธิบายให้ฟังนิดนึงก็คือ

00:24:37.300 --> 00:24:39.233
ตัว Svelte เนี่ยเหมือนที่ผมบอกก็คือ

00:24:39.300 --> 00:24:41.033
มันจะต้องมี shorthand syntax นิดนึง

00:24:41.100 --> 00:24:43.433
ก็คือแบบว่าเป็น document.getElementById

00:24:43.500 --> 00:24:46.333
แล้วก็แบบย่อเป็นตัว function d หรือว่าอะไรประมาณนี้

00:24:46.400 --> 00:24:48.833
ซึ่งมันจะเอาเวลาที่แบบเราเรียกพวกนั้นเนี่ย

00:24:48.900 --> 00:24:51.833
มันจะ ตัว component ที่เราเรียกใช้เนี่ย

00:24:52.200 --> 00:24:54.833
มันจะเอาตัวมัน runtime เล็กๆ ของมันเข้ามา

00:24:54.900 --> 00:24:56.033
ซึ่งจริงๆ ก็ไม่ใช่ runtime หรอก

00:24:56.100 --> 00:24:58.233
แต่ถ้าเราลองเอาไปเทียบแล้วเนี่ย

00:24:58.300 --> 00:25:00.233
มันก็จะได้ประมาณอยู่ที่ประมาณ 3 kb

00:25:00.700 --> 00:25:02.533
แล้วก็ที่เหลือก็เป็นขนาดที่เราเขียนขึ้นมา

00:25:02.600 --> 00:25:05.533
อย่าลืมว่าตรงด้าน ด้านขวาเนี่ย component ด้านขวาเนี่ย

00:25:05.600 --> 00:25:07.533
มันคือ element ที่แบบ compile เสร็จแล้ว

00:25:07.600 --> 00:25:11.033
มันกลายเป็นแบบว่า deleteNode insertNode

00:25:11.100 --> 00:25:13.033
หรือว่าแบบ vanilla JavaScript เลย

00:25:13.100 --> 00:25:17.533
มันแค่แบบ เอา function เล็กๆ เข้ามาแบบว่า insertChild

00:25:17.600 --> 00:25:19.233
แล้วก็แบบย่อเป็น function แบบชื่อตัวเดียว

00:25:19.300 --> 00:25:22.533
อะไรประมาณนี้ ที่เราเห็นใน พวก terser ปกติเนาะ

00:25:22.600 --> 00:25:26.933
ทีนี้เนี่ยสมมุติว่าเราจะเอา component อันนึงไปใช้เนี่ย

00:25:27.000 --> 00:25:28.433
เราจะได้ bundle size ประมาณเท่าไหร่

00:25:29.000 --> 00:25:31.333
เราจะได้ bundle size ประมาณเท่านี้

00:25:31.400 --> 00:25:32.533
สมมุติผมเลือกใช้ paper-card

00:25:32.600 --> 00:25:35.533
เราก็จะได้ bundle size ประมาณ 4.11 kb

00:25:35.600 --> 00:25:38.433
แต่ว่าถ้าเราสมมุติเราใช้เป็น 2 อันเนี่ย

00:25:38.500 --> 00:25:40.533
มันก็ไม่ได้เพิ่มขึ้นมาเป็นคูณ 2 เนาะ

00:25:40.600 --> 00:25:43.033
เพราะว่าเราเลือกแค่ component อันนึงเข้ามา

00:25:43.100 --> 00:25:44.133
มันโหลด runtime เรียบร้อยแล้ว

00:25:44.200 --> 00:25:45.033
อะไรเรียบร้อยหมดแล้ว

00:25:45.100 --> 00:25:50.533
เพราะฉะนั้นเนี่ย ไม่ว่าเรา ขนาดเนี้ยเราใช้ bundle size 2 อันเนาะ

00:25:50.600 --> 00:25:51.733
ถ้าเราลองคิดเป็น React เนี่ย

00:25:51.800 --> 00:25:53.633
มันก็จะได้ bundle size อย่างน้อย 40 kb

00:25:53.700 --> 00:25:57.833
Angular ก็ได้อย่างน้อยแบบว่า 60 หรือมากกว่านั้นแน่ๆ

00:25:57.900 --> 00:26:02.733
แต่ว่า โอเค ทีนี้เราได้ตัว bundle ออกมาแล้ว

00:26:02.800 --> 00:26:04.033
แล้วเราจะใช้ยังไงใช่มั้ย

00:26:04.100 --> 00:26:06.933
โอเค ปกติเนี่ยเราก็ ทำเหมือนกับ

00:26:07.000 --> 00:26:11.633
ผมจะลองแบบว่าทำเป็นแบบ publish ขึ้นตัว npm แล้วกันเนาะ

00:26:11.700 --> 00:26:14.333
ปกติที่เราทำเนี่ยเราก็แค่ตั้ง package name

00:26:14.400 --> 00:26:17.433
แล้วก็ตั้งว่า พอ import เนี่ยให้ไป import ตรงไหนเนาะ

00:26:17.500 --> 00:26:20.633
ผมก็ไป import จากตัว build ออกมาเนาะ

00:26:20.700 --> 00:26:21.833
ก็ได้เป็น main.js ออกมา

00:26:22.200 --> 00:26:25.433
ส่วนวิธีเรียกใช้เนี่ยก็แค่ลง component แบบปกติเลย

00:26:25.500 --> 00:26:28.033
แล้วก็เรียก import ปึ๊บ

00:26:28.900 --> 00:26:29.333
พอเรา import เสร็จแล้วเนี่ย

00:26:29.400 --> 00:26:32.733
ตัว HTML เนี่ยมันจะ register ตัวมันเองตอนที่เราใช้

00:26:32.800 --> 00:26:35.033
เพราะฉะนั้นเนี่ยเดี๋ยวเราลองเอาเป็น

00:26:35.100 --> 00:26:36.733
เอาไปใส่ใน React แล้วกันเนาะ

00:26:36.800 --> 00:26:38.133
web component ตัวนี้ไปใส่ใน React ปึ๊บ

00:26:38.700 --> 00:26:42.033
อ่า อันนี้เผื่อไม่ เผื่ออันนี้ไม่เก็ต

00:26:42.100 --> 00:26:45.133
อันนี้มาจากตัว React component ที่เป็น jsx

00:26:45.200 --> 00:26:47.033
แต่ว่ามันจะเขียนเหมือน JavaScript

00:26:47.100 --> 00:26:50.033
เพราะฉะนั้นมันทำให้เหมือนแบบว่าเหมือนกับตัว HTML ปกติมาก

00:26:50.100 --> 00:26:52.133
แต่จะสังเกตได้ว่ามันมี export default ตรงนี้อยู่

00:26:52.200 --> 00:26:53.733
ที่ run เป็น function

00:26:53.800 --> 00:26:56.533
อ่า พอเราเรียกปกติ ปึ๊บ

00:26:56.900 --> 00:26:59.933
แล้วก็เอามา run เป็น ตัวหน้าเว็บเนาะ

00:27:00.000 --> 00:27:01.433
มันจะได้หน้าเป็นแบบประมาณนี้

00:27:01.500 --> 00:27:03.833
เผื่อใครไม่เชื่อว่ามันคือ React จริงรึเปล่า

00:27:03.900 --> 00:27:04.433
เดี๋ยว run ให้ดูเลย

00:27:17.900 --> 00:27:22.033
จะเห็นว่าตรงนี้เนี่ยเป็น อ่า ใช้ Vite ในการเขียนเนาะ

00:27:22.100 --> 00:27:25.633
dependency มันเป็น React ปกติ source อ่า App.tsx ปึ๊บ

00:27:26.000 --> 00:27:28.933
อันนี้ อ่า ตัวหน้าเว็บเนาะ

00:27:29.000 --> 00:27:33.033
เห็นว่าเรา import ตัว Svelte component มา ปึ๊บ แล้วก็เรียก

00:27:33.100 --> 00:27:34.833
เอ๊า เดี๋ยวนะ อันนี้เป็น native หรือว่า

00:27:34.900 --> 00:27:49.933
อ้อ แป๊บนึงนะ อันนี้น่าจะผิด ผิดอ่านแป๊บเดียว อ่า

00:27:50.000 --> 00:27:57.033
โอเค จะเห็นว่าเราลง react ปกติเลย เป็น dependency

00:27:57.400 --> 00:27:59.833
เป็น react แล้วก็ใช้ vite ในการ run เนาะ vite.js

00:28:00.600 --> 00:28:04.033
ทีนี้ถ้าเราลองเข้าไปดูใน source App.tsx เนี่ย

00:28:04.300 --> 00:28:08.133
เอาเป็นเต็มแล้วกันเนาะ เห็นว่าเรามีฟังก์ชัน App อันนึง

00:28:08.200 --> 00:28:10.933
ซึ่งเป็นแบบว่า react ปกติ เรามี useState มีอะไรปกติ

00:28:11.000 --> 00:28:14.933
อันนี้น่าจะลบออกไปละ แล้วเราก็เรียก import ตรงนี้

00:28:15.000 --> 00:28:19.233
import ตรงนี้เข้ามา แล้วก็จะใช้ web component ได้ปกติเลย

00:28:19.300 --> 00:28:22.233
เห็นว่ามันมี typescript support อะไรด้วย source alternate

00:28:22.500 --> 00:28:25.333
เดี๋ยวผมลองลบแล้วให้มันเดา type แล้วกันเนาะ

00:28:29.800 --> 00:28:35.533
เห็นได้ว่ามันมีตัวตรงเนี้ย เราสามารถเพิ่มตัว typescript

00:28:35.600 --> 00:28:37.633
declaration เข้าไปเองได้ด้วยกัน อย่างเช่นนี้

00:28:37.700 --> 00:28:41.033
เราสามารถเพิ่มเข้าไปในตัว environment.d.ts ได้

00:28:41.100 --> 00:28:44.533
อย่างเช่นผมใช้เป็น main.tsx แล้วก็ declare global

00:28:44.600 --> 00:28:47.033
แล้วสามารถเอา typescript ยัดใส่เข้าไปได้ปกติเลย

00:28:47.100 --> 00:28:50.633
ปึ๊บ แล้วจากนั้นเราก็ลอง run ดู

00:29:01.000 --> 00:29:04.033
เดี๋ยวเราลองเปิดตัว web visualizer แล้วกัน

00:29:04.100 --> 00:29:06.433
จะเห็นว่านี่มันไม่อัพเดท น่าจะติดแคช

00:29:06.500 --> 00:29:09.633
แต่ว่าเรามีเรียก dev tools มั้ยในนี้ ไม่มีฮะ

00:29:09.900 --> 00:29:13.333
แต่หลักๆ ก็คือถ้าเราลองไปดูตรง App.tsx เนาะ

00:29:13.400 --> 00:29:16.433
เอา main main แล้วกัน main.tsx เรา import ตัว component

00:29:16.500 --> 00:29:20.133
เมื่อกี้ ก็คือ App แล้วก็เอา react-dom createRoot เข้ามา

00:29:20.200 --> 00:29:22.933
แล้วจับ App เข้าไป มันก็จะ render react มา

00:29:23.000 --> 00:29:28.933
แล้วทีนี้เราลองไปดูตรงตัว browser เพิ่มๆ

00:29:29.000 --> 00:29:32.633
จะเห็นว่าตัว div root ตรงเนี้ย มัน run ตัว web component

00:29:32.700 --> 00:29:35.333
ได้ปกติเลย ก็คือเราเอา card เข้าไปใส่ ถ้าเราลองเปลี่ยน

00:29:35.400 --> 00:29:41.033
ตรงนี้เราจะเห็นได้ว่า shadow root มันคือตัว HTML

00:29:41.100 --> 00:29:43.333
ที่อยู่ด้านในเนาะ ทีเนี้ย เราจะเห็นได้ว่ามัน run

00:29:43.400 --> 00:29:45.733
เราแค่ใส่แค่ตรงเนี้ย มันก็จะได้แบบตัว component

00:29:45.800 --> 00:29:48.433
เมื่อกี้ออกมาเลย เราลองเปลี่ยนอันนี้แล้วกัน

00:29:48.500 --> 00:29:53.433
เปลี่ยนตัวอะไรดี ชายแล้วกันเนาะ เป็นอะไรก็ได้

00:29:53.500 --> 00:29:56.733
ก็จะเห็นว่ามันก็ไปอัพเดทตรงนี้ปกติเลย run ได้ปกติเลย

00:29:56.800 --> 00:30:00.133
ถ้าเราลองไปดูใน HTML ก็จะได้แบบว่าเห็นว่าเรา

00:30:00.500 --> 00:30:02.733
เอาใหม่ ต้องไป run ใน main เนาะ

00:30:02.800 --> 00:30:05.033
ก็อันนี้ก็คือตัวโค้ดที่ run ออกมาเนาะ

00:30:05.100 --> 00:30:06.033
ก็คือ web component ปกติเลย

00:30:06.700 --> 00:30:12.833
โอเค ทีนี้เราก็กลับไปที่ตัว keynote แล้วก็ run ต่อ

00:30:17.300 --> 00:30:22.233
ติดมั้ย โอเค ติด เราสามารถเอาตัว typescript

00:30:22.500 --> 00:30:25.433
ใส่เข้าไปได้แบบนี้ปกติเลย แป๊บนึงนะ

00:30:25.500 --> 00:30:31.633
ขอเดี๋ยว ชุดมันเยอะ ชุดมันชอบหลุดบ่อย

00:30:31.900 --> 00:30:34.833
โอเค ถ้าเราไม่แน่ใจว่าขนาดมันอยู่เท่าไหร่เนี่ย

00:30:34.900 --> 00:30:36.433
เดี๋ยวเราเอา bundle size ให้ดูแล้วกัน

00:30:36.500 --> 00:30:38.933
อันนี้คือ bundle size ของ react-dom อย่างเดียว

00:30:39.000 --> 00:30:43.033
อยู่ที่ 78 กิโลไบต์ แต่ถ้าเราลองเทียบกับ component

00:30:43.100 --> 00:30:44.833
เมื่อกี้ที่เรา import เข้ามา 3 อันเนี่ย

00:30:44.900 --> 00:30:47.433
bundle size รวมทั้งหมดแค่ 8% จาก 100%

00:30:48.000 --> 00:30:53.333
เราลองคิดดูนะ เรามี react component เขียนมา

00:30:53.400 --> 00:30:56.533
ใช้แบบ bundle size 78 ละ ยังไม่รวมตัว react ปกติ

00:30:56.600 --> 00:30:59.633
แล้วก็ตัว component ที่เขียนด้วย react อีกทีนึง

00:30:59.700 --> 00:31:02.633
แต่นี้เนี่ย เราเอา component ใส่เข้ามาใน

00:31:02.700 --> 00:31:04.833
component ใส่เข้ามา 3 อันแล้วเนี่ย

00:31:04.900 --> 00:31:06.633
มันก็ยังมีขนาดแค่นิดเดียวอยู่

00:31:09.400 --> 00:31:11.933
แค่นี้เนี่ยเราก็สามารถเอาตัว web component มาใส่ใน React

00:31:12.000 --> 00:31:14.233
ได้แล้ว เราสามารถเอาตัว web component ที่เขียนด้วย

00:31:14.300 --> 00:31:15.933
Svelte เนี่ย เอาไป reuse ที่ไหนก็ได้

00:31:16.000 --> 00:31:19.133
ซึ่งมันก็ run ได้ในทั้ง Angular, React แล้วก็ Vue

00:31:19.200 --> 00:31:22.633
แล้วก็ปกติเลย เหมือนที่เราต้องการจะทำ HTML เปล่าๆ

00:31:22.700 --> 00:31:23.433
ก็ run ได้เหมือนกัน

00:31:23.500 --> 00:31:26.133
ทีนี้เนี่ยจะมีอีกประมาณที่เหลือเนี่ย

00:31:26.200 --> 00:31:28.033
ที่มันไม่ค่อย practical เท่าไหร่

00:31:28.100 --> 00:31:30.233
แต่ว่าจะเอามาให้ดูแล้วกันเนาะ

00:31:31.000 --> 00:31:33.033
หลักๆ เนี่ย มีอีก 3 อันก็คือ

00:31:33.100 --> 00:31:35.333
อย่างแรกที่อยากให้แนะนำก็คือ mitosis

00:31:35.400 --> 00:31:38.233
เผื่อใครไม่รู้จัก mitosis ก็คือ mitosis

00:31:38.300 --> 00:31:41.933
เป็น library นึงที่ออกแบบมาให้เราเขียนโค้ดที่เดียว

00:31:42.000 --> 00:31:44.333
แล้ว compile เป็นภาษาอื่น compile เป็น library อื่นได้

00:31:44.600 --> 00:31:49.833
ถ้าใครรู้จักตัว ไม่แน่ใจมันชื่อโปรเจกต์อะไร

00:31:49.900 --> 00:31:52.533
แต่ว่ามันคือเราสามารถเขียนโค้ดเป็นภาษานึง

00:31:52.600 --> 00:31:53.733
แล้ว compile เป็นอีกภาษานึงได้

00:31:53.800 --> 00:31:55.633
ซึ่งตัว mitosis เนี่ยมันพยายามทำเหมือนกัน

00:31:55.700 --> 00:31:58.233
แต่ว่าเป็น web framework หรือ web library

00:31:58.300 --> 00:32:00.233
ซึ่งเราสามารถเขียนตัว Svelte เนี่ย

00:32:00.300 --> 00:32:01.933
compile ให้กลายเป็นอะไรก็ได้

00:32:02.000 --> 00:32:05.233
แต่ว่าหลักๆ เนี่ยก็คือจะมีตัว Angular, React แล้วก็ Vue

00:32:05.300 --> 00:32:06.233
ที่มันสามารถ compile ได้

00:32:06.300 --> 00:32:09.333
ในอนาคตเนี่ยตัว library ตัวนี้จะสามารถ compile

00:32:09.400 --> 00:32:12.633
เป็น SwiftUI กับตัว React Native ได้ด้วย

00:32:12.700 --> 00:32:14.733
แต่ว่า SwiftUI น่าจะยากกว่าเลย

00:32:15.400 --> 00:32:18.133
โอเค ถ้าเผื่อไม่แน่ใจว่ามันเป็นยังไง

00:32:18.200 --> 00:32:19.533
เราสามารถไปที่เว็บ mitosis

00:32:19.600 --> 00:32:21.333
แล้วมันจะมีตัว preview แบบนี้ออกมาได้

00:32:22.500 --> 00:32:26.033
ตัว mitosis เนี่ยมันเขียนเหมือนกับตัว React เป๊ะๆ เลย

00:32:26.100 --> 00:32:28.133
คือมี useState แล้วแค่แบบเปลี่ยนจากคำว่า React

00:32:28.200 --> 00:32:29.633
เป็น builder.io/mitosis

00:32:29.700 --> 00:32:32.833
จะสังเกตว่ามันเป็น JSX ปกติ มี useState ปกติ

00:32:32.900 --> 00:32:36.233
เขียนแบบว่าทุกอย่างปกติเหมือนตัว React เป๊ะๆ เลย

00:32:36.300 --> 00:32:37.733
แล้ว compile เป็นภาษาอื่นได้

00:32:37.800 --> 00:32:40.533
ซึ่งในนี้เนี่ยจะมีตัว Vue, React, Angular, Svelte,

00:32:40.600 --> 00:32:41.133
React Native, Swift

00:32:41.200 --> 00:32:46.133
โอเค ก็หลักๆ ก็ประมาณนี้

00:32:46.200 --> 00:32:49.633
แต่ว่าข้อเสียของมันก็คือมันไม่ค่อย practical สักเท่าไหร่

00:32:49.700 --> 00:32:53.733
เพราะว่าอย่างแรกเนี่ย มี issue ในหน้า GitHub เยอะมาก

00:32:53.800 --> 00:32:56.833
ซึ่ง issue บางอย่างเนี่ยมันก็ค่อนข้างที่จะ basic มาก

00:32:56.900 --> 00:33:02.733
อย่างเช่น เราไม่ได้ใส่ฟังก์ชันใน Svelte

00:33:02.800 --> 00:33:04.733
ไม่ได้แบบเป็น stateless Svelte

00:33:04.800 --> 00:33:05.933
มันก็ compile ไม่ผ่าน

00:33:06.000 --> 00:33:11.233
หรือว่าเป็น compile แล้วแบบ type ก็ import ไม่ขึ้น

00:33:11.300 --> 00:33:14.233
ประมาณนี้ มันทำให้มันยังไม่ค่อย practical เท่าไหร่

00:33:14.300 --> 00:33:16.833
แต่ว่ามันเป็นอะไรที่ค่อนข้างน่าสนใจมาก

00:33:16.900 --> 00:33:18.733
ซึ่งในอนาคตก็คงคิดว่ามันน่าจะดีขึ้น

00:33:18.800 --> 00:33:21.233
แล้วก็น่าจะช่วยหลายๆ ที่ได้เยอะ

00:33:21.300 --> 00:33:23.333
เวลาใช้ใน monorepo หรือเอาแบบว่าต้องการแบบ

00:33:23.400 --> 00:33:25.633
เอาเขียนที่นึงไป run ทุกที่เลย

00:33:25.700 --> 00:33:29.533
อย่างที่ 3 ก็คือเหมือนที่ Astro.js

00:33:30.000 --> 00:33:32.633
ก็เหมือนที่ speaker คนแรกพูดก็คือ

00:33:32.700 --> 00:33:35.333
ตัวตอนที่เขาเขียนเนี่ย เขาไม่ได้เขียนด้วย Svelte

00:33:35.400 --> 00:33:36.133
แต่เขาใช้ Astro

00:33:36.200 --> 00:33:39.533
Astro เนี่ยเป็น library นึงที่ทำให้เราสามารถ

00:33:39.600 --> 00:33:43.933
เอา library ประมาณ 4-5 library เข้ามา run

00:33:44.000 --> 00:33:44.533
เป็นที่เดียวกันได้

00:33:44.600 --> 00:33:48.233
แล้ว compile เป็น DOM แล้วก็ทำ run JavaScript ปกติได้เลย

00:33:48.300 --> 00:33:50.933
ซึ่งตัว Astro เนี่ยเราสามารถ import Svelte,

00:33:51.000 --> 00:33:53.333
import React แล้วก็ import Vue

00:33:53.400 --> 00:33:54.633
แล้วก็เอามาใช้ปกติได้เลย

00:33:54.700 --> 00:33:55.933
เหมือนกับไม่มีอะไรเกิดขึ้น

00:33:56.000 --> 00:33:58.733
แต่ว่ามันแค่แบบเรา import เข้ามาแล้วใช้ได้ตรงๆ เลย

00:33:58.800 --> 00:34:03.433
แต่ว่าในตอนนี้เนี่ยมันยังไม่ค่อย practical เท่าไหร่

00:34:03.500 --> 00:34:05.033
จากประสบการณ์ที่ตัวเองเคยใช้มา

00:34:05.100 --> 00:34:09.533
ก็มันจะมีปัญหาอีกอย่างนึงก็คือ Astro เนี่ยปัญหา

00:34:10.100 --> 00:34:12.132
อย่างแรกก็คือ goal ของ Astro เนี่ย

00:34:12.199 --> 00:34:14.632
เขาไม่ได้ต้องการที่จะ run lib ทั้งหมดบนนั้น

00:34:14.699 --> 00:34:18.333
แต่ว่าจุดประสงค์ Astro เนี่ยคือ

00:34:18.400 --> 00:34:21.433
เขาต้องการที่จะเอา import component เข้ามา

00:34:21.500 --> 00:34:23.733
ตัด JavaScript ทุกอย่างออก เป็น HTML เพียวๆ

00:34:23.800 --> 00:34:25.132
แล้วก็ run อยู่บนนั้น

00:34:25.199 --> 00:34:30.533
ซึ่งมันทำให้แบบว่ามัน ความ complex ของ Astro เนี่ย

00:34:30.600 --> 00:34:33.033
มันไม่ได้แบบว่าสร้างมาเพื่อให้แบบ run ทุกที่

00:34:33.100 --> 00:34:34.533
run แบบว่าตัว component ได้

00:34:34.600 --> 00:34:37.533
แต่แค่แบบว่าตัด component แล้วก็เอา HTML เข้ามาใส่ได้

00:34:37.600 --> 00:34:40.233
แต่ว่าตอนนี้เนี่ยมันก็สามารถ run JavaScript ได้

00:34:40.300 --> 00:34:43.433
ซึ่งมันก็มีปัญหานิดหน่อยก็คือมัน run ไม่ตรงบ้าง

00:34:43.500 --> 00:34:45.733
เพราะฉะนั้นเนี่ยเวลาเราใช้ Astro เนี่ย

00:34:45.800 --> 00:34:48.132
มันจะมีข้อเสียตามมาก็คือ

00:34:48.199 --> 00:34:50.433
เราใช้ client-side routing ไม่ได้

00:34:50.500 --> 00:34:52.433
อย่างเช่นแบบใน React ก็แบบใช้ React Router,

00:34:52.500 --> 00:34:54.733
Vue ก็ Vue Router พวกนี้เราไม่สามารถใช้ได้

00:34:55.300 --> 00:34:56.933
state management ก็ใช้ไม่ได้

00:34:57.000 --> 00:34:59.133
เพราะว่าทุกอย่างถูก treat เป็น HTML ปกติ

00:34:59.200 --> 00:35:01.433
SSR ก็ตอนนี้ยังไม่ support

00:35:01.500 --> 00:35:03.433
แต่ว่ามี plan ว่าจะ support อีก version 2 version

00:35:03.500 --> 00:35:06.233
แล้วก็เราไม่สามารถใช้ dev tools ตรงๆ ได้

00:35:06.300 --> 00:35:07.733
อย่างเช่นเราใช้ React dev tools ใช้ไม่ได้

00:35:07.800 --> 00:35:08.833
ใช้ Vue dev tools ใช้ไม่ได้

00:35:08.900 --> 00:35:10.233
Svelte dev tools ก็ไม่ได้

00:35:10.300 --> 00:35:14.833
แล้วก็บางทีเนี่ยมันมีปัญหานิดนึงก็คือมัน render ไม่ถูก

00:35:14.900 --> 00:35:17.233
ซึ่งไอ้ตรงนี้เนี่ยมาจากปัญหาส่วนตัว

00:35:17.300 --> 00:35:20.533
ที่ตัวเองเคยเอา Astro แล้วก็ไปเขียนเป็น Astro

00:35:20.800 --> 00:35:25.333
แล้วก็มัน render HTML ไม่ถูก

00:35:25.400 --> 00:35:27.933
แล้วมันแบบพังไปเลยบางทีในบางเคส

00:35:28.000 --> 00:35:29.833
อันนี้เป็นเว็บที่เคยเขียนด้วย Astro

00:35:29.900 --> 00:35:33.333
มันคือ documentation ที่ผมเคยเขียนสำหรับ

00:35:33.400 --> 00:35:34.833
library ตัวนึงใน Flutter

00:35:34.900 --> 00:35:39.233
แต่ว่า migrate จาก Astro มาเป็น VuePress เรียบร้อยแล้ว

00:35:39.300 --> 00:35:41.133
เพราะว่า Astro มันปัญหาเยอะมาก

00:35:41.200 --> 00:35:43.833
ถึงแม้มันจะใช้ตัว component ได้หลายอันก็จริง

00:35:43.900 --> 00:35:45.833
แต่ว่าตอนนี้ปัญหามันยังเยอะอยู่

00:35:45.900 --> 00:35:47.433
แล้วก็ HTML ยัง render ไม่ถูก

00:35:48.300 --> 00:35:49.933
อันที่ 4 ค่อนข้างน่าสนใจก็คือ

00:35:50.000 --> 00:35:52.033
แทนที่เราจะใช้ library ตัวอื่นเนี่ย

00:35:52.100 --> 00:35:54.233
ทำไมเราไม่ใช้ Svelte ปกติไปเลยล่ะ

00:35:55.000 --> 00:35:58.233
ปกติเนี่ยเราใช้ Svelte เนี่ยเราทำยังไงถึงจะ

00:35:58.600 --> 00:35:59.533
เราถึงจะใช้ Svelte ได้

00:36:12.100 --> 00:36:13.833
ปึ๊บ โอเค เดี๋ยวๆ เหมือนสไลด์จะพังนิดหน่อย

00:36:13.900 --> 00:36:17.133
โอเค ไม่เป็นไร โอเค เอาเป็นว่าสมมติว่าเรา

00:36:17.900 --> 00:36:21.733
ถ้าเราลองคิดภาพดูนะ ถ้าเรา search ใน web component เนี่ย

00:36:21.800 --> 00:36:24.333
ใน Google เนี่ย result อันแรกที่เราเห็นก็คือ

00:36:24.400 --> 00:36:27.233
is web component dead ก็คือ web component

00:36:27.300 --> 00:36:30.933
เนี่ยตายไปรึยัง คำถามก็คือทำไมมันถึงขึ้นอย่างงี้เนาะ

00:36:31.000 --> 00:36:33.033
เพราะ web component เนี่ยมันเริ่มมาจากประมาณปี 2014

00:36:33.900 --> 00:36:37.833
มั้ง 2015 สร้างโดย Google กับ browser ทั้งหลาย

00:36:37.900 --> 00:36:39.933
เนี่ยพยายามที่จะผลักดัน web component ให้เป็น

00:36:40.000 --> 00:36:42.333
mainstream เนาะ แต่ว่าเห็นว่าตอนนี้เรา 2022

00:36:43.000 --> 00:36:44.933
แล้วก็แทบไม่มีใครใช้ web component อีกเลย

00:36:45.000 --> 00:36:47.233
นอกจากเอามาทำให้มัน reusable

00:36:47.300 --> 00:36:50.233
ทำให้แบบว่าเราลอง search เนี่ย จะเห็นว่า web component

00:36:50.300 --> 00:36:53.333
มันตายแล้วแหละ เพราะฉะนั้นเราจะไปใช้ทำไมล่ะ

00:36:54.100 --> 00:36:56.933
เอาเป็นว่าเราสมมติว่า เราลองสมมติสถานการณ์ที่เราบอกว่า

00:36:57.000 --> 00:36:59.933
เราเกลียด web component ไม่ว่ายังไงเราก็จะไม่ใช้

00:37:00.000 --> 00:37:03.933
web component แบบว่ายังไงก็ไม่ใช้เด็ดขาด

00:37:04.200 --> 00:37:08.833
แต่ว่าถ้าผมบอกว่าจริงๆ แล้วเนี่ยเราสามารถที่จะไม่ใช้

00:37:08.900 --> 00:37:11.133
web component แล้วเรายังสามารถใช้ Svelte ในที่อื่นได้

00:37:12.600 --> 00:37:15.833
ซึ่งคำถามก็คือเราทำยังไงถึงจะทำแบบนั้นได้เนาะ

00:37:15.900 --> 00:37:18.933
เราลองคิดภาพนะ ปกติเนี่ยเราสร้าง Svelte เนาะ

00:37:19.000 --> 00:37:22.033
component นึงเนี่ย เราก็ทำอย่างงี้เนาะ เป็น root

00:37:22.100 --> 00:37:24.933
เหมือน Vue ปกติเลย Vue ก็คงแบบหน้าตาประมาณนี้

00:37:25.000 --> 00:37:27.433
แล้วก็แบบว่าเพิ่ม tag เข้าไปแล้วก็ new app

00:37:27.500 --> 00:37:32.033
ถ้าเป็น React ก็ createRoot หรือว่า ReactDOM.render ปกติ

00:37:32.300 --> 00:37:36.333
ซึ่งคำถามก็คือในเมื่อเราสามารถเอา HTML tag

00:37:36.600 --> 00:37:37.533
เนี่ยแล้วเราก็ render มันนั้น

00:37:37.600 --> 00:37:41.533
ทำไมเราไม่แค่แบบทำเหมือน jQuery ที่แบบ select ตัว

00:37:41.600 --> 00:37:44.833
stateless บน library ที่เราใช้อย่างเช่นแบบ React เนาะ

00:37:44.900 --> 00:37:48.033
มีใครเคยใช้ React กับ React กับตัว jQuery มั้ย

00:37:48.100 --> 00:37:51.333
ถ้าไม่เคยมีก็คือมันจริงๆ มันใช้ได้นะ

00:37:51.400 --> 00:37:54.433
แต่ว่ามันไม่ควรใช้เท่าไหร่ เพราะว่าแล้วก็แบบ

00:37:54.700 --> 00:37:56.633
HTML select element แล้วก็แบบ run jQuery ปกติ

00:37:56.900 --> 00:37:59.733
แต่อย่างน้อยน่าจะมีคนเคยใช้ D3.js หรือว่า library

00:37:59.800 --> 00:38:01.933
อะไรแปลกๆ ที่ยังไม่เคยเขียนใน React หรือว่า Vue

00:38:02.000 --> 00:38:05.233
เมื่อก่อนได้ ซึ่งเราสามารถทำเหมือนกันได้โดยการใช้

00:38:05.300 --> 00:38:08.533
Svelte แล้วก็แค่แบบว่า import Svelte app

00:38:08.600 --> 00:38:11.233
แล้วก็ run บน HTML อันนึงบน React

00:38:11.600 --> 00:38:13.633
อันนี้เราจะสาธิตเป็น React แล้วกันเนาะ

00:38:13.700 --> 00:38:17.233
เพราะว่าปกติผมเขียน React มากกว่าเนาะ ถนัด React เนาะ

00:38:18.700 --> 00:38:21.033
งั้นเดี๋ยวเราลองเอา component อันนึงแล้วกัน

00:38:21.100 --> 00:38:23.833
อันนี้คือ component ตัว React ตัวนึงที่ผมเขียนขึ้นมา

00:38:23.900 --> 00:38:26.333
เพื่อ run ตัว Svelte component เมื่อกี้

00:38:26.400 --> 00:38:28.633
คือเราสร้าง component ตัวนึงชื่อ SvelteHost

00:38:28.700 --> 00:38:30.933
แล้วเราก็ render ตัว div ออกมา 1 อัน

00:38:31.000 --> 00:38:33.533
แล้วเราก็บอกว่าเรารับ component เข้ามา

00:38:33.600 --> 00:38:34.833
แล้วก็ให้มัน render บนนี้

00:38:34.900 --> 00:38:38.633
ซึ่งเราก็แค่ เราจะมั่นใจได้ไงว่าตัว div

00:38:38.700 --> 00:38:41.233
เนี่ยมันจะไม่เปลี่ยน เราก็แค่มั่นใจว่าเอา memo ไปใส่

00:38:41.300 --> 00:38:42.333
หรือว่าให้มันเป็น stateless ไปเลย

00:38:42.400 --> 00:38:45.133
เพราะฉะนั้นเนี่ย ไม่ว่าทำยังไงตรงนี้เนี่ยมันก็จะไม่เปลี่ยน

00:38:45.200 --> 00:38:47.633
ในเมื่อมันไม่เปลี่ยนแล้วเนี่ยเราก็สามารถเอา Svelte

00:38:47.700 --> 00:38:51.333
ไป run ปกติได้เลย ซึ่งก็เท่ากับว่าเราสามารถ run ได้ละ

00:38:51.400 --> 00:38:56.133
ทีนี้เนี่ยเราก็อาจจะเพิ่ม TypeScript เข้าไปหน่อย

00:38:56.200 --> 00:38:58.033
ก็เพิ่ม TypeScript support ให้มันเนี่ย

00:38:58.100 --> 00:39:01.233
มันแบบมี type auto infer type ได้

00:39:01.300 --> 00:39:03.633
แล้วก็ให้ TypeScript มันไม่ฟ้องเป็น any เนาะ

00:39:03.700 --> 00:39:05.633
ทีนี้เนี่ยเราก็ลองเอาไป run ดู

00:39:06.700 --> 00:39:08.533
ปึ๊บ เราก็จะได้หน้าเว็บแบบนี้ออกมา

00:39:08.600 --> 00:39:10.633
สมมติเราอยากได้หน้าเว็บแบบนี้เนาะ

00:39:10.700 --> 00:39:13.333
ตัว tag เนี่ยมันก็จะหน้าตาเป็นประมาณนี้

00:39:13.400 --> 00:39:15.433
เรา import paper-counter เมื่อกี้ที่เราเขียนใน

00:39:15.900 --> 00:39:18.433
web component แต่ว่าอันนี้เราเปลี่ยนนิดหน่อยเนาะ

00:39:18.500 --> 00:39:21.933
เป็น native เนาะ อันนี้มันจะไม่เหมือนกับตัว

00:39:22.000 --> 00:39:26.733
web component ที่เราใช้แบบว่าเป็น tag paper-counter แล้ว

00:39:26.800 --> 00:39:30.133
อันนี้มันแบบว่า compile เป็น native เป็น native Svelte ปกติ

00:39:30.200 --> 00:39:32.833
แล้วเราก็เอา component Svelte เนี่ยยัดเข้าไปในนี้

00:39:32.900 --> 00:39:34.633
ถ้าไม่แน่ใจว่ามันเป็นยังไงเนาะ

00:39:34.700 --> 00:39:36.933
ก็จะเห็นว่าตัว code ตรงนี้เนี่ยมันบอกว่า

00:39:37.000 --> 00:39:40.033
มัน new component ก็คือตรงเนี้ยเป็น syntax ของ Svelte

00:39:40.100 --> 00:39:41.333
ในการสร้าง root 1 อัน

00:39:41.400 --> 00:39:43.233
ซึ่งแน่นอนมันไม่ใช่ web component ละ

00:39:43.500 --> 00:39:45.833
เพราะว่ามัน web component มันไม่สามารถสร้าง root

00:39:45.900 --> 00:39:46.833
แบบ Svelte ปกติได้

00:39:46.900 --> 00:39:51.333
ปึ๊บ มันก็จะได้หน้าตาออกมาเป็นประมาณนี้

00:39:51.400 --> 00:39:53.133
ก็จะได้ counter ออกมา 1 อันเนาะ

00:39:53.200 --> 00:39:54.733
เมื่อกี้ผม import paper-counter เนาะ

00:39:55.300 --> 00:39:57.033
ก็ได้หน้าตาประมาณเป็นประมาณนี้

00:39:58.400 --> 00:40:02.933
ทีนี้เนี่ยมันมีปัญหานิดนึงก็คือในเมื่อเราทำแบบเมื่อกี้แล้วเนี่ย

00:40:03.000 --> 00:40:06.433
เราผ่าน props เข้าไปแล้วมันดัน props มันดันไม่แสดง

00:40:06.500 --> 00:40:09.733
คำถามก็คือทำไมล่ะ เราลองมาดู code ตรงนี้เนาะ

00:40:09.800 --> 00:40:12.033
จะเห็นว่าถ้าเราย้อนกลับไปเมื่อกี้

00:40:12.100 --> 00:40:16.933
ปึ๊บ อ่า ตรงนี้เนาะ เห็นว่าเรา import มาแค่ component

00:40:17.200 --> 00:40:18.733
อย่างเดียวแต่เราไม่ได้รับ props เข้ามา

00:40:19.300 --> 00:40:21.333
สิ่งที่เราต้องทำก็คือผ่าน props เข้าไป

00:40:21.400 --> 00:40:27.033
ปึ๊บ ผ่าน props เข้าไปเนาะ ปึ๊บ แล้วก็รับ props เข้ามา

00:40:27.100 --> 00:40:29.133
แล้วเอา props ทั้งหมดยัดเข้าไปใน props

00:40:29.200 --> 00:40:31.833
ของตัว Svelte อีกทีนึง ก็จะได้ props ผ่านเข้ามา

00:40:31.900 --> 00:40:34.533
ทีนี้เนี่ยมันจะมีปัญหานิดนึงก็คือ TypeScript

00:40:34.800 --> 00:40:37.133
เนี่ยมันจะฟ้องว่ามันไม่รู้จัก type นี้

00:40:37.200 --> 00:40:46.433
ซึ่งเราสามารถแก้ตรงนี้ได้ด้วยการเพิ่ม TypeScript

00:40:46.500 --> 00:40:49.733
import เข้ามา ปึ๊บ แล้วก็สร้าง type ขึ้นเพิ่มขึ้นมา

00:40:49.800 --> 00:40:52.333
แล้วก็บอกว่าเรารับ children เรารับ slot

00:40:52.400 --> 00:40:54.733
แล้วก็ที่น่าสนใจตรงนึงคือเราเพิ่ม generic เข้ามา

00:40:55.000 --> 00:40:57.333
เผื่อใครไม่คุ้นว่า generic คืออะไร

00:40:57.400 --> 00:40:59.633
generic มันเหมือนกับตัวแปรที่เราใส่เข้าไปในตัวฟังก์ชัน

00:40:59.700 --> 00:41:02.633
แล้วมันจะรับ type เข้ามา อะไรประมาณนั้น

00:41:02.700 --> 00:41:03.933
ก็เท่ากับว่าเวลาเราเรียกฟังก์ชันเนี่ย

00:41:04.000 --> 00:41:05.833
เราสามารถกำหนด type ให้มันได้ว่า

00:41:05.900 --> 00:41:07.133
เราจะเพิ่ม type อะไรเข้าไปบ้าง

00:41:07.600 --> 00:41:10.833
ทีนี้เนี่ยเราก็แค่เพิ่มตัว generic เข้ามา

00:41:10.900 --> 00:41:14.333
ปึ๊บ ยัดใส่ props generic ทียัดใส่ props

00:41:14.400 --> 00:41:15.833
ปึ๊บ TypeScript ก็จะไม่ฟ้องละ

00:41:15.900 --> 00:41:22.933
แต่ว่ามันจะ cursed นิดนึง คือในนี้มีใครรู้มั้ยว่าตัว React

00:41:23.000 --> 00:41:24.133
เนี่ยเราสามารถทำอย่างงี้ได้

00:41:24.400 --> 00:41:26.933
เราสามารถเอา component แล้วก็ยัด generic

00:41:27.000 --> 00:41:28.133
ใส่เข้าไปใน component ได้

00:41:28.200 --> 00:41:32.833
ซึ่งผมเขียน React มา 3 ปีแล้วเนี่ย

00:41:32.900 --> 00:41:35.633
ผมก็ยังไม่เคยเห็นใครทำท่านี้มาก่อน

00:41:35.700 --> 00:41:38.533
เพราะผมก็เพิ่งรู้ว่ามันทำอย่างงี้ได้ด้วย โอเค

00:41:40.200 --> 00:41:42.933
เราก็จะรันเคาน์เตอร์ออกมา ก็จะได้หน้าตาปกติเลย

00:41:43.000 --> 00:41:47.833
ทีนี้นี่มันมีปัญหานิดนึง ก็คือ props เนี่ย

00:41:47.900 --> 00:41:49.833
เวลาเราเปลี่ยนเนี่ย สมมุติเราใช้ state ใน React

00:41:49.900 --> 00:41:52.833
ผ่านเป็น props มันไม่อัพเดตอะ

00:41:53.700 --> 00:41:56.133
ผมลองเอาเคาน์เตอร์ขึ้นมา 1 อัน

00:41:56.200 --> 00:41:57.633
แล้วก็ผมสร้างเคาน์เตอร์ใน React ขึ้นมา

00:41:57.700 --> 00:42:00.233
แล้วก็สร้าง paper รับ prop ออกมาเนาะ

00:42:00.300 --> 00:42:03.533
หน้าตาก็จะเป็นประมาณนี้ เรามีเคาน์เตอร์ 1 อัน reducer

00:42:03.600 --> 00:42:07.233
พอกดฟังก์ชัน increase ก็จะเพิ่มค่าเคาน์เตอร์

00:42:07.300 --> 00:42:09.733
แล้วก็เอา button เข้ามาใส่เป็น local counter เนาะ

00:42:10.000 --> 00:42:12.733
เพราะฉะนั้นเนี่ย เวลาเรากด button ตัวนี้เนี่ย

00:42:12.800 --> 00:42:15.333
ตัวเคาน์เตอร์ก็จะค่อยๆ เพิ่ม 0 เป็น 1 เป็น 2 เป็น 3

00:42:16.300 --> 00:42:18.633
แล้วก็เพิ่มเคาน์เตอร์ตัวเดียวกันเนี่ย

00:42:18.700 --> 00:42:21.433
ใส่เข้าไปในตัว props ของตัว Svelte host เนาะ

00:42:22.500 --> 00:42:26.233
ปัญหาก็คือ สังเกตว่าตัว local counter ตรงนี้เนี่ย

00:42:26.300 --> 00:42:28.933
มันเป็น 4 แต่ว่า props ที่ผ่านเข้าไปตรงเนี้ย

00:42:29.000 --> 00:42:30.033
มันยังเป็น 0 อยู่

00:42:30.700 --> 00:42:35.933
คำถามก็คือมันเกิดอะไรขึ้น ทำไม props มันไม่อัพเดตหล่ะ

00:42:36.500 --> 00:42:39.833
มันเป็นเพราะว่า ถ้าเราลองกลับไปดูที่ code ของเราอีกทีนึงเนี่ย

00:42:39.900 --> 00:42:41.933
เราจะเห็นว่าเรารับ props เข้ามา

00:42:42.000 --> 00:42:45.133
แต่ว่าบน useEffect เนี่ย useEffect ก็คือ on mount

00:42:45.200 --> 00:42:47.933
มันคือบอกว่า useEffect เนี่ยคือบอกว่า

00:42:48.200 --> 00:42:50.333
พอเรารับ props มันรับ props เข้ามา

00:42:50.400 --> 00:42:52.933
แล้วมันจะรันใหม่อีก 1 รอบเมื่อไหร่ก็ได้

00:42:53.000 --> 00:42:54.733
เราสามารถผ่านเข้าไปที่ parameter ที่ 2

00:42:55.100 --> 00:42:56.733
คือตัว dependency ของมันได้

00:42:56.800 --> 00:42:59.533
จะสังเกตว่าเราใส่เป็น empty array

00:42:59.600 --> 00:43:03.033
ก็คือบอกว่าอันนี้เนี่ยจะรันแค่เฉพาะตอน on mount อย่างเดียว

00:43:03.100 --> 00:43:06.133
จะสังเกตว่า เราก็ผ่าน props เข้าไปแล้ว

00:43:06.200 --> 00:43:08.233
แต่พอ props มันอัพเดตใหม่เนี่ย ตัวอันนี้ก็ไม่รันใหม่

00:43:08.300 --> 00:43:10.233
ทำให้ตัว component มันไม่อัพเดต

00:43:10.600 --> 00:43:15.633
เราก็แค่เอา props เข้าไปใส่ในตัว useEffect เมื่อกี้เนาะ

00:43:16.500 --> 00:43:18.233
แต่ความพิเศษของ Svelte อย่างนึงก็คือ

00:43:18.300 --> 00:43:20.633
ในตัว new component เมื่อกี้เนี่ย

00:43:20.700 --> 00:43:23.333
เราสามารถ set props จากด้านนอกได้

00:43:23.400 --> 00:43:25.833
คือเราไม่จำเป็นจะต้อง access เข้าไปในตัว Svelte component

00:43:25.900 --> 00:43:28.633
แล้วก็บอกว่า อัพเดตใช้แบบ reactivity อัพเดตให้หน่อย

00:43:28.700 --> 00:43:33.833
เราสามารถที่จะใช้ฟังก์ชันที่ชื่อว่า .$size set ได้

00:43:33.900 --> 00:43:36.333
ซึ่งพอเราเรียกฟังก์ชันนี้ในตัว Svelte เนี่ย

00:43:36.400 --> 00:43:39.133
มันจะอัพเดต props ให้เองอัตโนมัติ

00:43:40.800 --> 00:43:44.433
เราก็แค่เก็บตัว component นึงที่เราสร้างเมื่อกี้เนาะ

00:43:44.900 --> 00:43:46.833
กลับเข้าไปใน variable ที่ชื่อ state ref

00:43:46.900 --> 00:43:55.033
แล้วก็บอกว่า พอมันสร้าง Svelte ขึ้นมาอันนึงปึ๊บ

00:43:55.100 --> 00:43:57.933
สร้าง Svelte component ในตอนแรกเนี่ยที่มันรันอันเนี้ย

00:43:58.000 --> 00:43:59.633
ตัว state ref จะเป็น null

00:43:59.700 --> 00:44:01.633
เพราะฉะนั้นก็คือมันก็จะมาตกที่ case ด้านล่าง

00:44:01.700 --> 00:44:03.533
ก็คือบอกว่า โอเค สร้าง component

00:44:03.600 --> 00:44:05.633
แต่ทีนี้นี่พอ props มันอัพเดตเนี่ย

00:44:05.700 --> 00:44:08.533
มันก็จะเช็คว่า ตัว state ref เนี่ยมันไม่ null แล้ว

00:44:08.600 --> 00:44:09.733
เพราะว่ามันมี component ของมันอยู่

00:44:09.800 --> 00:44:11.533
มันก็คือจำค่าตัว component ตรงนี้ไว้

00:44:11.600 --> 00:44:13.833
แล้วก็บอกว่า state ref แล้วก็อัพเดตไป

00:44:14.700 --> 00:44:16.333
เราก็จะได้หน้าตาเป็นประมาณนี้

00:44:16.800 --> 00:44:18.433
เราเห็นสังเกตว่าเรา local counter 5

00:44:18.700 --> 00:44:19.533
แล้วก็ component 5 เรียบร้อย

00:44:19.600 --> 00:44:24.233
แต่ทีนี้นี่ ปัญหาก็คือทั้งหมดเมื่อกี้เนี่ย ที่เราพูดเนี่ย

00:44:24.300 --> 00:44:29.033
คือเราสามารถแค่แบบว่า ตั้ง custom component เป็น true

00:44:29.100 --> 00:44:30.133
แล้วก็เอาไปรันได้เลย

00:44:30.200 --> 00:44:32.333
ไม่จำเป็นต้องสร้าง Svelte host

00:44:32.400 --> 00:44:33.533
ไม่จำเป็นต้องทำอะไรแปลกๆ

00:44:33.600 --> 00:44:34.833
ไม่จำเป็นต้องผ่าน generic เข้า React

00:44:34.900 --> 00:44:38.033
เราก็แค่ใช้ web component ก็ทำได้เรียบร้อยแล้ว

00:44:38.100 --> 00:44:40.733
ไม่ต้องทำอะไรยุ่งยากด้วย แถมรันได้ทุกที่ด้วย

00:44:41.300 --> 00:44:45.233
ปัญหาก็คือมันเทียบกันแล้ว performance ก็เท่าเดิม

00:44:45.300 --> 00:44:46.233
bundle size เท่าเดิม

00:44:46.300 --> 00:44:48.833
แต่ว่าพอเราทำแบบเมื่อกี้เนี่ย มันไม่มี encapsulation

00:44:49.200 --> 00:44:51.233
เราต้อง manual setup ทุกอย่างเอง

00:44:51.300 --> 00:44:52.733
แล้วก็ feature ก็หายไปเยอะด้วย

00:44:52.800 --> 00:44:56.033
อย่างเช่นตัว CSS เมื่อกี้ก็หายไป

00:44:56.100 --> 00:45:01.033
ตัว CSS host ก็หายไป encapsulation ไม่มี CSS ไม่มีอะไรแล้ว

00:45:01.300 --> 00:45:03.933
เพราะฉะนั้นเราก็ไม่สามารถทำท่าแบบนี้ได้

00:45:04.400 --> 00:45:06.033
เราต้องมั่นใจเองว่า class name เนี่ย

00:45:06.100 --> 00:45:08.533
มันจะไม่ไป conflict กับตัว code base ที่เราใช้อยู่

00:45:08.600 --> 00:45:13.333
แล้วก็ปัญหาต่อมาก็คือมันใช้ name slot ใน React ไม่ได้

00:45:13.400 --> 00:45:18.333
เพราะว่าใน React เนี่ยมันไม่มี name slot

00:45:18.400 --> 00:45:20.833
ส่วนใน Vue เนี่ย ปัญหาก็คือใน Vue เนี่ย

00:45:20.900 --> 00:45:24.833
slot ใน Vue มันพอใช้กับตัวท่าเมื่อกี้เนี่ย

00:45:24.900 --> 00:45:26.533
มันไม่สามารถที่จะ render ตัว slot ได้

00:45:26.600 --> 00:45:28.333
เพราะว่า props ที่รับเข้ามาเนี่ย

00:45:28.400 --> 00:45:30.933
มันเป็นตัวแปรที่ specific กับ Vue

00:45:31.000 --> 00:45:35.933
ซึ่งมันต้องใช้ Vue runtime ในการแปลเป็น HTML อีกทีนึง

00:45:37.300 --> 00:45:39.133
ถ้าเราลองดู code ตรงนี้เนี่ย

00:45:39.200 --> 00:45:41.633
อันนี้คือ code ที่เขียนด้วย Vue

00:45:41.700 --> 00:45:43.233
ตรงนี้มันเล็กไปนิดนึงเนาะ

00:45:43.300 --> 00:45:45.133
แต่ว่าจะสรุปให้ฟังง่ายๆ ก็คือ

00:45:45.200 --> 00:45:46.933
เราผ่าน component แบบเมื่อกี้แล้วเนี่ย

00:45:47.000 --> 00:45:48.333
ยัดเข้าไปใน Vue เนี่ย

00:45:48.400 --> 00:45:51.133
ไม่ว่าจะยัดอะไรเข้าไปเนี่ย ก็ children มันก็ไม่ออก

00:45:51.800 --> 00:45:54.433
ถ้าไม่แน่ใจว่ามันใช้อะไรจริงๆ

00:45:54.500 --> 00:45:57.133
เราก็แค่เปิด Wappalyzer ดูก็เห็นว่าใช้ Vue กับ Svelte อยู่

00:45:57.200 --> 00:45:58.433
เดี๋ยวมี demo ให้ดูนิดนึงด้วย

00:45:58.500 --> 00:46:01.733
เพราะฉะนั้นเนี่ยทุกอย่างมันอยู่ที่ความเมตตาของ lib เราแล้ว

00:46:01.800 --> 00:46:03.433
ว่า lib เรามันจะ support มากแค่ไหน

00:46:03.500 --> 00:46:06.033
สุดท้ายแล้วเนี่ยมันก็แค่

00:46:06.100 --> 00:46:08.133
เราไม่อยากให้มีปัญหามากวนใจ

00:46:08.200 --> 00:46:09.533
เราก็แค่ใช้ web component

00:46:09.600 --> 00:46:11.933
ถึงแม้ว่ามันจะเกิดอะไรขึ้นก็ตาม

00:46:12.000 --> 00:46:14.033
เราก็แค่แบบใช้เครื่องมือที่มันใช้ได้

00:46:14.100 --> 00:46:17.033
ไม่ว่าคนจะบอกว่าตายแล้ว เดี๋ยวยังไม่ตายก็มันไม่ใช่ปัญหา