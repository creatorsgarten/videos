WEBVTT - Generated by https://github.com/dtinth/subtitles

00:00:02.620 --> 00:00:05.933
This is a short topic
I want to share with you all.

00:00:08.000 --> 00:00:09.933
Hello everyone, my name is Thai.

00:00:12.000 --> 00:00:14.733
My topic for today’s lightning talk is

00:00:14.800 --> 00:00:17.933
The Magic of Signed Distance Functions.

00:00:18.000 --> 00:00:23.933
This is Creative Coding Meetup’s
web page on Eventpop.

00:00:24.000 --> 00:00:25.933
And this is the background image used.

00:00:26.000 --> 00:00:28.233
Of course, it’s made with code.

00:00:28.300 --> 00:00:29.933
But how many lines of code did it take?

00:00:32.000 --> 00:00:34.933
I think this image has a lot of effects.

00:00:35.000 --> 00:00:40.933
There are gradient, repeating patterns,
and an inner glow effect.

00:00:41.000 --> 00:00:45.293
As a web developer, I would think that
using HTML, CSS, Canvas, or SVG

00:00:45.360 --> 00:00:47.263
That’s gonna take a lot of code.

00:00:47.330 --> 00:00:49.933
But the main logic is only 7 lines.

00:00:50.000 --> 00:00:55.833
Before I knew about SDF,

00:00:55.900 --> 00:00:58.953
I saw see creating images using very
little code, my jaw dropped.

00:00:59.020 --> 00:01:02.013
I’ve never thought that just 7 lines
could create this kind of image.

00:01:02.080 --> 00:01:02.933
It was magic to me

00:01:03.000 --> 00:01:05.933
until I studied it — and I want to
share it with you all today.

00:01:06.000 --> 00:01:07.933
But what is this code?
Let’s take a look.

00:01:08.000 --> 00:01:11.933
This code is called Fragment Shader,
written in GLSL language.

00:01:12.000 --> 00:01:13.933
It stands for OpenGL Shading Language.

00:01:14.000 --> 00:01:18.933
We can write Fragment Shader in VS Code
by using an extension called glslCanvas.

00:01:19.000 --> 00:01:25.333
The role of Fragment Shader is to
calculate for each pixel on the screen,

00:01:25.400 --> 00:01:28.933
what color the GPU should paint on it.

00:01:29.000 --> 00:01:32.933
The input is the <i>glFragCoord</i> variable.

00:01:33.000 --> 00:01:35.933
The output is the <i>glFragColor</i> variable.

00:01:36.000 --> 00:01:39.933
The GPU will run our code once per pixel.

00:01:40.000 --> 00:01:42.933
But since it’s a GPU, it can process
multiple pixels at the same time.

00:01:43.000 --> 00:01:48.933
Once the code is run, the color inside
<i>glFragColor</i> will be shown on the screen.

00:01:49.000 --> 00:01:55.933
For this image, I used the concept of
Signed Distance Functions.

00:01:56.000 --> 00:01:58.933
I think this concept is very powerful.

00:01:59.000 --> 00:02:00.933
In this session we will go very quickly.

00:02:01.000 --> 00:02:03.933
If you don’t understand
all the details, don’t worry!

00:02:04.000 --> 00:02:06.933
My intention is for the details to
pass through your eyes and ears once.

00:02:07.000 --> 00:02:09.933
It may help make it easier to understand
when you study in more detail.

00:02:10.000 --> 00:02:11.933
Let’s take a look at what it is.

00:02:12.000 --> 00:02:13.933
Let’s say we have a shape.

00:02:14.000 --> 00:02:19.933
For example, we want to draw this circle.

00:02:20.000 --> 00:02:22.933
What we want to draw is called <i>scene</i>.

00:02:23.000 --> 00:02:24.933
What is SDF?

00:02:25.000 --> 00:02:28.173
SDF is a function that receives a point

00:02:28.240 --> 00:02:31.933
and returns a distance between
that point and the scene.

00:02:32.000 --> 00:02:35.233
For example, this point

00:02:35.300 --> 00:02:38.803
You see that it’s 2 units away
from the edge of the circle.

00:02:38.870 --> 00:02:42.933
If our SDF receives this point as input,
it must return a distance of 2.

00:02:43.000 --> 00:02:44.933
What about this point?

00:02:45.000 --> 00:02:46.163
Audience: 1

00:02:46.230 --> 00:02:47.383
Ah! What about this point?

00:02:47.450 --> 00:02:48.303
Audience: 0

00:02:48.370 --> 00:02:50.033
Okay! What about this point?

00:02:50.100 --> 00:02:50.933
Audience: -1

00:02:51.000 --> 00:02:52.473
That’s right!

00:02:52.540 --> 00:02:54.933
If the point is inside the shape,
the distance is negative.

00:02:55.000 --> 00:02:58.933
Hence, *signed* distance.
It can be positive or negative.

00:02:59.000 --> 00:03:02.933
So, this is what the SDF function does.

00:03:03.000 --> 00:03:06.933
Now, how can we write
the SDF for this circle?

00:03:07.000 --> 00:03:10.933
The circle has a centre point *(h,k)*
and a radius *r*.

00:03:11.000 --> 00:03:13.933
If we want to know how far a point (x,y)
is from the edge of that circle,

00:03:14.000 --> 00:03:15.933
we can use the formula
we learned from school:

00:03:16.000 --> 00:03:19.933
x-h squared + y-k squared,
all square rooted

00:03:20.000 --> 00:03:24.933
Remember the analytical geometry
class in the fourth grade?

00:03:25.000 --> 00:03:28.933
Subtract out the radius,
and you get the SDF for this circle.

00:03:29.000 --> 00:03:31.933
But don’t you think that
this formula looks quite scary?

00:03:32.000 --> 00:03:33.933
Let’s just simply call
these points <i>C</i> and <i>P</i>.

00:03:34.000 --> 00:03:36.933
Then we have a vector <i>CP</i>.

00:03:37.000 --> 00:03:38.933
Now we can just write our SDF like this.

00:03:39.000 --> 00:03:40.933
It becomes easier to understand —

00:03:41.000 --> 00:03:43.933
If the point <i>P</i> is outside the circle,

00:03:44.000 --> 00:03:45.933
this <i>CP</i> vector will be
longer than the radius.

00:03:46.000 --> 00:03:47.933
The result is a positive number.

00:03:48.000 --> 00:03:49.933
But if this point moves inside,

00:03:50.000 --> 00:03:53.933
then <i>CP</i> will be shorter than the radius,
and we get a negative number.

00:03:54.000 --> 00:03:56.933
As a programmer, using single-letter
name isn’t great for readability.

00:03:57.000 --> 00:03:59.933
We should name it in a way
that is easy to understand.

00:04:00.000 --> 00:04:02.933
When we write it as GLSL,
we get a code like this.

00:04:03.000 --> 00:04:06.933
Finally, if we know the exact
values for the centre and radius,

00:04:07.000 --> 00:04:09.933
we can “hardcode” it in
to shorten the code.

00:04:10.000 --> 00:04:11.933
That’s all we need.

00:04:12.000 --> 00:04:15.933
Now we can represent this circle
with this simple formula.

00:04:16.000 --> 00:04:17.933
In Inigo Quilez’s website,

00:04:18.000 --> 00:04:21.933
there are many formulas of SDF to study.

00:04:22.000 --> 00:04:25.933
You can check them out.

00:04:26.000 --> 00:04:28.933
Now that we have the SDF,
what can we do with it?

00:04:29.000 --> 00:04:32.933
We can check the value of SDF
at various points

00:04:33.000 --> 00:04:36.933
and map the distance to the color

00:04:37.000 --> 00:04:39.933
and fill in the color for that point.

00:04:40.000 --> 00:04:41.933
If we do the same thing
with the whole picture,

00:04:42.000 --> 00:04:43.933
We will get a rendered circle like this.

00:04:44.000 --> 00:04:46.933
We can see that a circle can be
represented with a very short code.

00:04:47.000 --> 00:04:50.933
The other block of code maps
the distance to the color.

00:04:51.000 --> 00:04:56.933
With a distance value,
we can create the desired shading.

00:04:57.000 --> 00:05:01.933
The next cool thing about SDFs is that
we can compose them together.

00:05:02.000 --> 00:05:03.933
Suppose that we have two circles,

00:05:04.000 --> 00:05:05.933
each circle has its own SDF.

00:05:06.000 --> 00:05:08.933
This is the distance from A,
and this is the distance from B.

00:05:09.000 --> 00:05:12.933
If we find the minimum of two distances,

00:05:13.000 --> 00:05:15.453
what do you think will happen?

00:05:15.520 --> 00:05:16.463
Audience: Combine?

00:05:16.530 --> 00:05:17.933
Yes, we will get this picture.

00:05:18.000 --> 00:05:22.163
It’s like the union operation.

00:05:22.230 --> 00:05:24.053
How about finding the maximum?

00:05:24.120 --> 00:05:24.963
Audience: Intersect?

00:05:25.030 --> 00:05:26.933
We will get this picture,
like an intersection.

00:05:27.000 --> 00:05:32.933
We can see that many simple SDFs
can be combined with simple operations

00:05:33.000 --> 00:05:34.933
to create a variery of images.

00:05:35.000 --> 00:05:36.933
For example, if we flip
the sign of the SDF,

00:05:37.000 --> 00:05:39.933
the inside and outside will be swapped.

00:05:40.000 --> 00:05:46.933
Combine <i>-</i> and <i>max</i>, we get this.
It represents the area in A but not in B.

00:05:47.000 --> 00:05:50.933
Do the same thing with the other side,
we will get this picture.

00:05:51.000 --> 00:05:54.933
If we subtract from the distance,
the scene will expand.

00:05:55.000 --> 00:05:59.933
If we add to the distance,
the scene will contract.

00:06:00.000 --> 00:06:05.933
There are many GLSL functions
you can find online

00:06:06.000 --> 00:06:10.933
For example, the <i>smoothMin</i> function
is a simple function like <i>min</i>

00:06:11.000 --> 00:06:14.163
But when we use it with SDFs,

00:06:14.230 --> 00:06:18.933
the edges are more smoothed out.

00:06:19.000 --> 00:06:24.563
If we take the absolute value of a
distance and subtract a little from it

00:06:24.630 --> 00:06:26.933
the solid scene will become an outline.

00:06:27.000 --> 00:06:30.933
In summary, there are
many things we can do.

00:06:31.000 --> 00:06:35.933
And as mentioned previously,
we can shade it however we want.

00:06:36.000 --> 00:06:38.933
Now let’s draw this picture.

00:06:39.000 --> 00:06:41.933
I will start with this small circle <i>A</i>.

00:06:42.000 --> 00:06:43.933
And a bigger circle <i>B</i>.

00:06:44.000 --> 00:06:46.933
Then I have this vertical bar <i>C</i>.

00:06:47.000 --> 00:06:48.933
And a horizontal bar <i>D</i>.

00:06:49.000 --> 00:06:50.933
Then I will max <i>C</i> and <i>D</i> together.

00:06:51.000 --> 00:06:52.273
What happens?

00:06:52.340 --> 00:06:53.373
Audience: Union?

00:06:53.440 --> 00:06:55.103
It’s a max operation.

00:06:55.170 --> 00:06:58.163
It becomes a square.

00:06:58.230 --> 00:07:01.933
This is the picture.
Then I will min <i>E</i> and <i>B</i>.

00:07:02.000 --> 00:07:03.933
It will become this picture <i>F</i>.

00:07:04.000 --> 00:07:05.933
Then I will make another circle <i>G</i>

00:07:06.000 --> 00:07:07.933
but taking the outer area.

00:07:08.000 --> 00:07:09.933
And I will intersect it with <i>F</i>.

00:07:10.000 --> 00:07:11.933
This is what I get, <i>H</i>.

00:07:12.000 --> 00:07:16.933
Finally, I will min <i>H</i> and <i>A</i>.

00:07:17.000 --> 00:07:18.933
It will become this shape.

00:07:19.000 --> 00:07:21.933
The next cool thing about SDF is

00:07:22.000 --> 00:07:25.933
we can transform the picture
by transforming the coordinate system.

00:07:26.000 --> 00:07:30.933
You can see the code up here,
p = abs(p)

00:07:31.000 --> 00:07:34.933
When taking the absolute
of a point, what happens?

00:07:35.000 --> 00:07:40.933
The image in the negative region will
become a reflection of positive region.

00:07:41.000 --> 00:07:42.933
Like this.

00:07:43.000 --> 00:07:46.933
The next thing is modulo.

00:07:47.000 --> 00:07:53.093
It makes points beyond the divisor —

00:07:53.160 --> 00:07:55.933
they will wrap around to the other side.

00:07:56.000 --> 00:07:57.933
It will make the pattern repeat.

00:07:58.000 --> 00:08:04.333
Finally, the line at the top

00:08:04.400 --> 00:08:06.933
I rotate the coordinate by 45 degrees.

00:08:07.000 --> 00:08:08.933
It will become this picture.

00:08:09.000 --> 00:08:12.193
And I will change the color.

00:08:12.260 --> 00:08:16.573
Now, I will add inline all the variables.

00:08:16.640 --> 00:08:17.933
It will become like this.

00:08:23.000 --> 00:08:24.933
That’s all.

00:08:25.000 --> 00:08:27.933
Okay, it’s almost the end.

00:08:28.000 --> 00:08:31.933
Besides 2D, SDF can be used to
create 3D images through Ray Marching.

00:08:32.000 --> 00:08:33.933
But I don’t know how to do it yet.

00:08:34.000 --> 00:08:35.933
But on Inigo Quilez’s website,

00:08:36.000 --> 00:08:38.933
there is an article about 3D SDFs.

00:08:39.000 --> 00:08:40.933
You can check it out.

00:08:41.000 --> 00:08:42.933
I show only a little bit on this slide.

00:08:43.000 --> 00:08:46.933
The actual article is much longer.
There are so many SDF formulas.

00:08:47.000 --> 00:08:49.933
Again I don’t know
how to paint 3D pictures yet

00:08:50.000 --> 00:08:55.933
But I’ll recommend several
YouTube channels if you’re interested.

00:08:56.000 --> 00:08:57.933
The first channel is SimonDev.

00:08:58.000 --> 00:09:00.343
This video goes over
the basics of ray marching,

00:09:00.410 --> 00:09:03.373
and using SDFs to render
3D scenes with maths.

00:09:03.440 --> 00:09:06.893
You will see that with just an SDF,

00:09:06.960 --> 00:09:12.933
you can render scenes with shading,
and light and shadow.

00:09:13.000 --> 00:09:14.933
Another channel is CodeParade.

00:09:15.000 --> 00:09:19.933
This video shows how to render
3D fractals using SDF and ray marching.

00:09:20.000 --> 00:09:23.933
Lastly, Inigo Quilez.

00:09:24.000 --> 00:09:27.933
He painted a character and a landscape,
and other pictures using these techniques.

00:09:28.000 --> 00:09:31.933
Everything is done with math formula.
No model files or a texture files.

00:09:32.000 --> 00:09:33.933
And you can look at the source code.

00:09:34.000 --> 00:09:35.933
You can go and check them out.

00:09:36.000 --> 00:09:38.453
Inigo Quilez also created a website
called ShaderToy.

00:09:38.520 --> 00:09:41.933
You can go to this website
and click on some pictures.

00:09:42.000 --> 00:09:43.933
You will see the source code.

00:09:44.000 --> 00:09:47.933
You can try to change the source code
and see how it affects the result.

00:09:48.000 --> 00:09:49.933
You can use it as a learning tool.

00:09:50.000 --> 00:09:53.933
Lastly, there is a #つぶやきGLSL
hashtag on Twitter,

00:09:54.000 --> 00:09:58.053
where people show off what they can create

00:09:58.120 --> 00:10:01.933
with GLSL code that fits in a tweet.

00:10:02.000 --> 00:10:03.933
There are so many cool works.

00:10:04.000 --> 00:10:05.933
You can check out this hashtag.

00:10:06.000 --> 00:10:07.933
I will put all the links

00:10:08.000 --> 00:10:11.933
about this talk on the URL.

00:10:12.000 --> 00:10:13.933
That’s all I want to share.

00:10:14.000 --> 00:10:15.773
Thank you.
