WEBVTT

1
00:00:05.171 --> 00:00:16.000
The next session is "Regular Expression as an Irregular Musical Expression".

2
00:00:16.000 --> 00:00:18.000
Please give him a round of applause.

3
00:00:22.000 --> 00:00:28.000
If you can't hear the sound, you can listen to it on live.

4
00:00:30.000 --> 00:00:32.000
Facebook Live.

5
00:00:32.000 --> 00:00:34.000
Okay, please go ahead.

6
00:00:34.000 --> 00:00:36.000
Hello, I'm Jim.

7
00:00:36.000 --> 00:00:40.000
My profile is not very interesting, so I'll skip it.

8
00:00:40.000 --> 00:00:48.000
The topic of the session is "Regular Expression as an Irregular Musical Expression".

9
00:00:48.000 --> 00:00:50.000
If I translate it, it will be confusing.

10
00:00:50.000 --> 00:00:52.000
so, I won't translate it.

11
00:00:52.000 --> 00:00:54.000
But you will understand what it is, eventually.

12
00:00:54.000 --> 00:00:58.000
My background is a graphic designer.

13
00:00:58.000 --> 00:01:04.000
I'm also an amateur electronic musician.

14
00:01:04.000 --> 00:01:08.000
I'm interested in writing codes.

15
00:01:08.000 --> 00:01:10.000
I just wrote a code a few years ago.

16
00:01:10.000 --> 00:01:14.000
so I'm quiet a relatively newbie in this field.

17
00:01:14.000 --> 00:01:18.000
Let's start with the word "music".

18
00:01:18.000 --> 00:01:24.000
since, It weaved the world of "graphic design" and "codes" together, personally.

19
00:01:28.000 --> 00:01:30.000
What is music?

20
00:01:30.000 --> 00:01:44.000
According to Edgard VarÃ¨se, he is a french composer also known as the "Father of Electronic Music".

21
00:01:44.000 --> 00:01:48.000
"Music is a sound that is organized".

22
00:01:48.000 --> 00:01:50.000
however,

23
00:01:50.000 --> 00:01:56.000
some might not fully agreed with that definition, it's debatable.

24
00:01:56.000 --> 00:01:58.000
but I'll use his term for a starting point

25
00:01:58.000 --> 00:02:00.000
so, what is a fundamental of "organized sound" then?

26
00:02:00.000 --> 00:02:08.000
fundamentally, "Sound wave" is the basis of any sound.

27
00:02:08.000 --> 00:02:14.000
Sound is the vibration of the object through the medium.

28
00:02:14.000 --> 00:02:18.514
for example, When I hit the table

29
00:02:18.515 --> 00:02:24.999
the object will vibrate and the molecule in the air will be pushed into the ear of the audience.

30
00:02:25.000 --> 00:02:28.000
so the air act as a medium

31
00:02:28.000 --> 00:02:30.942
and you can hear the sound

32
00:02:30.943 --> 00:02:36.000
let's look at the properties of sound wave.

33
00:02:36.000 --> 00:02:38.000
What is it?

34
00:02:38.000 --> 00:02:42.000
the first thing is wavelength.

35
00:02:42.000 --> 00:02:46.000
the moment before the wave is repeated itself.

36
00:02:46.000 --> 00:02:50.000
The next one is amplitude.

37
00:02:50.000 --> 00:02:58.000
Ampitude is the rate of displacement.

38
00:02:58.000 --> 00:03:02.000
normally, we perceive it as a "loudness"

39
00:03:02.000 --> 00:03:04.000
the other one is the frequency.

40
00:03:04.000 --> 00:03:10.000
Frequency is the number of repetitions of the wavelength in one second.

41
00:03:10.000 --> 00:03:16.000
for example, note A is 440 Hz.

42
00:03:16.000 --> 00:03:22.000
It will vibrate 44,000 times per second.

43
00:03:22.000 --> 00:03:23.914
human will perceive it as a note A

44
00:03:23.915 --> 00:03:28.343
the next is time-period, similar to wavelength

45
00:03:28.344 --> 00:03:30.414
the difference is wavelength more about a "space"

46
00:03:30.415 --> 00:03:31.971
but time-period is about "time"

47
00:03:31.972 --> 00:03:34.585
(before it's repeating itself)

48
00:03:34.586 --> 00:03:39.156
"velocity" is the speed at which the sound travels.

49
00:03:39.157 --> 00:03:43.086
so, the sound that happen in the water.

50
00:03:43.087 --> 00:03:45.457
the velocity will be different

51
00:03:45.458 --> 00:03:47.999
from the sound travel through the air.

52
00:03:48.000 --> 00:03:54.000
The next video will be an inspiration for the software I wrote.

53
00:03:54.000 --> 00:04:00.000
I will pull out one of the properties.

54
00:04:00.000 --> 00:04:02.000
In the video, despite there is no sound at all.

55
00:04:02.000 --> 00:04:04.400
but it can be reminisced

56
00:04:04.401 --> 00:04:06.956
to one of the element I've just talked about

57
00:04:06.957 --> 00:04:12.000
I want everyone try to think, what is that property?.

58
00:04:15.429 --> 00:04:17.971
This is a real event.

59
00:04:17.972 --> 00:04:19.743
I means, inspired by real event

60
00:04:19.744 --> 00:04:26.000
When I search for information on the internet, I clicked and clicked.

61
00:04:26.000 --> 00:04:30.343
What is related to the properties of sound wave is

62
00:04:30.344 --> 00:04:31.999
"time period"

63
00:04:32.000 --> 00:04:36.000
the time before it repeats itself.

64
00:04:36.000 --> 00:04:40.000
If you go back to see it, there will be a starting point.

65
00:04:40.000 --> 00:04:44.000
Stop and rewind.

66
00:04:44.000 --> 00:04:48.000
Let's look at the word "time period".

67
00:04:48.000 --> 00:04:52.000
When it repeats itself, it is called periodic event.

68
00:04:52.000 --> 00:04:56.000
It is an event that repeats itself.

69
00:04:56.000 --> 00:05:06.000
The event is one of the methods that musicians use.

70
00:05:06.000 --> 00:05:08.000
I will give an example.

71
00:05:08.000 --> 00:05:10.000
Does anyone have no idea what a fizzbuzz is?

72
00:05:10.000 --> 00:05:12.000
Everyone probably knows.

73
00:05:12.000 --> 00:05:16.000
Fizzbuzz is a game, sort of.

74
00:05:16.000 --> 00:05:22.000
It is a game that teaches children how to do division.

75
00:05:22.000 --> 00:05:26.000
If it is divided by three and remains is zero, it is called "fizz"

76
00:05:26.000 --> 00:05:28.000
if it is divided by five and remains is zero, it is called  "buzz"

77
00:05:28.000 --> 00:05:32.000
if it is divided by both three and five, it is called "fizzbuzz"

78
00:05:42.000 --> 00:05:44.000
you'll notice, I didn't do anything in the first event.

79
00:05:44.000 --> 00:05:46.000
also the second event I didn't make any sound.

80
00:05:46.000 --> 00:05:48.871
The third event I spoke "fizz"

81
00:05:48.872 --> 00:05:49.999
and so on..

82
00:05:50.000 --> 00:05:54.000
What happens is an "interval (of time)".

83
00:05:54.000 --> 00:06:00.000
Interval is the time period between one stage and another stage.

84
00:06:00.000 --> 00:06:08.000
One of the main element of music is rhythm.

85
00:06:08.000 --> 00:06:12.000
in this sense, rhythm is nothing more than just a management of interval (of time).

86
00:06:12.000 --> 00:06:16.000
This is a hardware model.

87
00:06:16.000 --> 00:06:20.000
This is a software model (step-sequencer).

88
00:06:20.001 --> 00:06:22.885
Everyone might be familiar with

89
00:06:22.886 --> 00:06:28.000
if you have played GarageBand, you will notice the timeline.

90
00:06:28.000 --> 00:06:30.428
ultimately says, timeline is just

91
00:06:30.429 --> 00:06:34.000
an event management (interval of time).

92
00:06:34.000 --> 00:06:40.000
This is the software that I wrote.

93
00:06:40.000 --> 00:06:44.000
"anu" is a Thai prefix that is used with other words.

94
00:06:44.000 --> 00:06:48.000
"anu" means "small", "tiny", "sub"

95
00:06:48.000 --> 00:06:52.000
eg. "anupak"(molecule), "anukun"(support), "anukrom"(series).

96
00:06:52.000 --> 00:06:58.000
metaphor to the software that can prefix with others.

97
00:07:00.529 --> 00:07:03.157
objectives

98
00:07:03.158 --> 00:07:05.200
I want it to be just a "frontend"

99
00:07:05.201 --> 00:07:08.000
for any "backend" that can understand

100
00:07:08.000 --> 00:07:09.471
the supported protocols

101
00:07:09.472 --> 00:07:14.000
currently, it supports OSC, Open Sound Control and MIDI.

102
00:07:14.000 --> 00:07:16.000
The second one is the deterministic / stochastic processes.

103
00:07:16.000 --> 00:07:18.000
basically, a semi-random semi-deterministic

104
00:07:18.000 --> 00:07:20.000
I will explain it later.

105
00:07:20.000 --> 00:07:22.000
The third one is "(live) performance-oriented"

106
00:07:22.000 --> 00:07:24.000
initially, I wrote this for live performance

107
00:07:24.000 --> 00:07:26.000
but eventually it never been performed anywhere

108
00:07:26.000 --> 00:07:28.000
so

109
00:07:28.000 --> 00:07:30.000
next one is "low dependencies"

110
00:07:30.000 --> 00:07:32.000
means it should depends other library as less as possible

111
00:07:32.000 --> 00:07:33.800
since I don't want to keep updating dependencies

112
00:07:33.801 --> 00:07:35.999
or some "breaking change"

113
00:07:36.000 --> 00:07:38.000
also it is easier to see how it is broken.

114
00:07:38.000 --> 00:07:40.000
so it's easier for maintenace

115
00:07:40.000 --> 00:07:42.000
the last one, since I am from

116
00:07:42.000 --> 00:07:44.000
a "graphic design" background.

117
00:07:44.000 --> 00:07:46.000
It must have a connection to its vision.

118
00:07:46.000 --> 00:07:50.000
Let's see how to develop the application that I wrote.

119
00:07:50.000 --> 00:07:54.000
Let's look at the overall image first.

120
00:07:54.000 --> 00:08:00.000
This is the software that I wrote using JavaScript only.

121
00:08:00.000 --> 00:08:04.000
I did not use any framework, React, Svelte or anything.

122
00:08:04.000 --> 00:08:10.000
When you click search, it will match the index.

123
00:08:10.000 --> 00:08:14.000
It will add a class "current".

124
00:08:14.000 --> 00:08:16.000
It will be actived

125
00:08:16.000 --> 00:08:22.000
this does not work at all, because it manipulates the DOM directly.

126
00:08:22.000 --> 00:08:28.000
By manipulating the DOM(document object model) directly

127
00:08:28.000 --> 00:08:30.000
it will cause a lot of performace problems.

128
00:08:30.000 --> 00:08:32.000
(for step-sequencer application)

129
00:08:32.000 --> 00:08:36.000
I will explain further.

130
00:08:36.000 --> 00:08:40.000
This is the amended version by sending a msg to trigger a sound.

131
00:09:10.000 --> 00:09:14.000
I use SuperCollider as a backend

132
00:09:14.000 --> 00:09:18.000
sending out an OSC(open sound control)

133
00:09:18.000 --> 00:09:26.000
since, I cannot compose other part while clicking

134
00:09:26.000 --> 00:09:30.000
so a "step" was introduced

135
00:09:30.000 --> 00:09:34.000
it will be the result of the next video.

136
00:09:34.000 --> 00:09:40.443
oh ok, It will checked-out one of the objective of the project.

137
00:09:40.444 --> 00:09:44.199
It is a "visualize syntactic connectedness"

138
00:09:44.200 --> 00:09:50.000
the audience will get a clue what's going on

139
00:09:52.886 --> 00:09:58.171
this is the amended version

140
00:10:11.300 --> 00:10:14.770
the problem is that it cannot compose

141
00:10:14.771 --> 00:10:20.042
a complex pattern when I use normal searching

142
00:10:20.043 --> 00:10:20.900
so,

143
00:10:20.901 --> 00:10:24.143
I added the function of the regular expression.

144
00:10:24.144 --> 00:10:26.586
for anyone who don't know about Regular Expression

145
00:10:26.587 --> 00:10:29.999
basically, it is just an another method of searching

146
00:10:30.000 --> 00:10:33.000
so you can define a complex pattern for searching

147
00:10:33.001 --> 00:10:38.000
eg. I can validate if the text message is an email or not.

148
00:10:38.000 --> 00:10:40.214
I can search if the text message is an email or not.

149
00:10:40.215 --> 00:10:41.999
phone number or not, etc.

150
00:10:42.000 --> 00:10:46.000
for example

151
00:10:46.000 --> 00:10:53.842
the letter "?", will match preceding character('u') 0 time or 1 time

152
00:10:53.843 --> 00:10:55.086
the letter "+"

153
00:10:55.087 --> 00:11:01.071
will match preceding character('r') 1 time or more times

154
00:11:04.057 --> 00:11:08.114
This is an implementation of a RegEx(Regular Expression).

155
00:11:08.115 --> 00:11:11.414
so we can creating more complex patterns

156
00:11:21.871 --> 00:11:22.842
ok so,

157
00:11:22.843 --> 00:11:28.000
What is deterministic and stochastic?

158
00:11:28.000 --> 00:11:32.557
Stochastic is used in Iannis Xenakis's meaning

159
00:11:32.558 --> 00:11:34.414
Xenakis is a Greece composer

160
00:11:34.415 --> 00:11:36.999
he was nearly in the same period with John Cage

161
00:11:37.000 --> 00:11:40.043
but Xenakis is known to be an "Avant-garde" composer

162
00:11:40.044 --> 00:11:42.571
while John Cage is experimental composer

163
00:11:42.572 --> 00:11:46.100
there are similarities, but different in details.

164
00:11:46.101 --> 00:11:48.129
Avant-garde, adopts an extreme position within a certain tradition

165
00:11:48.130 --> 00:11:49.629
eg. controlling some element

166
00:11:49.666 --> 00:11:50.713
by creating system that let it determine itself

167
00:11:50.714 --> 00:11:53.999
that allow the system to create the flow.

168
00:11:54.000 --> 00:12:00.000
For example, Xenakis's work "Achorripsis" (1956)

169
00:12:00.000 --> 00:12:02.600
he used the algorithm

170
00:12:02.601 --> 00:12:05.999
well, not really, its a formula called "Poisson distribution".

171
00:12:06.000 --> 00:12:12.000
It's the distribution of events that occur randomly

172
00:12:12.000 --> 00:12:15.000
to make a score(notation)

173
00:12:15.000 --> 00:12:19.000
so I use the word "stochastic" in this meaning.

174
00:12:19.001 --> 00:12:19.899
what I means is,

175
00:12:19.900 --> 00:12:23.000
Even though you know what's going to happen

176
00:12:23.000 --> 00:12:26.000
with these RegEx pattern, but in the context of music,

177
00:12:26.000 --> 00:12:32.000
you can't say that music matches what you want.

178
00:12:32.000 --> 00:12:37.000
There will be a half-random and half-deterministic

179
00:12:41.000 --> 00:12:43.000
let's try implementing it with the hardware.

180
00:12:54.157 --> 00:12:56.514
This is a modular synthesizer.

181
00:12:56.515 --> 00:13:00.499
The message is CV control voltage.

182
00:13:00.500 --> 00:13:02.042
It's the hardware language.

183
00:13:04.614 --> 00:13:07.300
this will checked-out the objectives's "back-end agnostic"

184
00:13:07.301 --> 00:13:08.500
with hardware

185
00:13:09.543 --> 00:13:12.371
this is integrating with another software

186
00:13:12.372 --> 00:13:15.114
called Pilot.

187
00:13:18.000 --> 00:13:20.999
Now we have achieved 3 objectives.

188
00:13:21.000 --> 00:13:23.329
only 2 left

189
00:13:23.529 --> 00:13:25.056
let's talk about "Tech Stack"

190
00:13:25.057 --> 00:13:27.000
who uses Electron?

191
00:13:29.972 --> 00:13:32.013
"anu" was written in 2019.

192
00:13:32.014 --> 00:13:34.214
using Electron

193
00:13:34.215 --> 00:13:36.913
but I changed it to Tauri (in 2023)

194
00:13:38.571 --> 00:13:41.386
anyone using Rust?

195
00:13:41.387 --> 00:13:43.286
cool, lol

196
00:13:44.471 --> 00:13:48.729
The result is the size has been reduced drastically

197
00:13:48.730 --> 00:13:50.999
from ~120 MB to ~ 9 MB.

198
00:13:51.000 --> 00:13:54.000
but I have to set up the optimization profile.

199
00:13:54.000 --> 00:13:57.000
But to be fair, even if I didn't set it up, 

200
00:13:57.000 --> 00:14:00.000
it will be reduced by 10 times anyway.

201
00:14:01.329 --> 00:14:03.000
Let's look at the architecture.

202
00:14:03.543 --> 00:14:08.243
The main part of Tauri is the Rust code.

203
00:14:08.244 --> 00:14:08.941
for backend

204
00:14:09.000 --> 00:14:12.000
The frontend is JavaScript.

205
00:14:12.000 --> 00:14:15.000
I use the backend to store modules that do not have on the frontend.

206
00:14:15.000 --> 00:14:18.000
I use the backend to store modules that do not have on the frontend.

207
00:14:18.000 --> 00:14:22.543
Since Tauri does not use Chromium at all.

208
00:14:22.544 --> 00:14:24.657
that's why the (application)size was very small.

209
00:14:24.658 --> 00:14:27.314
instead It uses WebView.

210
00:14:27.414 --> 00:14:32.457
but WebView doesn't have requestMidiAccess method

211
00:14:32.458 --> 00:14:34.400
so I have to write MIDI module in backend(Rust) instead

212
00:14:34.401 --> 00:14:37.429
then call the function via `invoke`

213
00:14:39.000 --> 00:14:42.000
this is the architecture of the frontend.

214
00:14:42.000 --> 00:14:44.614
If you have ever written Processing or OpenFramework,

215
00:14:44.615 --> 00:14:47.143
It will use the similar structure

216
00:14:47.386 --> 00:14:49.314
there will be an `install`(function) that runs once.

217
00:14:49.315 --> 00:14:51.757
There will be an `init` also runs once.

218
00:14:51.758 --> 00:14:54.529
and `run`, and `update` that will run as a loop

219
00:14:57.643 --> 00:15:03.971
There will be no dependency except for the CLI of Tauri.

220
00:15:05.386 --> 00:15:10.257
I will checked-out  "low dependency / less obscurantism"

221
00:15:12.000 --> 00:15:15.270
next, let's see how to implement the regular expression.

222
00:15:15.271 --> 00:15:18.000
In the first version, I used a very straightforward method.

223
00:15:18.000 --> 00:15:21.000
In the first version, I used a very straightforward method.

224
00:15:21.000 --> 00:15:24.000
The problem is this.

225
00:15:24.000 --> 00:15:27.000
This is it.

226
00:15:27.000 --> 00:15:30.000
If you have implemented the regular expression,

227
00:15:30.000 --> 00:15:33.000
You will understand that it will cause a case like this case.

228
00:15:33.000 --> 00:15:36.000
The case called catastrophic backtracking.

229
00:15:36.000 --> 00:15:38.614
The case called catastrophic backtracking.

230
00:15:38.615 --> 00:15:42.586
basically, RegEx cannot prevent us to use a pattern

231
00:15:42.587 --> 00:15:46.429
that will cause a long recursive finding

232
00:15:46.430 --> 00:15:50.999
weather it can find or cannot, since it will takes a long long time

233
00:15:51.000 --> 00:15:54.000
it doesn't work with my application at all

234
00:15:55.029 --> 00:15:57.000
otherwise, it may be stuck (freezed).

235
00:15:57.000 --> 00:16:00.000
If we send a empty capture group

236
00:16:00.000 --> 00:16:01.943
if we send a capture group.

237
00:16:01.944 --> 00:16:03.643
oh, spoiled, sorry

238
00:16:03.644 --> 00:16:06.000
The question is,

239
00:16:06.000 --> 00:16:09.000
How will we prevent this case?

240
00:16:09.000 --> 00:16:12.000
How will we prevent this case?

241
00:16:12.000 --> 00:16:15.000
my question was

242
00:16:15.000 --> 00:16:18.000
how will we know whether the program (RegEx solver) will runs forever

243
00:16:18.000 --> 00:16:21.000
or stop at some point?

244
00:16:21.186 --> 00:16:23.300
does it sound familiar?

245
00:16:23.301 --> 00:16:25.514
yes, it is a Halting problem

246
00:16:26.857 --> 00:16:27.857
classic

247
00:16:30.000 --> 00:16:31.900
What I did was,

248
00:16:31.901 --> 00:16:36.000
the first thing I did was sending a message to the worker thread.

249
00:16:36.000 --> 00:16:38.086
the thread that handle RegEx

250
00:16:38.087 --> 00:16:39.470
send "onload"

251
00:16:39.471 --> 00:16:42.000
when worker recieved "onload" msg

252
00:16:42.000 --> 00:16:45.000
the first thing it's going to do is

253
00:16:45.000 --> 00:16:48.000
it will throw out the "timeout" back to main thread.

254
00:16:48.000 --> 00:16:51.000
If the task takes too long, I set it to after 250 ms.

255
00:16:51.000 --> 00:16:54.000
If it's not too long, just clear the timeout.

256
00:16:54.000 --> 00:16:57.000
And send the message back.

257
00:16:57.000 --> 00:17:00.000
Whether it's an error message or whatever.

258
00:17:01.357 --> 00:17:04.100
Back to the main thread

259
00:17:06.000 --> 00:17:09.000
how do we know that the RegEx pattern we wrote

260
00:17:09.000 --> 00:17:12.000
will run all the time or leave the loop?

261
00:17:12.000 --> 00:17:15.000
so I use a technique called 2-pointer.

262
00:17:15.000 --> 00:17:18.000
Slow pointer and fast pointer.

263
00:17:18.000 --> 00:17:20.443
If anyone used to play Leetcode

264
00:17:20.444 --> 00:17:21.929
you'll be familiar with it.

265
00:17:21.930 --> 00:17:23.999
eg. Circular Dependencies sort of thing

266
00:17:24.986 --> 00:17:27.000
it's used to check if two position is "meet" or not

267
00:17:27.000 --> 00:17:30.000
there should be a gap between the slow one

268
00:17:30.000 --> 00:17:33.000
and the fast one, like a rabbit and a turtle.

269
00:17:33.000 --> 00:17:36.000
When the turtle follows the rabbit,

270
00:17:36.000 --> 00:17:38.100
there will be a gap between what follows.

271
00:17:38.101 --> 00:17:38.999
if not, or a slow index = fast index

272
00:17:39.000 --> 00:17:42.000
its means, the loop occurance.

273
00:17:45.000 --> 00:17:48.000
Now, the external connection

274
00:17:48.000 --> 00:17:51.000
currently support just two, MIDI and OSC(open sound control)

275
00:17:51.000 --> 00:17:54.000
as I said earlier,

276
00:17:54.000 --> 00:17:57.000
it can't request MIDI access on WebView.

277
00:17:57.000 --> 00:18:00.000
So, I had to write MIDI module in Rust

278
00:18:00.000 --> 00:18:03.000
simply, we just had to declare the procedural macro

279
00:18:03.000 --> 00:18:04.171
here

280
00:18:04.714 --> 00:18:05.999
and then

281
00:18:06.000 --> 00:18:09.000
we register it in the main app.

282
00:18:09.000 --> 00:18:12.000
now we can call via `invoke`

283
00:18:12.000 --> 00:18:17.771
we can invoke Rust code from JavaScript side.

284
00:18:20.000 --> 00:18:23.000
We can invoke it.

285
00:18:23.000 --> 00:18:26.000
Open sound control or OSC

286
00:18:26.000 --> 00:18:29.000
is a protocol.

287
00:18:29.000 --> 00:18:32.000
This is quite long. I can't explain it.

288
00:18:32.000 --> 00:18:35.000
basically, I use nom as a parser combinator.

289
00:18:35.157 --> 00:18:38.000
It's similar to PEG

290
00:18:38.000 --> 00:18:41.000
but with PEG you have to write a gramma

291
00:18:41.000 --> 00:18:44.000
it will pass the message (byte-array) directly.

292
00:18:44.000 --> 00:18:47.000
The speed is good.

293
00:18:47.000 --> 00:18:50.000
tbh, I don't know the difference that much

294
00:18:50.000 --> 00:18:53.842
it's just looks interesting

295
00:18:53.843 --> 00:18:56.000
so, I used nom.

296
00:18:57.843 --> 00:18:59.499
Another important part

297
00:18:59.500 --> 00:19:03.329
of the application is the sequencer.

298
00:19:03.330 --> 00:19:05.685
The timing of the sequencer

299
00:19:05.686 --> 00:19:07.643
shouldn't be jittery.

300
00:19:07.644 --> 00:19:09.186
it have to be stable

301
00:19:09.187 --> 00:19:14.000
There must be an robust implementation of the clock.

302
00:19:14.000 --> 00:19:16.400
What will I use between these three?

303
00:19:16.401 --> 00:19:18.671
Date.now(), setInterval, setTimeOut.

304
00:19:18.672 --> 00:19:23.000
The first thing I used was setTimeOut.

305
00:19:23.000 --> 00:19:26.000
very straightforward and naive

306
00:19:26.000 --> 00:19:29.000
eventaully it didn't work.

307
00:19:29.000 --> 00:19:32.000
I asked myself again.

308
00:19:32.000 --> 00:19:35.000
What should I use?

309
00:19:35.000 --> 00:19:37.243
Date.now, setInterval, setTimeOut.

310
00:19:37.244 --> 00:19:38.470
setTimeout already tried

311
00:19:38.471 --> 00:19:40.999
so there were two left.

312
00:19:41.000 --> 00:19:44.000
But the all options was wrong.

313
00:19:44.000 --> 00:19:47.000
The right question should be "where to run the clock?"

314
00:19:47.000 --> 00:19:50.000
because the main thread

315
00:19:50.000 --> 00:19:53.000
has the duties of rendering

316
00:19:53.000 --> 00:19:56.000
to disturb the timing of the clock.

317
00:19:56.000 --> 00:19:59.000
I used to use the event loop.

318
00:19:59.000 --> 00:20:02.000
Event loop is another topic

319
00:20:02.000 --> 00:20:05.000
that can be found on the Internet.

320
00:20:05.000 --> 00:20:08.000
basically, Event-loop

321
00:20:08.000 --> 00:20:11.000
it doesn't guarantee

322
00:20:11.000 --> 00:20:14.000
that the task you put in the queue

323
00:20:14.000 --> 00:20:17.000
will work as planned.

324
00:20:17.000 --> 00:20:20.642
It's not very suitable for the timing

325
00:20:20.643 --> 00:20:24.899
that requires high precision.

326
00:20:24.900 --> 00:20:27.085
The next method I used was

327
00:20:27.086 --> 00:20:30.656
setInterval on worker thread.

328
00:20:30.657 --> 00:20:33.199
This method almost works.

329
00:20:33.200 --> 00:20:35.000
But the problem is

330
00:20:35.000 --> 00:20:38.000
when you wanted to change the tempo in the middle of the song,

331
00:20:38.000 --> 00:20:41.000
it will cause a problem.

332
00:20:43.371 --> 00:20:45.099
The last method I use is

333
00:20:45.100 --> 00:20:47.000
audio context current time.

334
00:20:47.000 --> 00:20:50.000
Current time is double precision 64 bits.

335
00:20:50.000 --> 00:20:53.000
It means that the

336
00:20:53.000 --> 00:20:56.000
accuracy of the floating point will be very high

337
00:20:56.000 --> 00:20:59.000
therefore, it is very suitable for

338
00:20:59.000 --> 00:21:02.000
high precision handling

339
00:21:02.000 --> 00:21:05.000
such as timing and tempo.

340
00:21:05.000 --> 00:21:08.000
This is the updated version.

341
00:21:08.000 --> 00:21:11.000
There is a "start" msg,

342
00:21:11.000 --> 00:21:14.000
and "interval", and "stop"

343
00:21:14.000 --> 00:21:17.000
from the first one, there is only a start.

344
00:21:17.000 --> 00:21:21.313
what's been developed from previous version was

345
00:21:21.314 --> 00:21:22.429
this function

346
00:21:22.430 --> 00:21:24.986
the actual function quite long

347
00:21:24.987 --> 00:21:27.299
but it can be boiled down

348
00:21:27.300 --> 00:21:30.299
to understand as this.

349
00:21:30.300 --> 00:21:32.000
While it sets the...

350
00:21:37.000 --> 00:21:40.000
It has to keep checking the queue.

351
00:21:40.000 --> 00:21:43.000
It has to check the nextNoteTime.

352
00:21:43.000 --> 00:21:46.000
It's time to

353
00:21:46.000 --> 00:21:49.000
"is it ready for the next note(tick)"?.

354
00:21:49.000 --> 00:21:52.000
There is a scheduleAheadTime.

355
00:21:52.000 --> 00:21:54.557
We will check the time

356
00:21:54.558 --> 00:21:56.986
until the next note.

357
00:21:56.987 --> 00:22:00.500
the results is the timing will be very precise

358
00:22:01.000 --> 00:22:04.000
this is a bit tricky (to implement).

359
00:22:04.000 --> 00:22:07.000
since, setTimeOut

360
00:22:07.000 --> 00:22:09.400
although you already have a precise time,

361
00:22:09.401 --> 00:22:12.613
guaranteed time to play precisely

362
00:22:12.614 --> 00:22:14.214
but it's not

363
00:22:14.215 --> 00:22:15.914
I tried using setTimeOut but it's not works

364
00:22:16.471 --> 00:22:22.000
so I use the audioContext's time instead.

365
00:22:22.000 --> 00:22:25.000
The audio contact has a function called

366
00:22:25.000 --> 00:22:26.386
"start()"

367
00:22:26.387 --> 00:22:28.586
which accept "timestamp" as an argument

368
00:22:28.587 --> 00:22:32.357
tell it when to "start" and when to "stop"

369
00:22:32.358 --> 00:22:37.000
since we already have a very precise time

370
00:22:37.000 --> 00:22:40.000
and audio contact that can run the right time.

371
00:22:40.000 --> 00:22:43.000
"start" then "stop" immediately.

372
00:22:43.000 --> 00:22:46.000
Then use "onended" as a callback

373
00:22:46.000 --> 00:22:47.871
to run the application

374
00:22:47.872 --> 00:22:50.186
it's a little tricky and the flow is strange

375
00:22:50.187 --> 00:22:52.914
but I can't think of a better way.

376
00:22:52.915 --> 00:22:56.214
If you know how to improve the code, please let me know.

377
00:22:58.214 --> 00:23:01.985
This is the latest version.

378
00:23:01.986 --> 00:23:04.000
you might notice that I completely removed

379
00:23:04.000 --> 00:23:07.000
the form that has input.

380
00:23:07.000 --> 00:23:12.429
personally, I like Vim's workflow.

381
00:23:12.430 --> 00:23:16.000
I don't wanted to use the mouse

382
00:23:16.000 --> 00:23:19.000
while performing.

383
00:23:19.000 --> 00:23:22.000
quite distractive and annoying.

384
00:23:22.586 --> 00:23:26.243
This is the console.

385
00:23:31.000 --> 00:23:34.000
so this checked-out "(live)performance-oriented".

386
00:23:34.000 --> 00:23:37.000
I use it to perform.

387
00:23:38.700 --> 00:23:42.357
the objectives is now completed

388
00:23:42.358 --> 00:23:44.214
5 options.

389
00:23:46.000 --> 00:23:47.657
It's done.

390
00:23:47.658 --> 00:23:52.943
"anu" is an open-source so anyone can PR

391
00:23:52.944 --> 00:23:55.986
or open an issue or anything

392
00:23:59.086 --> 00:24:03.829
now I'll show you the demo

393
00:28:34.000 --> 00:28:37.000
That's about it.

