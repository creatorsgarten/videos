WEBVTT

00:00:01.900 --> 00:00:05.133
โอเคนะครับผมก็ขอส่งต่อเวทีนี้กลับให้คุณเจมส์นะครับ

00:00:06.400 --> 00:00:07.733
อ่าขอบคุณครับทุกคนครับ

00:00:08.000 --> 00:00:11.233
โอเค ถามก่อนครับในนี้ใครรู้จัก

00:00:12.000 --> 00:00:14.533
เอ่อ ทุกคนคงน่าจะเคยได้ยิน large language model

00:00:14.800 --> 00:00:15.533
กันใช่มั้ยครับ

00:00:15.600 --> 00:00:20.533
โอเค ใครในนี้เคยได้ยิน ยังไม่เคยได้ยินคำว่า

00:00:20.600 --> 00:00:23.633
vector search บ้างครับ ขอมือหน่อยฮะ จะได้รู้

00:00:23.700 --> 00:00:24.533
background ทุกคนหน่อย

00:00:24.600 --> 00:00:26.533
โอเคแปลว่าทุกคนเคยได้ยินหมดแล้ว

00:00:26.600 --> 00:00:27.433
โอเคมีข้างหลังนะครับ

00:00:27.900 --> 00:00:31.833
ในนี้มีใครยังไม่เคยได้ยินคำว่า semantic search บ้างครับ

00:00:33.100 --> 00:00:36.133
ทุกคนเคยได้ยินหมดแล้ว อ๋อๆ โอเคมี 2 ได้ครับ

00:00:36.200 --> 00:00:38.033
แปลว่าส่วนใหญ่น่าจะมีพื้นฐานใช่มั้ยครับ

00:00:38.100 --> 00:00:42.133
โอเค เอิ่ม บอกก่อนครับว่า เอ่อ เซสชั่นเนี้ยจริงๆ

00:00:42.200 --> 00:00:44.433
มันเป็น workshop นะครับ

00:00:44.500 --> 00:00:48.433
รันกันประมาณ 3 ชั่วโมงนิดๆ นะครับ

00:00:48.500 --> 00:00:50.433
ก็เราพยายามย่อมาให้เหลือเป็น 40 นาทีนะครับ

00:00:50.500 --> 00:00:53.233
ก็ดีเทลบางอย่างเราอาจจะข้ามมันไปนะครับ

00:00:53.300 --> 00:00:55.333
ก็ในส่วนที่เป็นโค้ดเดี๋ยวผมจะ walk through ให้ดู

00:00:55.400 --> 00:00:57.733
แต่ว่าคงไม่ได้ลงลึกขนาดนั้นนะครับ

00:00:57.800 --> 00:01:00.433
ก็ เอ่อ แต่ anyway ครับเรามี GitHub

00:01:00.500 --> 00:01:02.333
เรามี Google Colab นะครับ

00:01:02.400 --> 00:01:05.833
แล้วเราก็มีบทความที่เขียนเอาไว้แล้ว follow up ได้นะครับ

00:01:05.900 --> 00:01:09.933
แล้วก็เร็วๆ นี้น่าจะมีเปิดรับลงทะเบียนสำหรับ

00:01:10.400 --> 00:01:11.933
ทำ workshop ตัวเนี้ยนะครับ

00:01:12.000 --> 00:01:14.333
ก็เดี๋ยวผมกับทีมเนี่ยจะมาสอนด้วยกันนะครับ

00:01:14.400 --> 00:01:17.933
สอนฟรีนะครับ ก็ดูในกลุ่มไว้แล้วกันนะครับ

00:01:18.700 --> 00:01:24.532
โอเคครับ เอิ่ม จริงๆ วันนี้หัวข้อมันคือ RAG กับ

00:01:24.600 --> 00:01:26.533
vector search with MongoDB นะครับ

00:01:26.900 --> 00:01:33.433
ก็จริงๆ เนี่ย พอพูดถึงคำว่า large language model เนาะ

00:01:33.500 --> 00:01:35.233
นะครับ พูดถึง large language model

00:01:35.300 --> 00:01:37.033
เนี่ยมันทำอะไรได้บ้างนะครับ

00:01:37.100 --> 00:01:41.333
เราก็จะนึกถึงอะไรที่เราพิมพ์คำถามเข้าไปใช่มั้ยครับ

00:01:41.600 --> 00:01:42.933
เราพิมพ์คำถามเข้าไป

00:01:43.000 --> 00:01:45.933
แล้วจากนั้นเนี่ย มันก็พยายามที่จะให้คำตอบ

00:01:46.000 --> 00:01:47.833
อะไรบางอย่างกับเรากลับมาใช่มั้ยฮะ

00:01:47.900 --> 00:01:55.433
อ่ะลองดูนะครับ เอ่อ เห็นมั้ยฮะ

00:01:55.500 --> 00:01:56.533
ผมขยายหน่อยแล้วกันนะ

00:01:58.400 --> 00:02:01.333
อืม เอ่อ ผมพิมพ์ว่า system ของผมเป็นยังไงบ้างครับวันนี้ฮะ

00:02:01.400 --> 00:02:02.733
แล้วผมลองส่ง request นะครับ

00:02:03.000 --> 00:02:05.433
โอเคครับ เอ่อ สิ่งนี้ทำอะไรครับ

00:02:05.500 --> 00:02:10.733
สิ่งเนี้ยครับ มันจะรับคำสั่งเป็นคำถามแบบ meaning เข้าไปครับ

00:02:10.800 --> 00:02:14.033
แล้วมันก็จะพยายามไปเชื่อมต่อกับ 2 อย่างครับ

00:02:14.100 --> 00:02:17.632
ก็คือสิ่งที่เป็นตัว AI เองนะครับ

00:02:17.700 --> 00:02:21.833
ที่ก็คือเป็นโมเดลแยกเนาะ ของ OpenAI Azure OpenAI นะครับ

00:02:21.900 --> 00:02:22.333
ที่ผมใช้

00:02:22.700 --> 00:02:27.333
แล้วก็พยายามที่จะเข้าไป get data บางอย่างจาก MongoDB

00:02:27.400 --> 00:02:28.933
นะครับ แล้วก็เอามาแสดงนะครับ

00:02:29.000 --> 00:02:31.733
ประเด็นคือคำว่า get data บางอย่างเนี่ยมันทำได้หลายวิธี

00:02:31.800 --> 00:02:35.433
เดี๋ยววันนี้เราจะมาพูดถึง 2 วิธีนะครับที่เราจะใช้กันนะครับ

00:02:36.100 --> 00:02:38.533
ก็ครับ ซึ่งก็ เอ่อ โดย

00:02:38.600 --> 00:02:40.833
อันนี้เป็นข้อมูลที่เก็บมาเป็นข้อมูล logging นะครับ

00:02:40.900 --> 00:02:44.733
เป็นข้อมูล logging ของตัว HTTP request in general นะครับ

00:02:44.800 --> 00:02:47.033
ผมก็ถามว่า เออ system today ของผมเป็นยังไงนะครับ

00:02:47.100 --> 00:02:49.533
มันก็บอกเนาะว่า เออ วันนี้มันเกิดอะไรขึ้นเนาะ

00:02:49.600 --> 00:02:50.632
ด้วยอะไรแบบไหนนะครับ

00:02:50.700 --> 00:02:53.632
แปลงเป็นคำพูดออกมานะครับ

00:02:54.000 --> 00:02:58.533
โอเคครับ นั่นก็คือเดโมพอหอมปากหอมคอนะครับ

00:02:59.500 --> 00:03:02.933
โอเค แล้วนี่ก็คือตัวข้างหลังครับ

00:03:03.000 --> 00:03:04.833
จริงๆ ค่อนข้าง simple นะครับ

00:03:04.900 --> 00:03:07.132
ไม่ได้มีอะไรยิ่งใหญ่มากนะครับ

00:03:07.200 --> 00:03:11.233
แต่ว่าเดี๋ยวเราเนี่ย คงจะมาลงลึกเอ่อ นิดนึงนะครับ

00:03:11.300 --> 00:03:13.933
แตะนิดนึงในส่วนที่ 2 ที่เป็น query database นะครับ

00:03:14.000 --> 00:03:15.033
ที่ใช้ MongoDB เนาะ

00:03:15.100 --> 00:03:17.733
เดี๋ยวเรามาดูก่อนว่าเราใช้วิธีไหนได้บ้างนะครับ

00:03:18.100 --> 00:03:21.533
โอเคครับ แต่ผมขอปูพื้นนิดนึงแล้วกันครับ

00:03:21.600 --> 00:03:24.533
ผมว่าหลายๆ คนคงจะรู้จักกับ LLM แหละนะครับ

00:03:24.600 --> 00:03:27.533
เราก็คงจะรู้ว่า LLM มี model knowledge เนาะ ใช่มั้ยครับ

00:03:27.800 --> 00:03:29.533
เจ้า model knowledge ตัวเนี้ยครับ

00:03:29.600 --> 00:03:31.033
มันเป็น model knowledge แบบ batch

00:03:31.100 --> 00:03:32.632
หมายความว่าไงครับ หมายความว่า

00:03:32.700 --> 00:03:36.933
รุ่นนี้มันอาจจะถูกมีโมเดลที่ feed เข้าไปเป็น pre-trained

00:03:37.000 --> 00:03:39.333
อ่ะนะครับ ตั้งแต่วันนี้จนถึงวันนี้

00:03:39.400 --> 00:03:41.132
จากนั้นก็จบแค่ตรงนั้นใช่มั้ยครับ

00:03:41.200 --> 00:03:44.333
อย่างถ้าเกิดว่าบางทีเนี่ยเราถามคำถามให้กับตัว

00:03:44.400 --> 00:03:45.533
assistant ของเรานะครับ

00:03:45.600 --> 00:03:48.933
แล้วเราถามว่า เออ Queen Elizabeth เนี่ยยังอยู่มั้ยนะครับ

00:03:49.000 --> 00:03:52.533
ที่ 2 นะครับ เขาก็จะบอกว่า เออ เขายังอยู่นะครับ ใช่มั้ย

00:03:52.600 --> 00:03:54.533
เพราะว่าโมเดลบางตัวเนี่ยมันยัง

00:03:54.600 --> 00:03:57.933
มันยังเป็นโมเดลที่ข่าวเนี่ยมันยังอยู่ในช่วงปีก่อนที่

00:03:58.000 --> 00:04:00.833
Queen Elizabeth จะ pass away ใช่มั้ยครับเนาะ

00:04:00.900 --> 00:04:04.033
แต่ว่าโมเดลหลังจากนั้นก็อาจจะอัพเดตไปแล้วนะครับ

00:04:04.100 --> 00:04:06.733
โอเคนี่ก็เป็นประเด็นนึงนะครับ

00:04:07.000 --> 00:04:10.632
แล้วอีกประเด็นนึงครับ บางทีเราอาจจะถามคำถามที่

00:04:10.700 --> 00:04:12.433
เอ่อ มัน general มากนะครับ

00:04:12.500 --> 00:04:13.433
อย่างเช่นว่า เอ้ย ไม่ใช่ general แบบ

00:04:13.800 --> 00:04:16.132
คำถามที่มัน specific มากขึ้นนะครับ

00:04:16.200 --> 00:04:18.933
อย่างเช่น เออ ผมอยากจะได้ waterproof shoes

00:04:19.200 --> 00:04:20.433
ที่มันแบบอุ่นๆ หน่อยนะครับ

00:04:20.500 --> 00:04:22.533
ถ้าเกิดว่าปั่นๆ อยู่อะไรอย่างเงี้ยนะครับ

00:04:22.600 --> 00:04:25.533
เออ assistant ของเราที่เป็นตัว AI อ่ะครับ

00:04:25.600 --> 00:04:28.332
ถ้าเกิดว่าเขาไม่ได้มีข้อมูลที่มัน specific เจาะจง

00:04:28.400 --> 00:04:31.033
เขาก็จะพยายามดึงข้อมูลที่เป็น batch ของเขาออกมาตอบเราเนาะ

00:04:31.300 --> 00:04:36.733
นะครับ ซึ่งตรงเนี้ยครับ เป็นสิ่งที่ เอ่อ เราเนี่ย

00:04:36.800 --> 00:04:40.733
ที่เป็นคนที่ทำแอปพลิเคชันบางอย่างที่มันจะต้องมีการต่อกับ

00:04:40.800 --> 00:04:42.733
LLM เนี่ยครับ จะต้องพยายามเข้าใจนะว่า

00:04:42.800 --> 00:04:43.433
เอ้ย จริงๆ แล้วเนี่ย

00:04:43.700 --> 00:04:46.633
แล้วถ้าเกิดว่าเรายังอยากให้เขาตอบให้มัน specific มากขึ้น

00:04:46.700 --> 00:04:50.233
หรือว่าให้มันพยายาม lead มาสู่การซื้อสินค้าของเรามากขึ้น

00:04:50.300 --> 00:04:52.933
หรืออะไรแบบเนี้ยมันควรจะต้องเป็นยังไงนะครับ

00:04:53.300 --> 00:04:57.033
นะครับ ก็ โดยส่วนใหญ่นะครับ

00:04:57.100 --> 00:04:59.832
อันนี้เราพูดถึง knowledge ที่เป็นแบบขั้นพื้นฐานก่อน

00:04:59.900 --> 00:05:01.633
ก็คือเรา add prompt เข้าไปถูกมั้ยครับ

00:05:01.900 --> 00:05:03.733
prompt โดยปกติเลยใช่มั้ยครับ

00:05:03.800 --> 00:05:06.533
อย่างเช่นว่า เออ I need warm waterproof

00:05:06.600 --> 00:05:08.332
เราอาจจะ add prompt ที่เป็น meta prompt ว่า

00:05:08.400 --> 00:05:11.832
เออ จริงๆ แล้วอ่ะ you ควรจะต้องเป็น AI นะที่ตอบคำถาม

00:05:12.100 --> 00:05:15.933
เอ่อ เป็น AI นะที่ act ว่าตัวเองเนี่ยเป็น

00:05:16.000 --> 00:05:17.332
sales representative เนาะ

00:05:18.100 --> 00:05:21.633
เป็นเซลล์ขายของนะครับ ของบริษัทนี้ บริษัทนี้นะครับ

00:05:21.700 --> 00:05:23.933
แล้วเราก็ลุ้นนะครับว่า ไอ้บริษัทนี้ บริษัทนี้เนี่ย

00:05:24.000 --> 00:05:25.733
มันมี data อยู่ใน batch ที่มันถูก pre-trained

00:05:25.800 --> 00:05:27.033
เข้าไปรึเปล่านะครับ

00:05:28.100 --> 00:05:29.733
เอ่อ ซึ่งเราไม่ต้องการแบบนั้นครับ

00:05:29.800 --> 00:05:31.033
เราไม่ต้องการแบบนั้นนะครับ

00:05:31.100 --> 00:05:33.533
สิ่งที่เราพยายามทำเนี่ยคือการที่บอกว่าโอเค

00:05:33.600 --> 00:05:37.133
ถึงแม้โมเดลเนี่ย เอ่อ ที่เป็น LLM เนี่ยเขาจะเก่งนะครับ

00:05:37.200 --> 00:05:41.033
ในมุมของการพยายามที่จะเข้าใจ semantic meaning

00:05:41.100 --> 00:05:43.033
ความหมายอะไรบางอย่างก็ตามนะครับ

00:05:43.100 --> 00:05:46.633
แต่เราก็จะต้องมีการ provide ข้อมูลที่เป็นข้อมูลอัพเดต

00:05:46.700 --> 00:05:48.533
หรือข้อมูลบางอย่างให้กับเขา

00:05:48.600 --> 00:05:49.832
เพื่อให้เขาสามารถเอาตรงเนี้ยครับ

00:05:49.900 --> 00:05:52.033
กับตัวความรู้ที่เป็น model knowledge ของเขาเนี่ย

00:05:52.100 --> 00:05:53.332
มา compile ซึ่งกันและกัน

00:05:53.400 --> 00:05:55.332
แล้วตอบคำถามให้มันเจาะจงมากขึ้นเนาะ

00:05:55.400 --> 00:05:56.733
นะครับ สิ่งเนี้ยครับมีชื่อว่า

00:05:56.800 --> 00:05:58.733
retrieval augmented generation นะครับ

00:05:58.800 --> 00:06:00.533
หรือว่า RAG นั่นแหละนะครับ

00:06:00.600 --> 00:06:02.033
มันทำงานยังไงนะครับ

00:06:02.100 --> 00:06:05.933
ก็หลักๆ ครับ เวลาที่ user มี เอ่อ question เข้ามานะครับ

00:06:06.000 --> 00:06:08.933
เราก็จะพยายามจับ question ตรงนั้นก่อนครับ

00:06:09.000 --> 00:06:12.733
แล้วดึง data ที่เกี่ยวข้องนะครับ กับ question ตรงนั้นนะครับ

00:06:13.100 --> 00:06:15.832
แล้วจากนั้นเนี่ย เราก็จะพยายาม

00:06:16.800 --> 00:06:19.133
เอาไอ้ data ที่เกี่ยวข้องกับ question ตรงนั้นนะครับ

00:06:20.400 --> 00:06:22.033
ผสมกับ prompt ของเรานะครับ

00:06:22.100 --> 00:06:23.832
แล้วก็ใส่เข้าไปให้กับโมเดลเนาะ

00:06:23.900 --> 00:06:25.733
แล้วจากนั้นโมเดลมันก็จะพยายาม analyze นะครับ

00:06:25.800 --> 00:06:27.832
แล้วก็พยายาม send result บางอย่างออกมานะครับ

00:06:27.900 --> 00:06:32.233
นี่ก็คือท่ามาตรฐานทั่วไปนะครับ ของสิ่งที่มันเป็นนะครับ

00:06:32.300 --> 00:06:35.633
โอเคครับ ซึ่ง พอกลับมาตรงนี้ครับ

00:06:35.700 --> 00:06:36.633
เดี๋ยวปูพื้นกันนิดนึงครับ

00:06:36.700 --> 00:06:38.033
ยังไม่ไป MongoDB เลยนะครับ

00:06:38.400 --> 00:06:41.433
เรายังอยู่ที่ เอ่อ Azure OpenAI กันอยู่นะครับ

00:06:41.500 --> 00:06:43.332
เออ พอมาถึงตรงนี้ครับ

00:06:43.900 --> 00:06:45.733
sequence ในการทำงานของมันนะครับ

00:06:45.800 --> 00:06:47.433
โดยปกติเนี่ยมันเป็นยังไงนะครับ

00:06:47.500 --> 00:06:49.933
อ่า นี่คือ sequence diagram ในการทำงานของมันนะครับ

00:06:50.300 --> 00:06:53.733
ก็หลักๆ ครับมันจะรับตัว query เข้ามานะครับเนาะ

00:06:53.800 --> 00:06:56.033
แล้วก็หลังจากนั้นเนี่ย พอมันรับ query เข้ามานะครับ

00:06:56.100 --> 00:06:58.733
เสร็จเนี่ย มันก็จะพยายามที่จะเอา query ตัวเนี้ยครับ

00:06:59.000 --> 00:07:01.933
ยิงไปหาตัว OpenAI โมเดลก่อนเนาะ

00:07:02.000 --> 00:07:03.832
แล้วก็พยายามดูว่า OpenAI โมเดลเนี่ย

00:07:03.900 --> 00:07:06.033
มันต้องการข้อมูลอะไรเพิ่มมั้ยนะครับ

00:07:06.100 --> 00:07:08.633
ถ้ามันต้องการเพิ่มเดี๋ยวมันจะบอกกลับมาละหาเราครับ

00:07:09.100 --> 00:07:11.433
ถ้าเกิดว่า สมมติว่ามันบอกว่า เฮ้ย ชั้นต้องการ

00:07:11.500 --> 00:07:12.433
เราต้อง prompt เอาไว้นะว่า

00:07:12.500 --> 00:07:18.033
เฮ้ย ชั้นต้องการข้อมูลเกี่ยวกับ log วันนี้ วันนี้นะครับ

00:07:18.100 --> 00:07:20.033
เขาก็จะพยายามเรียกกลับมาที่ backend application

00:07:20.500 --> 00:07:20.933
ของเราเนาะ

00:07:21.000 --> 00:07:23.433
แล้วจากนั้นเราก็ไป fetch ข้อมูลจาก MongoDB นะครับ

00:07:23.700 --> 00:07:26.332
แล้วจากนั้นก็ส่งข้อมูลกลับไปให้ LLM นะครับ

00:07:26.400 --> 00:07:29.033
พร้อมกับ prompt ของเราเนาะ

00:07:29.100 --> 00:07:30.533
แล้วคราวเนี้ย เราก็ return ตัว summary ตรงนั้นนะครับ

00:07:30.600 --> 00:07:32.133
กลับไปให้กับ user นะครับ

00:07:32.200 --> 00:07:33.832
ซึ่งเราก็จะเห็นนะครับว่า process ตรงเนี้ย

00:07:33.900 --> 00:07:37.832
มันจะมีการ involve data ที่เป็น data แบบ data ของเราเอง

00:07:37.900 --> 00:07:40.933
กับ pre-trained data ที่มันมีอยู่ในโมเดลอยู่แล้วใช่มั้ยครับ

00:07:41.600 --> 00:07:46.933
ครับ ซึ่ง ผมจะ walk through ให้แบบคร่าวๆ แล้วกันนะครับเนาะ

00:07:47.000 --> 00:07:49.733
มันเป็นยังไงนะครับ ก็มันเป็นแบบนี้ครับ

00:07:50.400 --> 00:07:53.633
เอ่อ จริงๆ อันนี้อยู่ใน GitHub นะครับ มีทุกอย่างเลยครับ

00:07:54.000 --> 00:07:56.133
เอ่อ ทั้งสไลด์ สไลด์น่าจะยัง

00:07:57.100 --> 00:07:58.933
อ่า เดี๋ยวไม่อัพเดต เดี๋ยวขออัพเดตนิดนึงนะครับ

00:07:59.000 --> 00:08:00.832
แล้วก็แต่ที่เหลือมีหมดแล้วนะครับ

00:08:00.900 --> 00:08:06.233
โอเค เห็นมั้ย เล็กมากนะฮะ ขอขยายหน่อย นะครับ

00:08:06.300 --> 00:08:11.033
โอเคครับ หลักๆ ครับมันจะมี endpoint API อยู่ตรงนี้ครับ

00:08:11.700 --> 00:08:13.433
นี่คือ API endpoint ของเราครับ

00:08:13.800 --> 00:08:18.933
ก็หลักๆ ครับ พอเราพิมพ์ข้อมูลปุ๊บ กดปุ่ม ask ปุ๊บใช่มั้ยครับ

00:08:19.000 --> 00:08:20.933
มันก็จะยิงคำถามเข้ามาในนี้ครับ

00:08:21.200 --> 00:08:24.933
จากนั้นก็ simple ครับ เราก็รับคำถามเข้ามาครับ

00:08:25.000 --> 00:08:26.133
extract คำถามออกมา

00:08:26.400 --> 00:08:30.033
จากนั้นเสร็จปุ๊บครับ เรา เราขั้นแรกเราโยนคำถามเนี้ยกลับ

00:08:30.100 --> 00:08:32.832
ไปให้กับ AI โมเดลก่อนนะครับเนาะ

00:08:32.900 --> 00:08:33.732
เรายังไม่ retrieve นะครับ

00:08:34.000 --> 00:08:35.332
เราพยายามโยนกลับไปก่อนนะครับ

00:08:35.400 --> 00:08:37.732
เพราะว่าคำถามที่มาเนี่ยมันเป็นคำถามแบบ semantic

00:08:37.799 --> 00:08:40.933
คือมันเป็นคำถามที่มีความหมายเนาะ ใช่มั้ยครับเนาะ

00:08:41.000 --> 00:08:42.232
เราก็พยายามที่จะเข้าใจว่า

00:08:42.299 --> 00:08:45.233
เอ้ย ความหมายของคำถามเนี้ยคืออะไรนะครับ

00:08:45.300 --> 00:08:47.833
นั่นเป็นงานที่ LLM เขาเก่งอยู่แล้วนะครับ

00:08:48.100 --> 00:08:50.133
แต่หลังจากที่เราได้คำถามมาแล้วอ่ะครับ

00:08:50.800 --> 00:08:52.833
เราอ่ะครับจะพยายาม extract ครับ

00:08:52.900 --> 00:08:55.333
อันนี้คือตัวของ response ที่ได้มาจาก LLM นะครับ

00:08:55.700 --> 00:08:56.333
เห็นใช่มั้ยฮะ

00:08:56.400 --> 00:09:00.933
โอเค ไอ้ response ตัวเนี้ยครับ เราจะพยายามบอกเขาครับ

00:09:01.000 --> 00:09:02.033
pre-define บอกเขาว่า

00:09:02.100 --> 00:09:04.933
เฮ้ย ถ้ามันในคำถามเนี้ย ในความหมายของมันน่ะ

00:09:05.000 --> 00:09:09.233
มันมีอะไรบางอย่างที่มันจะต้องการข้อมูลเพิ่มเติมอ่ะ

00:09:09.300 --> 00:09:10.233
นายบอกมาหน่อยซิ

00:09:10.300 --> 00:09:13.233
ว่าไอ้ข้อมูลเพิ่มเติมที่นายต้องการน่ะคืออะไรครับเนาะ

00:09:13.300 --> 00:09:16.133
ซึ่ง ณ ที่นี้ครับ มันก็คือข้อมูลเพิ่มเติมที่เป็น

00:09:16.700 --> 00:09:19.133
ตัว recent log นะครับเนาะ

00:09:19.200 --> 00:09:21.033
ซึ่ง เอ่อ ในเชิง technical เลยครับ

00:09:21.100 --> 00:09:23.233
ก็คือว่าเรา define ฟังก์ชันให้เขาครับ

00:09:23.300 --> 00:09:25.933
เราโยนฟังก์ชันที่เป็น define แต่เราไม่ได้โยนฟังก์ชันเข้าไป

00:09:26.000 --> 00:09:26.333
นะครับ

00:09:26.400 --> 00:09:29.533
เราโยน definition ของฟังก์ชันเข้าไปให้ LLM นะฮะ

00:09:29.600 --> 00:09:31.933
LLM เนี่ยจะพยายามวิเคราะห์แล้วดูว่าฟังก์ชันเนี้ย

00:09:32.000 --> 00:09:35.033
เป็นฟังก์ชันที่เขาควรเรียกมั้ยนะครับ กับคำถามที่เกิดขึ้น

00:09:35.100 --> 00:09:37.533
ถ้าเขาควรเรียกครับ เขาก็จะโยนกลับมาให้เราบอกว่า

00:09:37.600 --> 00:09:38.533
เออ เรียกฟังก์ชันนี้ให้หน่อย

00:09:39.000 --> 00:09:41.333
แล้วจากนั้นครับ เราก็พยายามเรียกฟังก์ชันครับ

00:09:41.800 --> 00:09:43.533
เรียกฟังก์ชันเสร็จปุ๊บ เราก็พยายาม

00:09:44.300 --> 00:09:46.333
เอาไอ้ data ให้ได้จากฟังก์ชันนั้นๆ น่ะครับ

00:09:46.600 --> 00:09:50.533
โยนกลับไปใหม่นะครับ ให้กับ LLM อีกรอบนึงนะครับเนาะ

00:09:50.600 --> 00:09:53.233
แล้วท่าของมันก็จะเป็นประมาณแบบนี้นะครับ

00:09:53.300 --> 00:09:58.533
ซึ่งก็คือ โดยสรุปของสไลด์ตัวนี้นะครับ ก็คือ

00:09:58.600 --> 00:10:00.333
ท่าแบบเมื่อกี้เนาะ นะครับ

00:10:00.800 --> 00:10:03.033
โอเค ซึ่งอันเนี้ยเป็นท่า RAG มาตรฐานครับ

00:10:03.100 --> 00:10:04.333
ผมว่าหลายๆ คนน่าจะพูดกันเยอะใช่มั้ยครับ

00:10:04.400 --> 00:10:07.733
ถ้าแบบว่า มันเรียกฟังก์ชัน

00:10:07.800 --> 00:10:10.933
ก็มีโอกาสที่ context ที่ได้มาจากฟังก์ชันที่มันมีอยู่

00:10:11.000 --> 00:10:15.533
นะครับ จะเกินตัว context window ของตัวโมเดล

00:10:16.400 --> 00:10:19.933
หมายถึงตัวโทเค็นที่จะส่งเข้าไปหรือเปล่าครับ

00:10:20.000 --> 00:10:26.433
จริงๆ ตรงนี้ครับ ต้องพูดก่อนว่ามันมีโอกาสมั้ย

00:10:26.500 --> 00:10:29.333
มีโอกาสที่ตัวโทเค็นจะเกินครับ แต่ว่าเรามีวิธี handle

00:10:29.400 --> 00:10:31.733
ได้หลายแบบนะครับ อย่างแรกคือเราเป็นคน handle

00:10:31.800 --> 00:10:34.633
memory เอง โอเค พอพูดถึง memory คนจะสับสนกันมาก

00:10:34.700 --> 00:10:37.733
ครับ memory ไม่ได้หมายถึง memory ที่เป็น memory

00:10:37.800 --> 00:10:40.733
แบบคอมพิวเตอร์แหละครับ แต่ว่าเรากำลังพูดถึงพวก

00:10:40.800 --> 00:10:42.833
ข้อมูลเหล่านี้นะครับ พวก message นะครับ

00:10:42.900 --> 00:10:45.833
ถ้าเกิดว่าใครรู้ครับว่า message ที่เราส่งเข้าไป

00:10:45.900 --> 00:10:47.933
ให้กับพวก LLM เนี่ย มันจะมี role ถูกมั้ยครับ

00:10:48.000 --> 00:10:50.133
role user role system role assistant

00:10:50.200 --> 00:10:52.833
อะไรอย่างเงี้ยครับ ตรงนี้เราสามารถ control memory

00:10:52.900 --> 00:10:54.533
เองได้นะครับ เพราะฉะนั้นครับ ตอบคำถามเมื่อกี้

00:10:54.600 --> 00:10:56.733
ในแบบแรกก่อนครับ ใช่ครับ มันมีโอกาสครับ

00:10:56.800 --> 00:10:58.833
แต่ว่าเราก็จะพยายาม handle ตรงนี้ครับ

00:10:58.900 --> 00:11:01.033
ไม่ให้มันเกิน อันนี้คือประเด็นแรกนะครับ

00:11:02.400 --> 00:11:05.333
ประเด็นที่ 2 ครับ โดยส่วนใหญ่นะครับ

00:11:05.400 --> 00:11:10.833
คำถามที่มันวิ่งเข้ามาหาเราครับ ตัว definition

00:11:11.100 --> 00:11:13.333
ของฟังก์ชันที่เรามีนะครับ เดี๋ยวผมเปิดให้ดูนะครับ

00:11:15.600 --> 00:11:17.933
definition ของฟังก์ชันที่เรามีครับ

00:11:18.000 --> 00:11:19.433
เราจะพยายามบอกอยู่แล้วครับว่า

00:11:19.500 --> 00:11:22.233
ฟังก์ชันนี้จะ call ก็ต่อเมื่อมันเป็นอะไรนะครับ

00:11:22.300 --> 00:11:25.033
ซึ่งโดย in general นะครับ ถ้าเกิดว่าคนนั้น

00:11:25.100 --> 00:11:26.633
ต้องการจะถามคำถามจริงๆ เนี่ยนะครับ

00:11:26.700 --> 00:11:29.033
มันก็จะ คือฟังก์ชันมันคงไม่ได้มีแค่ 2 ตัวนะครับ

00:11:29.100 --> 00:11:32.133
มันจะมีอื่นๆ นะครับ หรือว่าถ้าเกิดว่ามันมีการถาม

00:11:32.200 --> 00:11:35.333
แบบว่า เฮ้ย คุณถามฟังก์ชันนี้มา 3 รอบแล้วนะ

00:11:35.400 --> 00:11:37.133
ถ้าเกิดว่ามันเป็นรอบที่ 4 เนี่ย

00:11:37.200 --> 00:11:38.533
เราควรจะต้องไปเรียกอีกอันนึงแล้วนะ

00:11:38.600 --> 00:11:40.833
แล้วก็ควรจะต้อง reset memory อะไรอย่างเงี้ยครับ

00:11:40.900 --> 00:11:42.433
มันก็จะมีวิธีแบบนั้นเหมือนกันในการ handle

00:11:42.500 --> 00:11:44.533
หวังว่าตอบคำถาม ครับผม

00:11:45.400 --> 00:11:49.133
anyway ครับ มันก็จะมีคนที่พยายามถามเรื่องเดียวย้ำๆ

00:11:49.200 --> 00:11:51.233
ครับ อันนี้ก็เป็นหน้าที่ของ engineer

00:11:51.300 --> 00:11:56.033
อย่างพวกเราแล้วล่ะครับนะครับ

00:11:56.100 --> 00:11:59.633
ซึ่งถึงตรงนี้ครับ เราก็จะเห็นว่าโอเค

00:11:59.700 --> 00:12:03.133
เรายังไม่ได้แตะอะไรกับตัวที่เป็น MongoDB เลยนะครับ

00:12:03.200 --> 00:12:05.533
คือแตะแหละ เราพยายามไป fetch data นะครับ

00:12:05.600 --> 00:12:17.833
ออกมานะครับ โอเค เดี๋ยวผมโชว์ data ให้ดูนิดนึงครับ

00:12:17.900 --> 00:12:21.033
นี่คือ data นะครับ รอแป๊บนึงนะ

00:12:21.100 --> 00:12:25.333
เป็น system log ครับ มี request header body time

00:12:25.400 --> 00:12:28.233
บลาๆ โอเคมั้ยครับ ซึ่งวิธีที่ผมดึง

00:12:28.300 --> 00:12:30.333
ผมดึงตรงๆ เลยครับ ใช้ MongoDB ดึงออกมาเลยนะครับ

00:12:30.400 --> 00:12:33.133
ไม่ได้ใช้ AI อะไรเลย AI โยนมาปุ๊บ ผมดึงเลย

00:12:33.200 --> 00:12:36.333
fetch ตรงๆ นะครับ โอเค อันนี้อันนึงครับ

00:12:36.800 --> 00:12:42.333
แล้วคราวนี้ครับ ก็หลังจากได้ลองๆ ทำมาดูครับ

00:12:42.400 --> 00:12:45.633
ปรากฏเวลาเราทำ LLM ครับ หรือว่าเวลาที่เราใช้งาน

00:12:45.700 --> 00:12:48.633
กับมันนะครับ เราไม่ได้ทำ LLM เองอยู่แล้วถูกมั้ยครับ

00:12:48.700 --> 00:12:51.533
ถ้าเกิดว่าใครทุกคนรู้ครับ เราใช้โมเดลที่มันสำเร็จ

00:12:51.600 --> 00:12:54.533
แล้วเราก็จ่ายเงินให้กับเค้าผ่านการ usage ผ่าน API

00:12:54.600 --> 00:12:56.133
นะครับ หรือถ้าเกิดเราจะ host เองก็ได้ครับ

00:12:56.200 --> 00:12:57.733
แต่มันก็จะแพงพอสมควรนะครับ

00:12:57.800 --> 00:13:00.733
ซึ่งสิ่งที่ทำให้โมเดลมันแพงครับ หลักๆ ก็คือ

00:13:00.800 --> 00:13:03.033
computational power และสิ่งที่ทำให้ computational

00:13:03.100 --> 00:13:06.333
power มันสูงก็คือโทเค็นที่เราโยนเข้าไปให้กับเค้า

00:13:06.400 --> 00:13:07.833
แล้วเค้า generate มันออกมาถูกมั้ยครับ

00:13:07.900 --> 00:13:11.033
โทเค็นคืออะไร ก็พวกตัวที่มันเป็น message

00:13:11.100 --> 00:13:13.133
ของเรานั่นแหละครับนะครับ มันจะมีวิธีการนับโทเค็น

00:13:13.200 --> 00:13:15.133
ของมันนะครับ text message ยาวแบบนี้

00:13:15.200 --> 00:13:17.433
โยนเข้าไปปุ๊บ เค้าต้อง generate ออกมาเท่านี้ยาวๆ

00:13:17.700 --> 00:13:19.233
เนี่ย พวกนี้โทเค็นหมดเลยนะครับ

00:13:19.300 --> 00:13:22.333
ซึ่งก็จะ relate สู่เงิน และ computational power

00:13:22.400 --> 00:13:23.633
และเวลาถูกมั้ยครับ

00:13:23.900 --> 00:13:26.433
โอเค แล้วเราจะทำยังไงได้บ้างครับนะครับ

00:13:27.800 --> 00:13:31.033
หลังจาก work กับหลายๆ อย่างครับนะครับ

00:13:31.100 --> 00:13:33.033
เราก็เจอกับกระบวนการนึงครับ

00:13:33.100 --> 00:13:35.133
ที่เป็นกระบวนการแบบพื้นฐานมากๆ ครับ

00:13:35.200 --> 00:13:37.333
ในการทำกับ optimization นะครับ

00:13:39.900 --> 00:13:42.533
ก็คือการเพิ่ม cache ครับ simple มากครับ

00:13:42.600 --> 00:13:45.633
วิธีการ simple มากๆ ครับ เพิ่ม cache ครับนะครับ

00:13:45.900 --> 00:13:48.733
ก็เพิ่ม cache ปุ๊บ แทนที่เราจะต้องไปพยายาม

00:13:48.800 --> 00:13:51.633
fetch ตัว LLM ใช่มั้ยครับ

00:13:51.700 --> 00:13:54.033
เราก็ไม่จำเป็นจะต้อง fetch LLM แล้วถูกมั้ยครับ

00:13:54.100 --> 00:13:57.033
เราก็ยิงเข้ามาปุ๊บ เช็ก cache เช็ก cache เสร็จปุ๊บ

00:13:57.100 --> 00:14:00.433
ดึง cache return ออกไป เสร็จสิ้นใช่มั้ยครับ

00:14:01.300 --> 00:14:04.533
เป็นวิธีมาตรฐานนะครับ ก็เราจะลด load

00:14:04.600 --> 00:14:05.633
ได้ดีขึ้นถูกมั้ยครับ

00:14:07.000 --> 00:14:11.133
โอเค นี่คือ basic cache key and value ครับ

00:14:11.200 --> 00:14:13.633
โอเค เรามีวิธีอื่นครับ แต่ว่านี่เป็น basic

00:14:13.700 --> 00:14:16.333
พื้นฐานนะครับ key value database ครับ มี key

00:14:16.400 --> 00:14:18.433
มี value ครับ เรา log เข้าไปครับ จบครับ

00:14:18.500 --> 00:14:19.533
ดึง cache ออกมาใช่มั้ยครับ

00:14:19.600 --> 00:14:22.633
ถ้าเป็นแบบ request ทั่วๆ ไป เรา cache ยังไงครับ

00:14:22.700 --> 00:14:26.133
เราก็เอา user ID เราก็เอาข้อบางอย่างใช่มั้ย

00:14:26.200 --> 00:14:28.433
ทำเป็น key ตั้ง value เป็น data ถูกมั้ยครับ

00:14:28.500 --> 00:14:29.833
แล้วก็จบใช่มั้ยครับ

00:14:30.500 --> 00:14:33.733
แล้วถ้าเราเจอ นี่คือตัวอย่างนะครับ ใช่มั้ย

00:14:33.800 --> 00:14:41.733
เรามี ID ครับ เราดึง เราเอา ID มาใส่ cache

00:14:41.800 --> 00:14:47.333
ใช่มั้ยครับ แล้วก็ article data ใช่มั้ย จบนะครับ

00:14:47.400 --> 00:14:49.933
คำถามคือแล้วถ้ามันเป็นแบบนี้ล่ะนะครับ

00:14:50.600 --> 00:14:53.233
คำถามคือถ้าสีเขียวมันคือคำถามล่ะ

00:14:53.300 --> 00:14:55.433
แต่ถ้าสีแดงมันคือคำตอบล่ะนะครับ

00:14:55.500 --> 00:14:56.833
เราจะ cache มันยังไงครับ

00:14:57.400 --> 00:14:58.833
เอาสีเขียวยัดเข้า cache เลยมั้ยครับ

00:14:58.900 --> 00:15:01.733
สีเขียวยัดเข้า key เลย สีแดงยัดเป็น response ครับ

00:15:02.400 --> 00:15:03.533
ทำได้มั้ย ทำได้นะครับ

00:15:06.100 --> 00:15:08.133
แล้วถ้าเกิดว่า 3 อันนี้ล่ะครับ

00:15:09.000 --> 00:15:11.733
สมมติว่าเราจะ log 3 อันนี้เป็น cache

00:15:11.800 --> 00:15:13.833
เราก็ต้องทำไงครับ เราต้อง log 3 อันเป็น key

00:15:13.900 --> 00:15:15.633
ใช่มั้ยครับ แล้ว response เหมือนเดิมใช่มั้ยครับ

00:15:16.100 --> 00:15:17.733
หรือเปล่านะครับ

00:15:18.400 --> 00:15:19.933
จริงๆ แล้วครับ พอเราอ่านสิ่งนี้

00:15:20.000 --> 00:15:22.133
ถ้าเรารู้สึกเอ๊ะว่าทำไมเราถึงทำแบบนั้นนะครับ

00:15:22.400 --> 00:15:24.333
คือไม่แปลกครับ เพราะว่าคอมพิวเตอร์เนี่ย

00:15:24.800 --> 00:15:26.733
พอพูดถึง key value เค้าจะเข้าใจเป็นแบบ

00:15:26.800 --> 00:15:28.733
exact match นะครับใช่มั้ยครับ pattern matching

00:15:29.000 --> 00:15:31.433
ใช่มั้ยครับ การทำ cache โดยปกติคือการหา

00:15:31.500 --> 00:15:33.833
pattern matching จาก memory ที่เรามีเพื่อลด

00:15:33.900 --> 00:15:36.433
computational power ในการ compute นะครับ

00:15:36.500 --> 00:15:37.533
time complexity ใช่มั้ยครับ

00:15:37.900 --> 00:15:40.633
แต่สิ่งนี้ครับ มัน pattern matching ไม่ได้ครับ

00:15:40.700 --> 00:15:43.133
มันทำได้แหละ แต่มันไม่ efficient เราทำยังไง

00:15:43.200 --> 00:15:47.333
ใช่มั้ยครับ สิ่งนี้ ถึงแม้ว่ามันจะไม่เหมือนกัน

00:15:47.400 --> 00:15:48.833
ในเทอม pattern matching นะครับ

00:15:48.900 --> 00:15:51.433
แต่ว่าสิ่งที่มันเหมือนกันคือมันมี semantic meaning

00:15:51.500 --> 00:15:53.433
ที่เหมือนกันนะครับ semantic meaning

00:15:53.500 --> 00:15:56.933
ก็คือความหมายของคำที่เมื่อมัน convert เป็น vector

00:15:57.000 --> 00:15:58.533
เดี๋ยวอธิบายให้ฟัง vector คืออะไร

00:15:58.600 --> 00:15:59.833
เมื่อมัน convert เป็น vector แล้วครับ

00:15:59.900 --> 00:16:03.833
มันอยู่ในกลุ่มเดียวกันหรือกลุ่มใกล้ๆ กันนะครับนะครับ

00:16:04.200 --> 00:16:06.033
วิธีที่เรา cache ครับ เราจะไม่ได้ cache แบบ

00:16:06.100 --> 00:16:08.833
pattern matching แล้ว เราจะพยายามดึงสิ่งที่เป็น

00:16:08.900 --> 00:16:11.133
semantic meaning ออกมา แล้วเอาสิ่งนี้ไปเป็น key

00:16:11.200 --> 00:16:13.433
ในการ cache แล้วจากนั้นก็เอา response ครับ

00:16:13.500 --> 00:16:16.333
ไปเป็นตัว response ของมัน

00:16:16.400 --> 00:16:22.333
ลองดูนะ semantic meaning ครับ semantic search ครับ

00:16:23.600 --> 00:16:25.733
ถ้าเราสามารถดึง semantic meaning ได้ครับ

00:16:25.800 --> 00:16:27.533
เราก็สามารถทำ semantic search ได้ครับ

00:16:27.600 --> 00:16:28.933
semantic search ก็คือการ search

00:16:29.000 --> 00:16:30.933
ผ่านความหมายของมันนะครับ

00:16:31.000 --> 00:16:32.233
ถ้าเราทำ semantic search ได้

00:16:32.300 --> 00:16:34.433
เราก็สามารถ semantic cache หรือว่า cache by

00:16:34.500 --> 00:16:38.033
ความหมายได้ครับ นี่คือวิธีการที่เรากำลังจะพูดถึง

00:16:38.100 --> 00:16:41.033
ต่อไปนะครับ semantic meaning ก่อนนะครับ

00:16:43.900 --> 00:16:47.133
วิธีการที่ AI เข้าใจ data นะครับ

00:16:47.200 --> 00:16:48.833
ผมว่าหลายๆ คนน่าจะเคยคุ้นเนาะ

00:16:48.900 --> 00:16:50.233
เขาไม่ได้เข้าใจ text นะครับ

00:16:50.300 --> 00:16:53.433
เขาจะต้องพยายามแปลง text ให้มันกลายเป็นสิ่งที่ชื่อว่า

00:16:53.500 --> 00:16:55.033
สิ่งที่เป็นตัวเลขเนาะ numerical data

00:16:55.400 --> 00:16:58.833
แล้วเราก็มักจะมีความหมายของคำนี้ก็คือ vector ถูกไหมครับ

00:17:00.000 --> 00:17:02.833
คำว่า embedding, vectorizing, encoding สิ่งเหล่านี้ครับ

00:17:02.900 --> 00:17:05.032
คือการพยายามแปลง string ให้มันกลายเป็น vector

00:17:05.099 --> 00:17:06.133
แล้วก็อาศัย pre-trained

00:17:06.200 --> 00:17:08.933
เพื่อที่จะพยายามหาความหมายให้กับคำเหล่านั้นเนาะ

00:17:09.000 --> 00:17:11.532
ใช่ไหมครับ เดี๋ยวลองดูครับ

00:17:11.900 --> 00:17:16.833
vector หน้าตาเป็นยังไงครับ หน้าตาเป็นแบบนี้เลยครับ

00:17:17.300 --> 00:17:19.333
นะครับ เราโยน text เข้าไปครับ

00:17:20.300 --> 00:17:24.633
แล้วเราก็ได้ vector ออกมาจากฝั่งขวานะครับเนาะ

00:17:24.700 --> 00:17:26.733
vector เหล่านี้ครับ หน้าตาของมันก็จะเป็น

00:17:27.900 --> 00:17:30.233
เห็นเนาะ มันคือตัวเลขแหละครับ

00:17:30.300 --> 00:17:32.633
มันคือตัวเลขนั่นแหละครับ มองเป็นตัวเลขตัวนึงนะครับ

00:17:32.700 --> 00:17:34.833
ที่เป็น set of ตัวเลขบางอย่างนะครับ

00:17:35.100 --> 00:17:37.433
คราวนี้ครับ การจะแปลงให้เป็น vector ได้ครับ

00:17:37.500 --> 00:17:40.333
มันจะต้องใช้สิ่งที่ชื่อว่า embedding model เนาะนะครับ

00:17:40.400 --> 00:17:42.633
ก็เป็น LLM sub ของ LLM

00:17:42.700 --> 00:17:46.633
ที่เอาไว้สำหรับแบบหาความหมายของคำนั้นๆ นะครับ

00:17:47.500 --> 00:17:49.433
ผมคงไม่ลงลึกว่ามันถูก train มายังไง

00:17:49.500 --> 00:17:51.233
หลักๆ ก็คือว่า มันจะถูก train

00:17:51.300 --> 00:17:53.533
มันจะมีการ match คำกับความหมายนะครับ

00:17:53.800 --> 00:17:55.033
เป็น vector แบบนี้

00:17:55.100 --> 00:17:56.533
แล้วจากนั้น พอมันได้คำหมายเข้าไป

00:17:56.600 --> 00:17:59.133
มันก็จะพยายาม expose หรือว่า return

00:17:59.200 --> 00:18:02.033
ตัว vector ออกมาให้เรานะครับเนาะ

00:18:02.100 --> 00:18:03.833
มองมันเป็น array of number ก็ได้นะฮะ

00:18:04.700 --> 00:18:10.833
โอเค แล้วคราวนี้ vector search คืออะไรนะครับ พอเรามี

00:18:11.500 --> 00:18:14.633
อย่างที่บอกเนาะ พยายามที่จะหา semantic search

00:18:15.000 --> 00:18:16.633
semantic คือความหมายใช่ไหมครับ

00:18:16.700 --> 00:18:18.433
เราจะแบบทำ pattern matching ไม่ได้แล้ว

00:18:18.500 --> 00:18:20.833
สิ่งที่มันสามารถทำได้ก็คือ

00:18:21.200 --> 00:18:23.433
เราเอา vector เนี่ย ที่มันเป็นตัวเลขเนี่ย

00:18:23.500 --> 00:18:26.333
ใช่ไหมครับ ตัวเลขเนี่ยอาจจะเป็น array ใช่ไหมครับ

00:18:28.500 --> 00:18:32.533
สมมติว่า array มีตัวเลขอยู่ในนั้นซัก 10 ตัวครับเนาะ

00:18:32.600 --> 00:18:35.633
10 ตัวเนี่ยเราก็คือมี array 10 ตัวเนี่ย

00:18:35.700 --> 00:18:37.033
เมื่อ plot ออกมาเป็นกราฟครับ

00:18:37.100 --> 00:18:38.033
ถ้าเรา plot มาเป็นกราฟเนาะ

00:18:38.100 --> 00:18:40.033
เราสามารถ plot เป็นกราฟแบบ 10 มิติได้นะครับ

00:18:40.300 --> 00:18:43.133
ซึ่ง 10 มิติเป็นยังไงก็ไม่รู้นะครับ แต่ว่าเราจะสามารถ plot มา

00:18:43.200 --> 00:18:45.233
ในการเข้าสมการทางคณิตศาสตร์ตัวนึงนะครับ

00:18:45.300 --> 00:18:49.133
ก็คือการหา similarity บางอย่างนะครับ ไอ้จุดตรงนี้ครับ

00:18:49.700 --> 00:18:52.933
จุดตรงนี้ครับ มันก็คือ array ที่มีเลขอยู่ข้างในนะครับ

00:18:53.200 --> 00:18:56.533
แล้วจากนั้นเนี่ย เมื่อมันเข้าสมการตรงนั้นแล้วมัน plot ออกมาครับ

00:18:56.600 --> 00:18:58.933
มันก็จะกลายเป็นจุดที่อยู่บนนี้เนาะ

00:18:59.000 --> 00:18:59.733
แล้วจากนั้นนะครับ

00:18:59.800 --> 00:19:02.333
เราก็จะเห็นว่าจุดบางจุดอยู่ใกล้กับจุดอื่นๆ นะครับ

00:19:02.400 --> 00:19:04.433
ในขณะที่จุดบางจุดอยู่ไกลจังเลยนะครับ

00:19:05.000 --> 00:19:07.833
นี่แหละครับ คือการทำสิ่งที่ชื่อว่า semantic search

00:19:08.800 --> 00:19:12.233
หรือว่าการหา similarity ความหมายของมันเนาะ

00:19:12.300 --> 00:19:14.133
อย่าง 2 จุดนี้ครับ มันมีความหมายที่ใกล้กัน

00:19:14.200 --> 00:19:16.833
เพราะฉะนั้นมันจะต้องสามารถถูก group

00:19:16.900 --> 00:19:19.833
หรือว่าถูกดึง หรือว่าถูก search แล้วเนี่ย

00:19:19.900 --> 00:19:21.233
มันจะต้องมี score ที่สูงกว่า

00:19:21.300 --> 00:19:24.333
เมื่อหาความใกล้เคียงกันของ 2 คำนี้ ใช่ไหมครับ

00:19:25.200 --> 00:19:29.333
โอเคครับ

00:19:30.000 --> 00:19:38.533
MongoDB ครับ มีการทำสิ่งที่ชื่อว่า vector search ครับ

00:19:38.600 --> 00:19:41.533
vector search มองมันเป็น index ตัวนึงครับ

00:19:41.800 --> 00:19:45.533
มันคือการพยายามที่จะสร้าง index ตัวนึงขึ้นมาครับ

00:19:45.600 --> 00:19:47.533
แล้วก็ใช้ machine learning model ครับ

00:19:47.600 --> 00:19:51.333
ในการที่จะเอาค่าจาก index ตัวนี้ครับ

00:19:51.400 --> 00:19:55.733
ไป operate ในการ search หรือหาอะไรบางอย่างนะครับ

00:19:55.800 --> 00:20:00.833
อย่างตรงนี้ครับ ก็เป็นfield ในการสร้างนะครับเนาะ

00:20:00.900 --> 00:20:03.433
ก็ function similarity ครับ

00:20:03.500 --> 00:20:06.133
หรือว่าก็คือเนี่ย วิธีการที่เราจะหาไอ้จุด 2 จุดนี้

00:20:06.200 --> 00:20:08.433
มันใกล้กันไหมเนี่ย มีหลาย function นะครับ

00:20:08.900 --> 00:20:10.633
machine learning model ที่เขาใช้

00:20:10.700 --> 00:20:12.433
ณ ปัจจุบันแล้วก็กำลังจะมีเพิ่มขึ้นเรื่อยๆ

00:20:12.500 --> 00:20:24.733
function ที่เราจะสามารถหา similarity

00:20:24.800 --> 00:20:27.733
ข้างในได้ปัจจุบันนะครับ มีอยู่ 3 ตัวนะครับเนาะ

00:20:28.000 --> 00:20:29.733
ก็คือ similarity function นะครับ

00:20:29.800 --> 00:20:31.933
ถ้าใครเรียน math มาเนาะ euclidean, cosine

00:20:33.400 --> 00:20:36.633
แล้วก็ตัว dot product ถูกไหมครับเนาะ

00:20:37.100 --> 00:20:42.933
เดี๋ยวผมลองเปิดให้ดูนะครับว่าหน้าตาของมันเป็นยังไงเนาะ

00:20:47.500 --> 00:20:49.733
โอเค เดี๋ยวเปิดให้ดูนะครับ

00:20:49.800 --> 00:20:50.933
แต่ว่ามันเป็นอย่างนี้แหละครับ

00:20:51.000 --> 00:20:53.833
หน้าตาตัวนี้คือผมก็แคปออกมาจากตัวนั้นแหละนะครับ

00:20:53.900 --> 00:20:58.533
เดี๋ยวเอาไว้เปิดให้ดูตอนเรา walk through code แล้วกันนะครับ

00:20:59.800 --> 00:21:03.233
คราวนี้ครับ เราเก็บ data ยังไงนะครับ

00:21:03.300 --> 00:21:04.733
เรา cache ยังไงนะครับ

00:21:04.800 --> 00:21:06.033
เดี๋ยวลองมา walk through กันครับ

00:21:08.900 --> 00:21:13.833
วิธีการที่เรา retrieve cache ก่อนนะครับ

00:21:14.300 --> 00:21:15.733
มันน่าจะ simple สุดนะครับ

00:21:15.800 --> 00:21:17.633
เดี๋ยวผมจะเปิดให้ดูนะฮะ

00:21:17.700 --> 00:21:19.933
retrieve cache จะทำแบบนี้ครับ เรามี question

00:21:20.500 --> 00:21:22.133
เราเอา question ที่ได้มาครับ

00:21:22.200 --> 00:21:24.333
embed เข้าไปในตัว embedding model

00:21:24.600 --> 00:21:25.933
เพื่อ get vector ออกมาเนาะ

00:21:26.500 --> 00:21:31.433
เอา vector ที่ได้ครับ ไป search ผ่านกระบวนการที่ 3 ครับ

00:21:31.500 --> 00:21:34.033
แล้วจากนั้นเมื่อมันได้ เมื่อมัน search แล้วมันหา similarity ได้

00:21:34.100 --> 00:21:35.833
มันจะ return ออกมาในกระบวนการที่ 4 นะครับ

00:21:35.900 --> 00:21:38.733
เดี๋ยวลองดูทำยังไงนะฮะ

00:21:39.100 --> 00:21:43.833
ผมมีไฟล์ที่ชื่อว่า app_cache นะครับเนาะ

00:21:43.900 --> 00:21:46.233
app_cache ทำอะไรครับ อันเดิมเลยครับ

00:21:46.900 --> 00:21:48.933
อันเดิมเลยเนาะ อันเดิมเลยนะครับ

00:21:49.000 --> 00:21:51.133
monitoring assistant นะครับ

00:21:51.700 --> 00:21:54.733
หน้าที่ของเขาครับ เมื่อเขาได้รับคำสั่งเข้ามาครับ

00:21:54.800 --> 00:22:01.733
อย่างเช่น How about my system today เนาะ

00:22:04.300 --> 00:22:05.033
มันจะไม่เห็นภาพ

00:22:05.300 --> 00:22:08.433
ผมว่าผมลองถามคำถามที่มันแบบต่างกันมากๆ เลยครับ

00:22:12.200 --> 00:22:15.533
ไม่น่าจะตอบได้นะ ถ้าผมชื่ออะไรนะ มันจะตอบได้ไหม

00:22:17.000 --> 00:22:18.033
Sorry, I don't know ครับ

00:22:18.100 --> 00:22:19.933
I have no access to your private information.

00:22:20.000 --> 00:22:21.733
That's good นะครับ โอเคนะครับ

00:22:21.800 --> 00:22:24.033
หรือว่าถ้าเกิดว่าเราลองถามอะไรที่มันแบบยาวกว่าหน่อย

00:22:24.100 --> 00:22:24.933
ที่มันเกี่ยวกับ system เนาะ

00:22:31.500 --> 00:22:33.633
ครับ คิดว่าสิ่งที่เราจะเบรกไหมครับ อาทิตย์หน้า

00:22:37.500 --> 00:22:39.933
อืม สิ่งที่มันทำก็คือมันพยายามที่จะ get

00:22:40.000 --> 00:22:44.233
เอาพวกข้อมูลที่มันเป็นดีนายอะนะครับ

00:22:44.300 --> 00:22:46.333
ข้อมูลที่มันแบบแปลกๆ ออกมาเนาะ

00:22:46.400 --> 00:22:48.233
แล้วก็พยายามวิเคราะห์ให้เรา ใช่ไหมครับ

00:22:48.900 --> 00:22:51.633
โอเค วิธีการที่มัน retrieve คือมันทำแบบนี้ครับเนาะ

00:22:51.700 --> 00:22:54.533
มันเอาอันนี้เข้ามา embed เสร็จปุ๊บครับ ครับผม

00:22:55.700 --> 00:22:59.733
Q: เรารู้ได้ยังไงครับว่า cache เรามันกว้างเกินไป

00:23:00.500 --> 00:23:04.333
อย่างเช่น อย่างเมื่อกี้ถามว่าอาทิตย์หน้าฝนจะตกหรือเปล่า

00:23:04.900 --> 00:23:08.033
ครับ มันตอบออกมา มันเอาตอบมาให้อยู่ ครับ

00:23:08.100 --> 00:23:12.233
แต่ไม่ใช่สิ่งที่เราอยากได้

00:23:12.500 --> 00:23:16.033
แต่กลายเป็นว่า similarity score มันคล้ายมากเกินไป

00:23:16.100 --> 00:23:19.833
อะไรเงี้ยครับ ถ้าเจออย่างงี้จะต้องทำยังไงครับ ครับ

00:23:19.900 --> 00:23:22.333
James: โดยส่วนใหญ่นะครับ เวลาที่เรา cache นะครับ

00:23:22.400 --> 00:23:26.933
เราจะพยายาม cache จากตัวของเป็นคำที่นะครับ

00:23:27.000 --> 00:23:31.633
จากตัวของ meaning ที่เราจะต้องดู 2 ส่วนเนาะ

00:23:31.700 --> 00:23:33.833
หลักๆ ที่เคยทำมาครับ meaning ของมันครับ

00:23:34.100 --> 00:23:36.433
กับตัว cache ของเราเองด้วยครับ

00:23:36.700 --> 00:23:41.133
อย่างเช่นนะครับ อย่างเช่น ถ้ามันถามว่า next week

00:23:41.200 --> 00:23:42.833
เนี่ยครับ next week เป็นคำที่กว้างเนาะ

00:23:42.900 --> 00:23:44.533
next week เนี่ย จริงๆ แล้ว next week นะครับ

00:23:44.600 --> 00:23:46.633
สิ่งที่มันควรจะเป็นจริงๆ ก็คือมันควรจะต้องไม่ได้

00:23:46.700 --> 00:23:47.933
เอาแค่ว่า next week คืออะไร

00:23:48.000 --> 00:23:50.533
แต่มันควรจะต้องเอา data ของปัจจุบันมาด้วยถูกไหมฮะ

00:23:50.600 --> 00:23:52.533
ว่า today คืออะไรใช่ไหมครับ

00:23:52.600 --> 00:23:54.833
แล้วพยายามวิ่งไปหา next week จาก today

00:23:54.900 --> 00:23:56.233
วิ่งไปข้างหน้าถูกไหมฮะ

00:23:56.300 --> 00:23:59.733
อะ ถ้าเป็นแบบเนี้ยครับ เรา สิ่งที่เราต้องทำก็คือว่า

00:23:59.800 --> 00:24:02.133
ไอ้ตอนที่มันไปดึง เราก็ต้องไป define

00:24:02.200 --> 00:24:04.433
ตัว pre-define function ของมันอะนะครับเนาะ

00:24:04.500 --> 00:24:06.033
ซึ่งอยู่ตรงเนี้ยนะ นะครับ

00:24:06.100 --> 00:24:07.633
ให้มันมี function ตัวนึงนะครับ

00:24:07.700 --> 00:24:10.733
ที่มันเอาไว้สำหรับว่าถ้ามันมีการถามเกี่ยวกับเวลาครับ

00:24:10.800 --> 00:24:12.633
ให้มันเรียก function นี้ก่อนนะครับ

00:24:12.700 --> 00:24:14.633
แล้ว function เนี้ย บอกเค้าว่าโอเค

00:24:14.700 --> 00:24:16.633
คำว่า next week กับเวลาของมันจริงๆ คือแบบนี้ครับ

00:24:16.900 --> 00:24:20.033
แล้วจากนั้นครับ มันก็ เราก็เอาไอ้สิ่งเนี้ยครับ

00:24:20.700 --> 00:24:24.533
ไป look up ต่อเนาะว่า เฮ้ย ใน cache ของเราเนี่ยครับ

00:24:24.600 --> 00:24:25.633
มันเป็นแบบไหนนะครับ

00:24:25.700 --> 00:24:27.233
ซึ่งเราสามารถกดเข้าไปใน embed ได้

00:24:27.300 --> 00:24:29.033
แต่ตอนเนี้ยครับ วิธีที่ผม embed เข้าไปเนี่ย

00:24:29.100 --> 00:24:31.533
คือผม embed question อย่างเดียว โอเคไหมฮะ

00:24:31.600 --> 00:24:33.733
มันเลย มันเลยใช่ครับ มันเลยกว้างไปนิดนึงครับ

00:24:33.800 --> 00:24:35.433
ถ้าเกิดว่าจะ embed ในกรณีแบบเนี้ยครับ

00:24:35.500 --> 00:24:37.233
เราควรจะ embed ทั้ง question และ embed

00:24:37.300 --> 00:24:40.533
ทั้ง time ซึ่งเป็น specific range ลงไปด้วยครับ

00:24:40.600 --> 00:24:42.533
มันก็จะ specific ข้อความมากขึ้น

00:24:43.300 --> 00:24:47.133
Q: คือผมจะบอกว่า ถ้าสมมติว่าเราไม่ทำ cache เนี่ย

00:24:47.700 --> 00:24:49.333
แล้วถ้าเราถามคำถามเมื่อกี้ไป

00:24:50.500 --> 00:24:53.333
มันควรจะตอบว่ามันไม่มีข้อมูล…ถูกต้องไหมครับ

00:24:55.500 --> 00:25:00.633
ขอคำถามใหม่ครับ คือ สมมติว่าถ้าไม่ได้ทำ cache

00:25:00.900 --> 00:25:04.233
ถ้าไม่ได้ cache ตัว embedding ไว้

00:25:04.800 --> 00:25:05.733
แล้วเราถามคำถามว่า ที่ไม่เกี่ยวข้องกับ function

00:25:05.800 --> 00:25:07.433
ที่เรามีให้เนาะ ใช่ปะ ครับ

00:25:07.600 --> 00:25:10.633
มันก็ควรจะตอบคล้ายๆ กับที่มันตอบที่ที่เราถามว่า

00:25:11.000 --> 00:25:11.833
พ่อเราชื่ออะไร

00:25:11.900 --> 00:25:14.433
James: อ๋อ ใช่ครับ ถ้าเรา define function

00:25:14.500 --> 00:25:16.433
ที่มันแบบกำหนดเวลาไปแล้วเนาะ ใช่ครับ

00:25:16.500 --> 00:25:17.233
มันควรจะตอบแบบนั้น แต่ว่าพอเราทำ cache เสร็จ

00:25:17.800 --> 00:25:18.333
ใช่ครับ ครับ

00:25:18.900 --> 00:25:20.633
Q: แต่พอเราทำ cache

00:25:20.700 --> 00:25:23.033
ปรากฏว่าคำถามที่มันไม่ควรจะเข้า cache

00:25:23.400 --> 00:25:25.333
มันก็เลยมีโอกาสที่มันจะเข้า cache ครับ

00:25:26.100 --> 00:25:28.933
James: มันจะไม่เข้า cache ครับ เพราะว่าถ้าเกิดว่าเราทำแบบนั้นปุ๊บ

00:25:29.000 --> 00:25:31.633
เรา อย่างที่บอกครับ ตอนเนี้ยเราใช้ query

00:25:31.900 --> 00:25:34.533
ในการทำ embed เข้าไปถูกไหมครับ

00:25:34.600 --> 00:25:35.733
แต่ถ้าเกิดว่าเราทำแบบนั้นปุ๊บ

00:25:36.100 --> 00:25:37.833
เราจะไม่ได้ใช้แค่ query ในการ embed

00:25:37.900 --> 00:25:40.633
เราจะใช้ query บวกกับเวลา embed เข้าไปเลยครับ

00:25:40.700 --> 00:25:42.733
เพราะฉะนั้น meaning ของมันจะไม่ใช่แค่ query แล้ว

00:25:42.800 --> 00:25:45.033
มันคือ query บวกเวลาและ เพราะฉะนั้นนะครับ

00:25:45.100 --> 00:25:46.933
embedding vector ที่ได้ออกมาเนี่ย

00:25:47.000 --> 00:25:48.333
ก็จะไม่เหมือนกัน ครับ

00:25:48.400 --> 00:25:50.033
ค่าของ score ก็จะต่ำลงมา

00:25:50.100 --> 00:25:52.733
แต่อันนี้ก็ขึ้นอยู่กับว่าเราวัด score ยังไง ครับ

00:25:54.200 --> 00:25:56.733
ครับ โอเคครับ เดี๋ยวๆ ให้ดู score ครับ

00:25:56.800 --> 00:25:58.733
มันมีวิธีวัด score ของมันอยู่เนาะ นะครับ

00:26:01.400 --> 00:26:02.833
กำลังนึกอยู่ว่าถึงไหนแล้วนะฮะ

00:26:02.900 --> 00:26:08.933
โอเค วิธีการครับก็คือ พอวิ่งเข้ามาปุ๊บ ใช่ไหมครับ

00:26:09.000 --> 00:26:13.133
อะ monitoring ใช่ไหมครับ เสร็จปุ๊บใช่ไหมครับ

00:26:13.200 --> 00:26:14.633
วิธีการที่ผมทำก็คือ อะ

00:26:14.700 --> 00:26:16.833
ผมลองเข้าไปดูที่ cache handler นะครับ

00:26:17.200 --> 00:26:19.233
มันเป็น class ตัวนึงที่ผมสร้างขึ้นมาเองนะฮะ

00:26:26.000 --> 00:26:28.933
เออ ผมพึ่งรู้ว่าเค้ามีสิ่งนี้ให้เราแล้วนะฮะ โอเคฮะ

00:26:31.100 --> 00:26:33.633
เอิ่ม อะ ลอง find ดูนะครับ จริงๆ อะครับ

00:26:33.700 --> 00:26:36.733
ไอ้เจ้าตัว vector index อะครับ มันก็คือ

00:26:37.300 --> 00:26:39.733
เราสามารถที่จะ retrieve data ของมันออกมาได้

00:26:39.800 --> 00:26:42.433
จากการทำ aggregation pipeline นะครับ

00:26:42.500 --> 00:26:44.233
aggregation pipeline ของผมเนี่ยนะครับ

00:26:44.300 --> 00:26:47.233
ก็คือแบบนี้เลยครับ ก็คือเรา วิ่งเข้าไปนะครับ

00:26:47.300 --> 00:26:49.833
เอา text มาครับ เอา text ไป get embedding ออกมาครับ

00:26:49.900 --> 00:26:52.633
จากนั้นเสร็จปุ๊บ เอาไปใส่ vector search นะครับ

00:26:52.900 --> 00:26:55.033
ก็บอกไปครับ อันนี้ก็คือตัวกำหนดแหละว่า

00:26:55.100 --> 00:26:57.133
เออ เราใช้ index อะไร path อะไรนะครับ

00:26:57.200 --> 00:26:59.733
อะ เดี๋ยวเราลองดูเนาะ นี่คือ cache ของผมนะครับ

00:27:00.200 --> 00:27:02.233
cache ผมเนี่ยมีอะไรบ้าง ผมมี query นะครับ

00:27:02.600 --> 00:27:06.933
อ่า มี response นะครับ แล้วก็มี embedding นะครับ

00:27:07.000 --> 00:27:08.433
วิธีการที่ผมก็คือระบุเข้าไปว่า

00:27:08.500 --> 00:27:11.833
เออ path ในการที่จะใช้ embed ข้อมูลอะ มันคือตัวนี้นะ

00:27:12.100 --> 00:27:15.033
นะครับ จากนั้นเสร็จปุ๊บครับ ก็โยนเข้าไปครับ

00:27:15.100 --> 00:27:17.633
แล้วก็นัมเบอร์ออฟ candidate ก็คือตัว ตัว candidate

00:27:17.700 --> 00:27:19.533
อะครับ ที่ ที่เป็น สุด

00:27:19.600 --> 00:27:21.533
ถ้าเกิดว่าเรากลับไปดูกราฟอะเนาะ มันจะมีจุดๆๆ

00:27:21.600 --> 00:27:24.333
ใช่ไหมครับ ก็ลองดูครับว่าถ้าเกิดข้อมูลนี้วิ่งเข้าไปเนี่ย

00:27:24.400 --> 00:27:26.933
แล้วแบบ มันมี candidate ที่อยู่ใกล้กันเนี่ย

00:27:27.000 --> 00:27:29.833
จำนวน 20 ตัวเนี่ย ไหมเนี่ย

00:27:29.900 --> 00:27:32.233
เมื่อมัน match นะครับ ก็ให้มัน extract ออกมาเนาะ

00:27:32.300 --> 00:27:35.433
นะครับ จากนั้นครับ ผมก็ทำการครับ add field

00:27:35.500 --> 00:27:36.733
สิ่งที่ชื่อว่า score เข้าไปครับ

00:27:36.800 --> 00:27:39.633
โดยการดึงตัว vector search score เข้ามาใส่นะครับ

00:27:39.700 --> 00:27:41.733
จากนั้นครับ ผมจะไม่ได้เอามาทั้งหมดเนาะ

00:27:41.800 --> 00:27:43.033
เพราะอย่างที่บอกครับ บางทีเนี่ย

00:27:43.300 --> 00:27:45.533
ความแม่นของมันเนี่ยก็ขึ้นกับ score นะครับ

00:27:45.600 --> 00:27:48.033
แต่ว่า score เนี่ยยิ่งแม่นเท่าไหร่

00:27:48.100 --> 00:27:51.833
ก็จะยิ่ง retrieve ข้อมูลออกมาได้ เจาะจงแหละ yes นะครับ

00:27:51.900 --> 00:27:55.733
แต่ก็ถ้าเกิดว่า มันขึ้นกับหลายแบบเนาะ บางทีเนี่ย

00:27:56.200 --> 00:27:58.333
model ที่เราใช้อะครับ ในการที่เรา embed

00:27:58.400 --> 00:28:00.333
ค่าเข้าไปครับ มันอาจจะเป็น model ที่ pre-train

00:28:00.400 --> 00:28:03.133
มาแล้วมันรู้จักคำได้น้อยกว่า model อีกตัวนึง

00:28:03.200 --> 00:28:06.033
ที่มีความแม่น แต่ก็แลกมากับความเบาใช่ไหมครับ

00:28:06.700 --> 00:28:07.733
ตัว score ตรงเนี้ยครับ

00:28:07.800 --> 00:28:09.933
มันก็ต้องปรับให้ตรงกับตรงนั้นนะครับ

00:28:10.000 --> 00:28:11.133
อย่างผมเคยใช้อันนี้

00:28:11.200 --> 00:28:15.433
ผมน่าจะใช้เป็น Azure OpenAI แบบ small embedding

00:28:15.500 --> 00:28:16.433
model นะครับ

00:28:16.800 --> 00:28:18.933
อ่า keyword เดียวกันนะครับ

00:28:19.000 --> 00:28:21.133
เมื่อเทียบกับที่มันเป็น large ตัว embedding model

00:28:21.200 --> 00:28:23.733
นะครับ score ต่างกันประมาณ 20 0.20

00:28:23.800 --> 00:28:24.733
อะไรอย่างเงี้ยนะครับ

00:28:25.200 --> 00:28:26.733
ก็อันนี้ก็ต้องมา fine-tune กันเนาะ

00:28:26.800 --> 00:28:28.733
ก็เป็นงาน in general ของเรานะครับ

00:28:28.800 --> 00:28:32.333
ก็วัด score ออกมาครับ เสร็จปุ๊บยิงเข้า aggregation ครับ

00:28:32.800 --> 00:28:34.333
แล้วก็ return result ออกมาครับ ครับ

00:28:36.000 --> 00:28:38.533
เราก็จะได้ result ออกมาว่า เออ มัน มันเจอไหมครับ

00:28:38.800 --> 00:28:41.533
ถ้ามันเจอครับ return ออกมาเลยครับเนาะ ใช่ไหม

00:28:41.900 --> 00:28:45.633
ถ้ามันไม่เจอ ก็ ก็ตามท่า cache ไปต่อครับ

00:28:45.700 --> 00:28:49.433
คำนวณครับ ก็เอาเลยครับ ก็สร้าง prompt ใช่ไหมครับ

00:28:49.500 --> 00:28:52.633
ดูซิว่ามันต้องดึง function ไหม ถ้ามันต้องดึงก็ดึงครับ

00:28:53.200 --> 00:28:57.633
ดึงอะไรเสร็จปุ๊บ อ่า ผมน่าจะเอาไว้แถวนี้

00:28:59.800 --> 00:29:02.633
อ่า นี่ครับ จริงๆ มันมี 2 ที่นะ มีที่นี่กับที่ข้างล่างนะ

00:29:02.700 --> 00:29:06.933
อะ การเซฟครับ ก็ ตรงไปตรงมาครับ

00:29:07.000 --> 00:29:10.433
คือการเซฟเนี่ยก็คือว่าเราจะไม่ได้เซฟผ่าน

00:29:11.800 --> 00:29:14.233
เราจะไม่ได้เซฟผ่าน pattern matching ใช่ไหมครับ

00:29:14.300 --> 00:29:15.933
เราจะเซฟผ่าน path

00:29:16.000 --> 00:29:19.733
ตัว embedding ที่เราได้ออกมาก็คือ vector ใช่ไหมครับ

00:29:19.800 --> 00:29:21.133
เพื่อให้มันทำ vector search ได้นะครับ

00:29:21.400 --> 00:29:23.433
แล้วจากนั้นเนี่ยเราก็ ที่ผมใส่ query

00:29:23.500 --> 00:29:25.033
เข้าไปเพื่อให้มันเห็นภาพมากขึ้นเนาะว่า

00:29:25.100 --> 00:29:27.233
เออ ไอ้ตรงนี้มันคือ query อะไรนะครับเนาะ

00:29:27.500 --> 00:29:29.133
แล้วก็ใส่ embedding เข้าไปนะครับ

00:29:29.200 --> 00:29:30.533
ใส่ response เข้าไปนะครับ

00:29:31.500 --> 00:29:34.033
จากนั้นปุ๊บพอเซฟก็จะได้ออกมาเป็นแบบนี้ นะฮะ

00:29:34.100 --> 00:29:40.933
ก็ ครับ จริงๆ แล้ว ถ้าเกิดว่าเราอยากจะให้มัน

00:29:41.000 --> 00:29:42.033
มีความเจาะจงมากขึ้น

00:29:42.100 --> 00:29:44.333
อย่างเช่นพี่ท่านเมื่อกี้พูดเป็นคำถามที่ดีนะครับ

00:29:44.400 --> 00:29:46.233
หรือว่ามันจะต้องมี scenario บางอย่าง

00:29:46.300 --> 00:29:47.633
ที่มันใช้แค่ query ไม่ได้

00:29:47.700 --> 00:29:49.233
เป็น question ไม่ได้เนี่ยนะครับ

00:29:49.300 --> 00:29:51.033
เราก็จะต้องเอาตรงนั้นนะครับ เข้าไป embed

00:29:51.100 --> 00:29:52.633
กับ model ด้วย เพื่อให้ model มัน

00:29:52.700 --> 00:29:55.333
มันสามารถบอกได้ว่าไอ้สิ่งเนี้ยมันเจาะจงมากขึ้นนะ

00:29:55.400 --> 00:29:56.933
พอเวลามันวัด score ออกมาครับ

00:29:57.500 --> 00:29:59.733
ของคำสั่งตัวเนี้ยเนาะ นะครับ score ของมันเนี่ย

00:29:59.800 --> 00:30:03.833
จะได้ไม่ mess กับตัวของ

00:30:03.900 --> 00:30:06.233
criteria ที่เราตั้งนะครับ

00:30:06.300 --> 00:30:10.433
อันนี้ก็ต้อง fine-tune กันอีกทีนึงนะครับ โอเคนะครับ

00:30:12.400 --> 00:30:19.233
โอเคครับ ทั้งหมดทั้งมวลครับ

00:30:19.800 --> 00:30:21.933
อันนั้นก็คือกระบวนการในการเซฟครับผม

00:30:22.000 --> 00:30:24.733
เอ่อ เซฟก็แบบนี้ครับ มี question ปุ๊บ

00:30:24.800 --> 00:30:27.233
fetch answer fetch answer เสร็จปุ๊บครับ เชิญครับผม

00:30:28.000 --> 00:30:33.433
Q: แล้วเราจะ define semantic rules ที่ไหนครับ

00:30:33.500 --> 00:30:35.133
คือเวลาเราหา semantic meaning เนี่ย

00:30:36.200 --> 00:30:38.033
มันก็แบบสามารถ define rules ได้ว่า

00:30:38.100 --> 00:30:43.333
ถ้าเกิดว่า query หรือ query ประมาณนี้ให้ตอบอย่างงี้

00:30:43.400 --> 00:30:44.433
เราจะ config ที่ไหน

00:30:45.200 --> 00:30:47.333
James: อ๋อ หมายถึง config ให้ MongoDB มัน

00:30:47.400 --> 00:30:48.833
มัน search ให้เราอย่างงี้ใช่ไหมครับ

00:30:48.900 --> 00:30:49.933
คำถามคือแบบนั้นใช่ไหม

00:30:50.300 --> 00:30:52.833
โอเคครับ

00:30:53.200 --> 00:30:56.833
Q: ให้มันว่าอย่างเช่นถ้าถามแบบนี้เราจะไม่ cache นะ

00:30:57.200 --> 00:30:58.433
มันต้องกดให้มันลืมขึ้น

00:30:59.600 --> 00:31:05.233
James: อ๋อ หมายถึงว่าจะ cache ไหมใช่ไหมฮะ ใช่ครับ

00:31:05.300 --> 00:31:09.733
จริงๆ อันเนี้ยครับ มันเป็น เป็น logic ที่

00:31:10.600 --> 00:31:12.933
เรา เรา เราทำเพิ่มเองขึ้นมาครับ

00:31:13.000 --> 00:31:14.733
คืออันนี้จะไม่ได้เกี่ยวกับ MongoDB และ MongoDB

00:31:14.800 --> 00:31:17.033
มีหน้าที่อย่างเดียวก็คือทำ index

00:31:17.700 --> 00:31:21.233
แล้วก็ search ผ่านตัว function บางอย่างใช่ไหมครับ

00:31:21.300 --> 00:31:23.233
อันเนี้ยครับ มันจะต้องเป็นฝั่ง application layer

00:31:23.500 --> 00:31:26.033
ของเราและว่าเราจะ cache มันไหมใช่ไหมครับ

00:31:26.700 --> 00:31:31.233
ถ้าที่ผมเคยทำครับ โดยปกติเราจะพยายาม cache

00:31:31.900 --> 00:31:35.333
จากก็คือมันก็จะกลับไปที่ตัว Azure อ่า

00:31:35.400 --> 00:31:36.233
ตัว OpenAI เลยครับ

00:31:36.300 --> 00:31:38.133
เรามี pre-define function ถูกไหมครับ

00:31:38.200 --> 00:31:40.333
เราก็พยายามให้มัน get ดูครับว่า

00:31:40.400 --> 00:31:41.433
เราก็พยายาม define เข้าไปครับว่า

00:31:41.700 --> 00:31:43.333
เออ ถ้ามันเป็นข้อมูลประมาณเนี้ย

00:31:43.400 --> 00:31:45.733
หรือมันถามประมาณเนี้ย หรือมันออกมาเป็นประมาณเนี้ย

00:31:45.800 --> 00:31:47.433
เฮ้ย เรียก function นี้นะ

00:31:47.500 --> 00:31:49.233
แล้ว function นั้นก็จะเป็น function ที่กำหนดครับ

00:31:49.300 --> 00:31:50.233
ว่ามันจะ cache หรือไม่

00:31:50.700 --> 00:31:53.533
ให้ตรงเนี้ยครับ เป็นตัว define meaning ของมัน ครับ

00:31:55.400 --> 00:31:59.333
โอเค ไม่แน่ใจว่าเหลืออีกประมาณ หมดเวลาแล้ว

00:31:59.400 --> 00:32:01.133
โอเค ครับ จริงๆ หมดแล้วครับ

00:32:02.000 --> 00:32:04.733
เซฟครับ เร็วๆ แล้วกันฮะ มี question

00:32:05.100 --> 00:32:06.433
fetch answer ออกมาครับ

00:32:06.500 --> 00:32:11.333
แล้วเราก็ embed ตัว embed ตัวของ question เนาะ

00:32:11.400 --> 00:32:16.433
นะครับ แล้วก็เซฟ 3 กับ 2 ลงไปใน database นะฮะ

00:32:17.700 --> 00:32:21.733
ครับ เอิ่ม ทั้งหมดทั้งมวลครับ จริงๆ มี article อยู่ครับ

00:32:21.800 --> 00:32:24.733
ผมพึ่ง publish กับ MongoDB Developer Center นะครับ

00:32:24.800 --> 00:32:26.833
เผื่อว่าอยากลองไปลองทำกันดูนะครับ

00:32:26.900 --> 00:32:28.233
ก็สแกนตรงนี้ได้ครับ

00:32:28.300 --> 00:32:30.233
เดี๋ยวๆ แชร์อันนี้ให้ในกลุ่มด้วยครับ

00:32:30.900 --> 00:32:32.933
เอ่อ สไลด์ทุกอย่างก็แชร์ได้นะครับ ลองเอาไปเล่นดูเนาะ

00:32:33.000 --> 00:32:37.933
นะครับ โอเค อันนี้อันนึงครับ อะ ขอโปรโมทนิดนึงครับ

00:32:38.000 --> 00:32:41.133
Javascript Bangkok จะจัดวันที่ 18-19 ตุลาคมนะครับ

00:32:41.700 --> 00:32:42.633
เดือนหน้านะครับ

00:32:42.700 --> 00:32:45.933
ก็เรามี keynote หลักๆ ก็คือเป็นคนที่สร้าง

00:32:46.000 --> 00:32:47.033
Elysia framework เนาะ

00:32:47.100 --> 00:32:48.933
เป็นคนไทยคนนึงชื่อคุณออมนะครับ

00:32:49.000 --> 00:32:52.033
อีกคนนึงก็คือเป็นตัว Svelte core contributor นะครับ

00:32:52.100 --> 00:32:55.633
บินตรงมาจากไหนนะริฟฟี่ สิงคโปร์นะครับ

00:32:55.700 --> 00:32:57.433
ถ้าบินตรงมาจากพะเยาก็ไม่ได้นะครับ

00:32:57.500 --> 00:32:59.133
บินตรงมาจากสิงคโปร์นะครับ

00:32:59.200 --> 00:33:01.433
อ่า ก็มาลองดูกันได้นะครับ

00:33:01.500 --> 00:33:03.233
แล้วก็มี session อื่นๆ อีกมากมายนะครับ

00:33:03.300 --> 00:33:05.033
มี code ลด 10% ให้ตรงนี้ครับ

00:33:05.100 --> 00:33:08.433
แล้วก็เราวันนี้เรามี code JetBrains 2 ตัวมาใช่ไหมครับ

00:33:09.200 --> 00:33:11.133
อ่า แจกเลยไหม แจกเลยครับ

00:33:11.200 --> 00:33:14.233
ใครรู้บ้างครับว่า function ในการหา similarity

00:33:14.300 --> 00:33:17.733
ของ MongoDB นี่แหละ ดีกว่า

00:33:17.800 --> 00:33:20.333
เพราะว่า คนไม่ได้ลงอะ คือคนต้องเช็กอิน

00:33:20.400 --> 00:33:22.533
เออ ได้ๆ ใครยังไม่ได้เช็กอินก็เช็กได้

00:33:22.600 --> 00:33:24.933
อะ เอาสักอันนึงแจกไปก่อนก็ได้ฮะ

00:33:25.000 --> 00:33:26.133
เพราะว่าผมอยากถามคำถามเดียวกัน

00:33:26.200 --> 00:33:30.733
ผมว่า ผมเคยตกสัมภาษณ์เพราะคำถามนี้นะครับ

00:33:30.800 --> 00:33:32.833
ใครจำได้บ้างครับว่า function ในการ search similarity

00:33:32.900 --> 00:33:37.933
ของ MongoDB มีอะไรบ้างครับ ใน vector search ครับ

00:33:38.000 --> 00:33:43.533
ใครจำได้บ้างครับ อ่า ยกมือครับ อะ อะ ยกมือครับ

00:33:43.600 --> 00:33:45.233
เชิญครับ

00:33:45.300 --> 00:33:47.433
Euclidean

00:33:47.500 --> 00:33:49.633
Cosine similarity

00:33:49.700 --> 00:33:51.033
Dot product

00:33:51.100 --> 00:33:52.133
อ๋อ ถูกต้องครับ ถูกต้องครับ

00:33:52.200 --> 00:33:54.433
นี่สัมภาษณ์ผ่านนะฮะ อันนี้ ไม่ตกแบบผมนะ

00:33:55.100 --> 00:33:56.333
นะครับ เชิญครับ เชิญครับ

00:34:06.000 --> 00:34:09.132
นะครับ โอเคครับ ก็ เอ่อ ประมาณนี้ครับ

00:34:09.199 --> 00:34:11.132
มีคำถามอะไรก็เดี๋ยวมาคุยกันนะครับ

00:34:11.199 --> 00:34:13.033
แล้วก็เดี๋ยว เบรกก่อน เอ่อ

00:34:13.100 --> 00:34:14.233
เดี๋ยวเบรกก่อนสักแป๊บนึงแล้วกันนะครับ

00:34:14.300 --> 00:34:15.632
โอเคครับ ขอบคุณทุกคนมากครับผม
