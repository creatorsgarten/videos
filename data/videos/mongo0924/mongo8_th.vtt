WEBVTT

00:00:00.100 --> 00:00:01.933
เซสชั่นนี้ครับ เราได้

00:00:02.600 --> 00:00:07.032
คนที่เป็น น่าจะใกล้ชิดกับโปรดักต์

00:00:07.100 --> 00:00:09.233
ของ MongoDB ที่สุดแล้วนะครับ

00:00:09.300 --> 00:00:11.633
แล้วก็เป็นพนักงาน MongoDB
คนเดียวในทีมด้วยนะครับ

00:00:11.700 --> 00:00:12.833
ที่เหลือไม่ได้เป็น

00:00:12.900 --> 00:00:18.933
แล้วก็เดี๋ยวเขาจะมาพูดนะครับ
ในหัวข้อ What is new in MongoDB

00:00:19.000 --> 00:00:20.133
8.0 นะครับ

00:00:20.200 --> 00:00:23.533
ก็เดี๋ยวมาดูกันครับว่าของใหม่ๆ
ที่กำลังจะออกมาหรือว่าออกมาแล้วเนี่ย

00:00:23.600 --> 00:00:28.133
เป็นยังไงนะครับ คนนี้ import ตรงนะครับ
จาก MongoDB สาขาพะเยา

00:00:28.200 --> 00:00:30.533
ไม่ใช่นะครับ MongoDB สิงคโปร์

00:00:30.600 --> 00:00:36.633
ขอเสียงปรบมือให้กับพี่ปิตินะครับ
Senior Consulting Engineer จาก MongoDB ครับผม

00:00:37.400 --> 00:00:41.633
เดี๋ยวเราเข้าเปลี่ยนสายแป๊บนึงนะครับ

00:00:44.100 --> 00:00:48.733
เดี๋ยวลองดูนะครับว่าจะเป็นยังไงนะครับ

00:00:48.800 --> 00:00:52.833
7.0 นะฮะ โอเค 8.0 นะฮะ

00:00:52.900 --> 00:00:57.133
ทุกคนน่าจะเคยใช้ MongoDB กันอยู่บ้างใช่ไหมครับ

00:00:57.200 --> 00:01:01.033
ใครยังใช้ MongoDB รุ่นต่ำกว่า 3 บ้างฮะ

00:01:01.800 --> 00:01:06.933
คือมันมีนะ ผมเคยเจอ
ใครใช้รุ่น 4-5

00:01:07.600 --> 00:01:09.033
โอเค 6 ขึ้นไป

00:01:10.000 --> 00:01:12.532
โอเค โอเคครับ
ส่วนที่ไม่ยกก็คือรอใช้รุ่น 9

00:01:12.600 --> 00:01:16.633
ซึ่งจะออกในอีก 2 ปีข้างหน้าใช่ไหมครับ
โอเคนะครับ เดี๋ยวรอดูนะครับ

00:01:16.700 --> 00:01:19.532
ครับ มาแล้วครับ
ถ้าพี่พร้อมก็เชิญเลยครับ

00:01:24.700 --> 00:01:32.633
โอเคนะครับ สวัสดีครับทุกคน
ผมตื่นเต้นนิดหน่อยนะครับ

00:01:32.700 --> 00:01:37.733
ในวันนี้นะครับ
เราจะมาพูดถึงตัวที่เป็น MongoDB Version 8

00:01:37.800 --> 00:01:43.833
ซึ่งภายในปีนี้จะออกเป็น GA
ก็คือ General Available

00:01:43.900 --> 00:01:45.333
นะครับ

00:01:47.700 --> 00:01:48.333
โอเค

00:01:48.400 --> 00:01:58.933
อันนี้เป็นสไลด์ที่เรามีการพูดในงาน mongodb.local
ซึ่งผมอาจจะ skip บางอันไปนะครับ เพราะว่ามันอาจจะ

00:01:59.000 --> 00:02:04.833
ไม่ได้มีเนื้อหาอะไรที่ดึงดูดความสนใจ
ให้เราสนใจได้มากนะครับ

00:02:04.900 --> 00:02:08.132
จะเป็นกล่าวประวัติเนาะ
แล้วก็ปัจจุบันตอนนี้

00:02:08.199 --> 00:02:11.833
มันจะเป็น release candidates เวอร์ชัน 8 นะครับ

00:02:13.600 --> 00:02:20.733
โอเค อันนี้เราจะเห็นว่า evaluation ก็คือในแต่ละปี
มันก็จะค่อยๆ เริ่มต้นมีเวอร์ชันมากขึ้นไป

00:02:20.800 --> 00:02:26.733
จนถึง ณ ปัจจุบันเนี่ย
จะออกเวอร์ชันทั้งหมดเนี่ย ประมาณ 1 ปี 1 เวอร์ชัน

00:02:26.800 --> 00:02:31.333
นะครับ MongoDB จะออก 1 ปี 1 เวอร์ชัน
ซึ่งผมถือว่าค่อนข้างเร็ว

00:02:32.700 --> 00:02:38.233
นะครับ อันนี้คือเป็นนโยบายพื้นฐาน
ซึ่งผมก็ยังไม่แน่ใจนะครับว่าเขาจะ

00:02:38.300 --> 00:02:43.233
มีการแบบ 2 ปี 1 ครั้งรึเปล่านะครับ
แต่ตอนนี้เขาจะผลักดันให้มันเป็น

00:02:43.300 --> 00:02:47.233
นะครับ 1 ปี 1 เวอร์ชันนะครับ ตรงนี้นะครับ

00:02:47.300 --> 00:02:51.433
อันนี้จะเป็นตัวเวอร์ชันนะครับ
โอเค ต่อไปนะครับ

00:02:51.500 --> 00:02:56.933
ที่จริงแล้วนะครับ สิ่งแรกที่ MongoDB จะมีในเวอร์ชัน 8 เลยนะครับ ก็คือ

00:02:57.000 --> 00:03:00.433
ปกติแล้วผมเข้าใจว่าทุกท่านเนี่ยใช้ Community Edition อยู่แล้ว

00:03:01.100 --> 00:03:01.833
ผมเชื่อว่าอย่างนั้นนะครับ

00:03:01.900 --> 00:03:07.033
เพราะว่าเราเป็น product ที่มีทั้ง open source และตัว commercial นะครับ

00:03:07.100 --> 00:03:08.033
เพราะฉะนั้นในตัว

00:03:08.100 --> 00:03:15.433
ตัว open source เนี่ยก็จะมี community
ซึ่ง community ต่างกับ EA นะครับ อยู่แค่จุดเดียว

00:03:15.500 --> 00:03:22.033
คำว่าจุดเดียวก็คือ อยู่แค่ segment เดียว
ก็คือเรื่องของตัว Security Advance

00:03:22.100 --> 00:03:24.132
นะครับ อันนี้ผมพยายามให้ความรู้ไปด้วย

00:03:24.200 --> 00:03:28.933
เพราะฉะนั้นเราจะเห็นได้ว่า product ที่เสียเงินกับไม่เสียเงินต่างกันแค่ตรงนี้จุดเดียว

00:03:29.000 --> 00:03:34.533
ดังนั้นเมื่อเป็น MongoDB เวอร์ชัน 8 ที่กำลังจะเกิดขึ้นนะครับ

00:03:34.600 --> 00:03:38.433
ในประมาณปลายปี อีกไม่กี่เดือนนี้นะครับ เวอร์ชัน 8 ที่จะออกมาเนี่ย

00:03:38.500 --> 00:03:42.733
เขาบอกว่า Community Edition เนี่ยครับ
จะมีฟีเจอร์ใหม่ขึ้นมาทันทีนะครับ

00:03:42.800 --> 00:03:45.433
ฟีเจอร์หนึ่งชื่อว่า Search กับ Vector Search

00:03:45.500 --> 00:03:50.033
ก็คือปกติแล้วนะครับ MongoDB เนี่ย
เป็นเวอร์ชัน Community ใช่ไหมครับ

00:03:50.100 --> 00:03:53.733
แล้วก็เป็นเวอร์ชันเสียตังค์และเวอร์ชัน Cloud

00:03:53.800 --> 00:03:58.132
นะครับ มีทั้งหมด 3 เวอร์ชันนะครับ
เพราะฉะนั้นในตัวที่เป็น

00:03:58.200 --> 00:04:02.833
เวอร์ชัน Cloud เนี่ย ปกติแล้วเราจะเรียกว่าเป็น MongoDB Atlas นะครับ

00:04:02.900 --> 00:04:05.132
ซึ่งใน MongoDB Atlas เนี่ย ก็คือเป็น

00:04:05.200 --> 00:04:09.033
self-managed นะครับ
ก็คือคุณสามารถที่จะเซ็ต config ต่างๆ

00:04:09.100 --> 00:04:10.933
ได้ deploy Mongo ได้นะครับ

00:04:11.000 --> 00:04:15.533
ก็จะมีฟีเจอร์หนึ่งที่เราเรียกว่าเป็น Atlas Search นะครับ

00:04:15.600 --> 00:04:21.433
ในตัว Atlas Search หมายความว่าอะไร
หมายความว่าเราสามารถจะทำพวก full-text search ได้

00:04:21.500 --> 00:04:24.933
search แบบ string
แทนที่เราจะ search แบบ regular expression

00:04:25.000 --> 00:04:26.733
เราอาจจะไม่จำเป็นต้องทำแบบนั้น

00:04:26.800 --> 00:04:30.533
มันจะเป็นแบบ full-stream search นะครับ
ซึ่งเบื้องหลังของตัว search เนี่ย

00:04:30.600 --> 00:04:33.733
โดยปกติแล้วก็คือใช้ตัว Apache Lucene

00:04:33.800 --> 00:04:39.033
ที่เป็นที่นิยมอยู่แล้วนะครับ
เพราะฉะนั้น engine เดียวกับตัว Elastic Search

00:04:39.100 --> 00:04:42.033
หรือ OpenSearch นะครับ
engine เดียวกันนะครับ

00:04:42.100 --> 00:04:44.133
เพราะฉะนั้นตอนนี้เขาก็จะโยกครับ

00:04:44.200 --> 00:04:47.733
ตัว Atlas Search นะครับ มา deploy อยู่บน on-prem

00:04:47.800 --> 00:04:51.133
โดยที่เปิดให้ community edition ใช้ก่อน

00:04:51.200 --> 00:04:54.133
เวอร์ชันเสียตังค์ตามมาทีหลัง

00:04:54.200 --> 00:04:55.533
นี่คือคอนเซ็ปต์แรกนะครับ

00:04:55.600 --> 00:05:00.433
เพราะว่าเขาให้เห็นว่านักพัฒนาทุกคนเนี่ย ให้ความสนใจต่อการใช้ Community มากอยู่แล้ว

00:05:00.500 --> 00:05:00.832
ดังนั้น

00:05:00.900 --> 00:05:04.433
เราอยากให้นักพัฒนาได้ลองใช้ feature

00:05:04.500 --> 00:05:08.633
ที่ง่ายขึ้นนะครับ
โดยการโยกตัว Atlas Search นะครับ

00:05:08.700 --> 00:05:14.433
มา deploy ลงบน Community Edition นั่นเอง
ซึ่งจะมาอยู่ในเวอร์ชันที่เป็นเวอร์ชัน 8

00:05:14.500 --> 00:05:18.733
แต่ยังคงเป็นลักษณะที่เหมือนเป็น beta

00:05:18.800 --> 00:05:23.433
ก็คือมันจะมีการ develop ไปเรื่อยๆ
แต่เราจะเริ่มใช้ได้ทันที

00:05:23.500 --> 00:05:31.033
อันนี้ก็คือเป็นสิ่งที่เขา announce นะครับ
เป็น feature ซึ่งถ้าถามตัวผมก็คือผมอ่ะ

00:05:31.100 --> 00:05:34.133
ยังไม่ได้มีโอกาสเล่นจริงๆ จังๆ
เพราะ product เขาค่อนข้างเยอะเนาะ

00:05:34.200 --> 00:05:36.533
เพราะฉะนั้นในความจริงแล้วผมเล่นแทบ

00:05:36.600 --> 00:05:37.633
ไม่ได้เล่นครบทุกตัว

00:05:37.700 --> 00:05:41.233
แต่ก็แบบประมาณ 90 กว่าเปอร์เซ็นต์ที่ผมได้เล่นเพราะว่าลูกค้า

00:05:41.300 --> 00:05:45.733
จะมีการใช้งานที่หลากหลาย
ดังนั้นเราจำเป็นที่จะต้องเรียนรู้ทุก product ก่อนออก

00:05:46.400 --> 00:05:48.233
เลยทุกตัวนะครับ

00:05:49.000 --> 00:05:53.533
อันนี้เป็นตัวแรกนะครับที่จะเข้ามาในเวอร์ชั่น 8 นั่นเองนะครับ

00:05:53.600 --> 00:05:56.133
เรื่องการใส่ search เข้าไป เพราะฉะนั้น search มี 2 ตัว

00:05:56.200 --> 00:06:01.433
ถ้าเห็นทางรูปก็คือ 1 ก็คือเป็นตัวที่เป็น search ปกติ
เราเรียก full text search นะครับ

00:06:01.500 --> 00:06:04.533
ตัวที่ 2 เรียกว่า vector search เพราะว่าตามสมัยนิยมแน่นอน

00:06:04.600 --> 00:06:09.332
ตอนนี้ทุกคนทำ generative AI ดังนั้นทุกคนต้องการให้ระบบ search เนี่ย

00:06:09.400 --> 00:06:13.033
search ได้เร็วขึ้นนะครับ ซึ่งตรง vector search คืออะไรเนี่ยนะครับ

00:06:13.100 --> 00:06:16.733
เดี๋ยวเราไปคุยใน section ของน้องเจมส์นั่นเองนะครับ

00:06:19.100 --> 00:06:25.633
ต่อไปนะครับ เราก็จะมีส่วนที่เป็นเวอร์ชันที่ release จริงจังแล้วก็คือ

00:06:26.600 --> 00:06:30.832
เวลาที่เราต้องการที่อยากจะย้าย database ที่เป็น relational database

00:06:30.900 --> 00:06:37.832
ขึ้นมาบน NoSQL หรือ MongoDB นะครับ
MongoDB จะมีเครื่องมือที่เราเรียกว่า migration

00:06:37.900 --> 00:06:41.332
เราเรียกว่า migration มี 2 ตัวหลักๆ ที่

00:06:41.400 --> 00:06:47.733
ถือว่าเป็นตัวที่ active อยู่ตลอดเวลา
ชื่อว่า mongosync กับ relational migrator

00:06:47.800 --> 00:06:53.633
mongosync ก็คือเป็นเครื่องมือสำหรับย้าย

00:06:53.700 --> 00:06:57.433
database ที่เป็น relational database ก็คือ

00:06:57.500 --> 00:07:01.933
ก็คือตัว mongosync เนี่ยจะย้ายจากตัวที่เป็นตระกูล NoSQL ด้วยกัน

00:07:02.000 --> 00:07:03.733
อย่างเช่น Mongo Community

00:07:03.800 --> 00:07:07.733
หรือ database ที่เป็น NoSQL ที่เป็น JSON ตัวอื่นนะครับ
ย้ายขึ้นมาบน

00:07:07.800 --> 00:07:11.533
MongoDB หรือบน Atlas เราจะเรียกว่าเป็น mongosync นะครับ

00:07:11.600 --> 00:07:14.733
ซึ่ง mongosync เนี่ยปกติแล้วเนี่ย เวลาเราย้าย migration เนี่ย

00:07:14.800 --> 00:07:20.033
หลายๆองค์กรจะมองภาพว่า เอ๊ะ ถ้าเราย้ายจาก A ไป B แล้วเกิดล่ม

00:07:20.100 --> 00:07:23.033
เราสามารถย้ายย้อนกลับจาก B มา A ได้ไหม

00:07:23.100 --> 00:07:27.033
ตัว mongosync สามารถทำที่เรียกว่าเป็น bi-direction

00:07:27.100 --> 00:07:28.533
ก็คือ

00:07:28.600 --> 00:07:34.332
เพราะว่าทุกธุรกิจจะต้องมีคำถามว่า เอ๊ะ ถ้าผมลองย้ายไปแล้วแล้วเกิดพัง ผม rollback ได้ไหม

00:07:34.400 --> 00:07:38.832
โอเคไหมครับ ทุกคนต้องมีคำถามนี้
เพราะไม่มีใครจะย้ายไปแล้วแบบ เออ พังก็ช่างมัน

00:07:38.900 --> 00:07:42.533
ก็ไปทำกันบนนั้นน่ะ คงไม่มีทางถูกไหมครับองค์กรทุกองค์กร ดังนั้น

00:07:42.600 --> 00:07:47.633
แปลว่าเราย้ายจาก A ไป B ปุ๊บ เราสามารถย้อนกลับได้
อันนี้คือตัว mongosync นะครับ

00:07:47.700 --> 00:07:50.533
ตัว mongosync เนี่ยมีหน้าที่แค่ย้าย data ครับ

00:07:50.600 --> 00:07:54.633
แต่ถ้าเราบอกว่าต้องการที่อยากจะย้ายจาก relational แล้วต้องการแบบ

00:07:54.700 --> 00:07:58.933
จะเข้าใจว่า เอ๊ะ ถ้าเราจะย้าย relational ที่เป็นโครงสร้าง table ล่ะ

00:07:59.000 --> 00:08:02.533
มีความสัมพันธ์ one-to-many, many-to-many, one-to-one เนี่ย

00:08:02.600 --> 00:08:05.533
เราจะย้ายไป Mongo ยังไง เพราะความรู้ของเราอาจจะ

00:08:05.600 --> 00:08:10.933
อาจจะยังแบบไม่ได้เต็มที่ที่จะเข้าใจว่าการทำ modeling ของ MongoDB ทำยังไง

00:08:11.000 --> 00:08:16.433
relational migrator ก็คือตัวตอบโจทย์ เพราะว่าอะไรครับ
เพราะว่ามันคือเครื่องมือที่

00:08:16.500 --> 00:08:21.433
เป็นหน้าเหมือน diagram ให้มองภาพเหมือนเราทำตัว ER diagram

00:08:21.500 --> 00:08:23.533
เพราะฉะนั้นตัว relational migrator

00:08:23.600 --> 00:08:27.533
จะเป็นตัวที่ทำการ map relational database ให้เห็นเป็น ER diagram

00:08:27.600 --> 00:08:32.232
แล้วก็สามารถ map เป็นโครงสร้างของ relational ที่เป็น MongoDB

00:08:32.299 --> 00:08:34.133
เป็น NoSQL diagram

00:08:34.200 --> 00:08:37.433
นี่คือสิ่งที่มันสามารถ mapping อัตโนมัติ

00:08:37.500 --> 00:08:41.832
by default หลังจากนั้นคุณก็สามารถที่จะปรับแต่งได้ตามต้องการ

00:08:41.900 --> 00:08:43.533
แต่สำคัญกว่านั้นก็คือ

00:08:43.600 --> 00:08:45.233
เช่น เราต้องการจะย้าย database

00:08:45.300 --> 00:08:48.933
จาก MySQL จาก Oracle จาก SQL Server ไปบน

00:08:49.000 --> 00:08:50.933
MongoDB เราใช้เครื่องมือนี้

00:08:51.000 --> 00:08:54.933
ข้อดีคือพอคุณสร้าง diagram เสร็จ mapping เรียบร้อยแล้ว

00:08:55.000 --> 00:08:55.933
คุณสามารถ run

00:08:56.000 --> 00:08:57.733
ย้าย data ได้ทันที

00:08:57.800 --> 00:09:02.733
การย้าย data ปกติเรามักจะมี 2 ส่วน
ก็คือย้ายครั้งเดียวจบใช่ไหมครับ

00:09:02.800 --> 00:09:08.633
แต่ส่วนใหญ่ผมเข้าใจว่าระบบทุกคนมีขนาดใหญ่
ดังนั้นเราไม่สามารถจะย้ายครั้งเดียวจบได้

00:09:08.700 --> 00:09:10.933
เราต้องย้ายที่เรียกว่า continuous

00:09:11.000 --> 00:09:15.333
ดังนั้นตัว relational migrator ทำการย้ายข้อมูล continuous ไว้

00:09:15.400 --> 00:09:19.433
แล้วสามารถบอกว่า เออ วันนี้ traffic เยอะ หยุด เราสั่ง stop

00:09:19.500 --> 00:09:23.933
วันนี้ traffic น้อย อ่า run หมายความว่าอะไร
หมายความว่าสมมุติว่าผมมี

00:09:24.000 --> 00:09:28.333
MySQL แล้วผมอยากจะย้ายไปบน MongoDB
ผม map เรียบร้อยแล้ว

00:09:28.400 --> 00:09:33.533
ผมบอกว่า วันนี้ตอนตี 1
ผมต้องการย้ายข้อมูลเฉพาะตี 1 ถึงตี 4 เท่านั้น

00:09:33.600 --> 00:09:35.133
ผมสามารถตั้ง schedule

00:09:35.200 --> 00:09:36.333
แล้วก็ย้าย

00:09:36.400 --> 00:09:40.233
พอย้ายถึงตี 4 ปั๊บ run command API บอกว่า stop

00:09:40.300 --> 00:09:45.833
วันถัดไป ย้ายตีหนึ่งถึงตีสี่ ซ้ำ ทำอย่างนี้ไปเรื่อยๆ ได้
เราเรียกว่า

00:09:45.900 --> 00:09:47.733
ตัว continuous sync นะครับ

00:09:47.800 --> 00:09:51.133
ซึ่ง relational migrator ถูกออกแบบมาให้เราย้าย

00:09:51.200 --> 00:09:55.333
เหตุผลง่ายๆครับ เราต้องการย้ายลูกค้า relational database

00:09:55.400 --> 00:10:00.933
ไปอยู่บน Mongo ให้ได้ ดังนั้นเขาจึงสร้างเครื่องมือนี้เป็นเครื่องมือฟรี

00:10:01.000 --> 00:10:06.733
ที่เหมาะกับการย้าย ปัญหาหนึ่งของการย้าย data

00:10:06.800 --> 00:10:09.333
relational database ไม่ใช่มีแค่ data อย่างเดียวจริงไหมครับ

00:10:09.400 --> 00:10:12.833
เขาจะมีตัวข้างในเรียกว่า stored procedure

00:10:13.400 --> 00:10:19.033
หรือ query ที่ซับซ้อน
ดังนั้น relational migrator ทำการ

00:10:19.100 --> 00:10:22.933
เรียกว่า mapping ก็คือเขาใส่ tool AI เข้าไปทำการ

00:10:23.000 --> 00:10:28.333
mapping command ใน function
หรือ stored procedure ที่เป็น relational SQL

00:10:28.400 --> 00:10:31.733
ให้แปลงเป็น Mongo Query Language

00:10:31.800 --> 00:10:36.133
อันนี้คือความสามารถของเขา
ดังนั้นหมายความว่ามันแปลงก็ไม่ใช่ 100%

00:10:36.200 --> 00:10:37.433
เพราะว่าหมายความว่า

00:10:37.500 --> 00:10:41.633
พอมันแปลงปุ๊บ แน่นอนคุณต้องเป็นคน adjustment ว่าถูกต้องหรือเปล่า

00:10:41.700 --> 00:10:46.833
แต่มากกว่า 80% มันจะแปลงได้อย่างถูกต้อง ทำให้เราลดเวลา

00:10:46.900 --> 00:10:51.733
ในการแปลงคำสั่งที่ฝังอยู่ใน stored procedure นั่นเองนะครับ

00:10:51.800 --> 00:10:55.233
อันนี้เราเรียกว่าเป็นตัว relational migrator นะครับ

00:10:56.600 --> 00:11:03.333
ต่อไปนะครับ ถ้าเรามาพูดถึงในมุมของ modernization
modernization ก็คือว่าลูกค้า

00:11:03.400 --> 00:11:07.533
ใช้ MongoDB เวอร์ชันเก่า หรือใช้ relational database อยู่

00:11:07.600 --> 00:11:11.533
แล้วแอปพลิเคชันเป็นเวอร์ชันเก่า
เขาจะมักจะมีปัญหาหนึ่งซึ่งบอกว่า

00:11:11.600 --> 00:11:14.933
แล้วถ้าเราย้ายแอปพลิเคชันไป
เราต้องแก้แอปเยอะมาก

00:11:15.000 --> 00:11:16.933
แก้แอปเยอะมาก
เราจะย้ายทำไม

00:11:17.000 --> 00:11:21.633
ในเมื่อเราย้ายจาก relational ไปอยู่ relational ไม่ง่ายกว่าเหรอ

00:11:21.700 --> 00:11:26.833
ดังนั้นในทีมของ MongoDB ก็เลยเกิดทีม

00:11:26.900 --> 00:11:31.033
ที่เรียกว่า Modernization Factory

00:11:31.100 --> 00:11:36.833
เป็นทีมที่จะช่วยอำนวยความสะดวก
โดยใช้ระบบ AI ในการ convert source code ทั้งหมด

00:11:36.900 --> 00:11:38.733
ซึ่งเขาพัฒนาเองอยู่แล้วภายใน

00:11:38.800 --> 00:11:41.333
ทำการแปลง source code จากการ mapping

00:11:41.400 --> 00:11:43.533
เช่น คุณเขียน Java แล้วคุณ call

00:11:43.600 --> 00:11:46.233
ด้วย JDBC ที่เป็น SQL query

00:11:46.300 --> 00:11:49.833
คุณแปลง code เนี่ย ให้กลายเป็น MongoDB code ได้เลย

00:11:49.900 --> 00:11:55.233
เป็น Java connect MongoDB
พร้อมกับเขียน Aggregation Framework ได้เลย

00:11:55.300 --> 00:12:02.333
อันนี้ก็คือฟีเจอร์ที่เราพูดถึงว่าเป็นการทำ AI-enabled application modernization tools

00:12:02.400 --> 00:12:07.233
นะครับ ซึ่งตัวนี้ก็จะเป็นทีมที่ช่วยในการย้าย
แปลว่าอะไรครับ แปลว่า

00:12:07.300 --> 00:12:10.933
คุณอยากจะย้ายใช้ MongoDB sync relational
ทำด้วยตัวเองได้นะครับ ไม่มีปัญหา

00:12:11.000 --> 00:12:15.933
แต่ถ้าคุณไม่มีทีมในการแก้ source code นะครับ
ทาง MongoDB มีทีมและ tool

00:12:16.000 --> 00:12:18.733
ในการ convert ซึ่งเขาไม่ได้เอา tool ออกมา public เนาะ

00:12:18.800 --> 00:12:20.833
เป็น tool สำหรับใช้ internal แต่เขารู้ว่า

00:12:20.900 --> 00:12:23.633
เขาพัฒนามาเพื่อให้ระบบ AI generate code

00:12:23.700 --> 00:12:26.333
เพราะเราอยู่ในยุคที่ code มัน generate เองได้ ถูกไหมครับ

00:12:26.400 --> 00:12:27.733
แค่พิมพ์ไปใน prompt เนาะ

00:12:27.800 --> 00:12:31.633
เพราะฉะนั้นเขาก็สร้าง prompt ด้วยตัวเองขึ้นมานะครับ เพื่อให้ manage

00:12:31.700 --> 00:12:38.633
ตรงนี้นะครับ อันนี้คือหนึ่งในความสามารถนะครับ
ที่มีในตัว MongoDB 8 ที่จะมีเข้ามานะครับ

00:12:41.800 --> 00:12:48.433
ในระหว่างทาง มีคำถามอะไรก็คือถามได้หมดนะครับผม
เท่าที่ผมสามารถที่จะตอบได้

00:12:48.500 --> 00:12:54.333
ต่อไป ฟีเจอร์หลักๆ แบ่งออกเป็น 4 ส่วน

00:12:54.400 --> 00:12:59.133
หนึ่งก็คือ MongoDB 8 เนี่ยจะปรับ optimization
คือ performance จะดีขึ้น แต่เราเห็นภาพนะ

00:12:59.200 --> 00:13:03.633
มันจะมีภาพ ฉะนั้นผมเชื่อว่า MongoDB 8 เนี่ย
เราเรียกว่าเป็น

00:13:03.700 --> 00:13:09.933
เมเจอร์เชนจ์มากๆ แล้วมีการวัดผลอย่าง 100%
ตามมาตรฐานของสาย database

00:13:10.000 --> 00:13:14.833
พวก database เนี่ยจะมีเว็บไซต์สำหรับวัดมาตรฐาน
เขาไม่ได้ใช้แบบ load test ทั่วๆ ไป

00:13:14.900 --> 00:13:16.133
เขาจะมีเว็บไซต์สำหรับ

00:13:16.200 --> 00:13:20.833
วัดว่า database ยี่ห้อแต่ละยี่ห้อเนี่ย
ถ้าคุณต้องใช้ data set แบบนี้แบบนั้นนะ

00:13:20.900 --> 00:13:22.733
คุณถึงจะวัด แล้วทุกคนก็จะไปวัด

00:13:22.800 --> 00:13:27.733
ด้วยกันที่ standard ตัวนั้น
เพื่อที่จะวัดว่า โอเค ของฉันใช้ speed แบบ

00:13:27.800 --> 00:13:33.733
ได้เร็วเท่าไหร่นะครับ เดี๋ยวเราจะมีภาพให้ดูนะครับ
ซึ่งตัวนี้จะเป็นเว็บไซต์ปกติที่เราเห็นนะครับ

00:13:33.800 --> 00:13:38.733
อันนี้เรื่องตัว optimization นะครับ
สองก็คือเรื่องของการ workload นะครับ

00:13:38.800 --> 00:13:40.533
workload management นะครับ

00:13:40.600 --> 00:13:44.633
ก็คือจะทำการ manage ทำให้การโหลดข้อมูลเนี่ยเร็วขึ้นนะครับ

00:13:44.700 --> 00:13:47.533
มันก็จะมีเรื่อง optimize เรื่อง workload

00:13:47.600 --> 00:13:51.833
เรื่อง flexible scaling นะครับ แล้วก็ improve ตัว security นะครับ

00:13:51.900 --> 00:13:54.533
เดี๋ยวเรามาดูกันนะครับ ทั้ง 4 key นะครับ

00:13:54.600 --> 00:13:57.433
เริ่มแรกนะครับ ตัว optimization นะครับ

00:13:58.000 --> 00:14:00.933
Optimization เนี่ยนะครับ

00:14:01.000 --> 00:14:02.833
ถ้าใครใช้ MongoDB อยู่แล้ว

00:14:02.900 --> 00:14:04.933
จะค้นพบว่าการทำ application

00:14:05.000 --> 00:14:08.533
framework เนี่ยเป็นเรื่องที่งง

00:14:08.600 --> 00:14:14.533
เพราะทุกคนคุ้นเคยต่อการใช้คำสั่ง SQL ในการ select, join, group by

00:14:14.600 --> 00:14:20.733
Nested join นะครับ ทำอะไรก็ตามนะครับ ด้วย join
เพราะฉะนั้น เวลาการทำตัว aggregation framework

00:14:20.800 --> 00:14:24.933
เป็นเรื่องที่ยาก แต่ว่าเราไม่ต้องกังวลครับ
เพราะว่าถ้าพวกเราใช้

00:14:25.000 --> 00:14:30.633
Compass นะครับ ซึ่งเป็น MongoDB Compass เนี่ย
พวกเราจะเห็นว่ามันจะมี feature ที่เรียกว่า NLP

00:14:30.700 --> 00:14:31.933
ก็คือ Gen AI
เราสามารถ

00:14:32.000 --> 00:14:36.233
บอกเขาได้เหมือน prompt เลย
ใส่ prompt เข้าไปมันจะ generate query ให้เรา

00:14:36.300 --> 00:14:40.133
อันนี้คือสิ่งที่ผมก็ใช้อยู่ทุกวันนะ เพราะว่า

00:14:40.200 --> 00:14:46.633
บางอย่างมันเป็นท่าที่ซับซ้อน
ดังนั้นผมก็ไม่สามารถที่จะคิดให้เร็วๆ ได้ ผมก็จะถาม

00:14:46.700 --> 00:14:51.633
พอเค้าเอามาปุ๊บ ผมก็จะค่อยๆ แปลงมันให้ถูกต้องต่อผลลัพธ์

00:14:51.700 --> 00:14:53.533
ซึ่งเป็นการพัฒนามันไป

00:14:53.600 --> 00:14:58.333
ซึ่งใน performance ของเวอร์ชัน 8 เนี่ยนะครับ
สิ่งหนึ่งที่เราบอกว่า raise the bar

00:14:58.400 --> 00:15:03.433
Raise the bar คือพยายามทำให้มันขึ้นแบบ top level
ในส่วนหลักๆ เลยของ performance เมื่อเทียบ

00:15:03.500 --> 00:15:07.533
เมื่อเทียบกับเวอร์ชัน 7 นะครับ ก็คือ 1.

00:15:07.600 --> 00:15:12.333
Group กับ project นะครับ ปกติแล้ว MongoDB เนี่ยเราจะมีการ group by ถูกไหมครับ

00:15:12.400 --> 00:15:13.833
SQL ทุกคนเนี่ยก็ต้องมีการ

00:15:13.900 --> 00:15:18.033
group by ผมเชื่อว่าทุกคน group by โปรเจกต์ก็คือการใช้คำสั่ง select

00:15:18.100 --> 00:15:20.833
ปกติทุกคนคงไม่ใช้ select star หรอกจริงไหมครับ

00:15:20.900 --> 00:15:25.533
ถ้าเวลาเราใช้ relational database
เราจะใช้คำว่า select แล้วก็เลือกคอลัมน์

00:15:25.600 --> 00:15:27.733
มันทำให้การดึงง่ายขึ้น แต่ในมุมของ

00:15:27.800 --> 00:15:32.733
ตัวระบบที่เป็น MongoDB เราใช้คำว่า project ก็คือการ select

00:15:32.800 --> 00:15:38.533
เพราะฉะนั้นพวกนี้เค้าจะปรับปรุง performance ให้มีประสิทธิภาพดีขึ้น

00:15:38.600 --> 00:15:44.433
ต่อไปพูดถึงตัว filter แล้วก็ sort
ปกติเรา filter ถ้า SQL ก็คือใช้คำว่า WHERE

00:15:44.500 --> 00:15:48.433
ถ้า MongoDB เราใช้คำว่า $match นะครับ

00:15:48.500 --> 00:15:52.233
เพราะฉะนั้นคำว่าตัว $match เนี่ยก็คือจะช่วยทำการ filter

00:15:52.300 --> 00:15:55.033
ให้มีศักยภาพในการ query ให้เร็วขึ้นนะครับ

00:15:55.100 --> 00:15:58.933
ผมอาจจะไม่ได้ลง detail โดยแบบละเอียดมากนะ
เพราะว่าผมมันมีเอกสาร

00:15:59.000 --> 00:16:02.633
อยู่แล้วที่ผมมาเห็นภาพ แต่ผมรู้ว่าเค้าให้เห็นภาพว่า

00:16:02.700 --> 00:16:06.633
ตัว operator ตัวไหนบ้าง ที่ performance ดีขึ้น

00:16:06.700 --> 00:16:10.133
เป็น operator ที่พวกเราต้องใช้อยู่แล้วในสาย MongoDB

00:16:10.200 --> 00:16:13.733
ก็คือ $match นะครับ
ก็คือ $sort นะครับ

00:16:13.800 --> 00:16:17.633
แล้วก็ตัวสุดท้าย $lookup ซึ่งปกติแล้วผมแนะนำอยู่แล้วว่า

00:16:17.700 --> 00:16:20.933
เราไม่ควรมี lookup
lookup ก็คือการ join

00:16:21.000 --> 00:16:23.733
เราไม่ควรมี lookup เกิน 2 lookup

00:16:23.800 --> 00:16:25.833
มันก็เหมือนเราเขียน relational database

00:16:25.900 --> 00:16:29.233
เราไม่ควร INNER JOIN ๆ ๆ ๆ ถูกไหม

00:16:29.300 --> 00:16:32.233
เพราะว่ามันจะทำให้ประสิทธิภาพ…

00:16:32.300 --> 00:16:36.133
performance ของการโหลดขึ้น memory เนี่ยมันหนักเกินไป

00:16:36.200 --> 00:16:39.333
นี่คือเหตุผลเดียวนะครับ ว่าบอกว่าถ้าเมื่อไหร่ก็ตามคุณใช้ lookup

00:16:39.400 --> 00:16:42.133
ทุกครั้งคุณจะใช้ CPU เยอะ

00:16:42.200 --> 00:16:48.833
ต่อให้คุณมี index แล้วก็ตาม
ดังนั้นเขาจึงบอกว่าควรมีการ join เพียงแค่ไม่เกิน 2 ครั้ง

00:16:48.900 --> 00:16:53.333
ซึ่ง lookup ในท่าของ Excel มันก็คือการทำ left join

00:16:53.400 --> 00:16:58.033
อันนี้เป็นข้อมูลเพิ่มเติมนะ
ถ้าใคร search รอบอยู่แล้ว นี่คือการทำ left join นะครับ

00:16:58.100 --> 00:17:02.533
เพราะ lookup เขาจะปรับปรุงให้มีประสิทธิภาพมากยิ่งขึ้น

00:17:03.200 --> 00:17:07.032
อันนี้คือเป็นส่วนที่เน้น query performance

00:17:08.599 --> 00:17:12.633
โอเค ต่อไปเราเซ็ต standard ใหม่ครับ เชิญครับ

00:17:17.800 --> 00:17:21.933
โอเคครับ เป็นคำถามที่ดีครับ แน่นอนครับ ปกติแล้วก็คือ

00:17:22.000 --> 00:17:27.433
การทำ index มันจะมีทฤษฎีหนึ่งนะครับ
ที่อาจจะดูบนเว็บไซต์ก่อนนะครับ ก็คือเรียกว่า ESR

00:17:27.500 --> 00:17:30.933
Equality นะครับ

00:17:31.000 --> 00:17:33.633
แล้วก็ sorting นะครับ แล้วก็ range นะครับ

00:17:33.700 --> 00:17:36.233
เป็นกฎปกติที่อยู่บนเว็บไซต์นะครับ ซึ่งมันจะมี detail นะครับ

00:17:36.300 --> 00:17:37.933
ผมอาจจะบอกไม่ได้ในตอนนี้มันเยอะ

00:17:38.000 --> 00:17:43.433
เพราะ ESR rule จะเป็นตัวบอกนะครับ
แล้วปกติแล้วเราควรมี index

00:17:43.500 --> 00:17:48.833
เขาบอกว่า best practice
ควรมี index ต่อหนึ่ง collection ไม่ควรเกิน 4

00:17:48.900 --> 00:17:51.433
สถานการณ์จริงผมเห็นสูงสุด 60

00:17:52.400 --> 00:17:56.633
สูงสุดของ index ที่มีได้ 64 ตัว

00:17:56.700 --> 00:18:01.333
โอเคไหมครับ ในหนึ่ง collection นะ
แต่ทุกครั้งที่เราทำเวลาโหลดขึ้น RAM

00:18:01.400 --> 00:18:04.133
RAM ไม่พอ ลองนึกภาพ 64 ตีไปซะว่า

00:18:04.200 --> 00:18:09.033
index หนึ่งใช้สอง GB ก็​เอา 2×64
แรมเครื่องของคุณก็หมดแล้ว

00:18:09.100 --> 00:18:13.033
เพราะฉะนั้น โดยปกติแล้ว
ค่าเฉลี่ยที่ผมเจอก็คือ โดยพื้นฐานประมาณ 10

00:18:13.700 --> 00:18:18.133
เพราะเราควรมี index ไม่เกินประมาณ 10 ให้เต็มที่
และไม่ควรเกิน 20

00:18:18.200 --> 00:18:21.833
collection เดียวนะครับ คุณนึกภาพนะ
มีอีก 1 collection มี 10 index

00:18:21.900 --> 00:18:25.033
index ตัวนึงเนี่ย ใช้ RAM เป็นร้อยๆ MB

00:18:25.100 --> 00:18:26.633
คุณมีซัก

00:18:26.700 --> 00:18:30.333
20 collection 100 collection คุณก็ไม่ไหว

00:18:30.400 --> 00:18:34.433
ปกติแล้ว MongoDB อนุญาตให้เรามี collection ได้ประมาณ

00:18:34.500 --> 00:18:37.833
ถ้าผมจำตัวเลขไม่ผิดนะครับ เป็นหลักหมื่นขึ้น

00:18:39.000 --> 00:18:43.033
ใน 1 database เลยนะ อนุญาตให้คุณมีเกิน 10,000 collection

00:18:43.100 --> 00:18:47.433
เกินกว่านั้นระบบจะยิ่งแบบ very slow มาก คือแบบอาจจะเกิดการพังได้

00:18:47.500 --> 00:18:49.333
แต่อนุญาตได้ถึงขนาดนั้น ซึ่ง

00:18:49.400 --> 00:18:54.133
ผมบอกอย่างนี้ได้ เพราะว่าเราเจอลูกค้า

00:18:54.200 --> 00:18:55.333
ที่เกินลิมิต

00:18:56.400 --> 00:19:01.033
คุณลองนึกภาพว่าออกแบบอย่างไร
ให้มี collection เป็นหมื่นๆ collection

00:19:01.100 --> 00:19:02.833
อยู่ใน database ก้อนนั้น

00:19:03.400 --> 00:19:06.633
นะครับ อันนี้คือแชร์ให้ฟังเนาะ นะครับ

00:19:06.700 --> 00:19:09.433
อ๋อ มันออกไลฟ์ด้วยนี่?

00:19:09.500 --> 00:19:12.933
ไม่เป็นไร ไม่ได้พูดถึงใครนะครับ

00:19:13.000 --> 00:19:16.633
นั่นคือหมายความว่า
อธิบาย index ว่าเราควรทำยังไงนะครับ

00:19:16.700 --> 00:19:18.033
มันจะมี detail นะครับ

00:19:18.100 --> 00:19:22.733
ต่อไปก็คือ พอเราพูดถึง set standard นะครับ
เราก็จะมี standard นะครับ เขาก็จะมีการ

00:19:22.800 --> 00:19:28.233
improve on industry benchmark
ก็คือเราบอกแล้วครับ เวอร์ชัน 8 เนี่ย เป็นเวอร์ชันที่แบบ

00:19:28.300 --> 00:19:32.333
ชูโรงเรื่อง performance มาก
เมื่อเทียบกับ MongoDB เวอร์ชัน 7 เลยนะครับ

00:19:32.400 --> 00:19:34.033
เขาจะเทียบกับ

00:19:34.100 --> 00:19:38.433
3 เจ้านี้ คุณเสิร์ชดูได้ ว่าเป็นเว็บไซต์

00:19:38.500 --> 00:19:42.333
หรือเป็นเครื่องมือ ที่คน ที่อยู่ในอุตสาหกรรม database

00:19:42.400 --> 00:19:45.433
จะต้องใช้เครื่องมือเหล่านี้ วัดประสิทธิภาพ

00:19:45.500 --> 00:19:49.833
จะ compare กับใครก็ตาม ไม่รู้
แต่คุณควรจะใช้อันนี้

00:19:49.900 --> 00:19:53.433
ถ้าคุณพูดถึงเป็น product ประเภท database vendor เนาะนะครับ

00:19:53.500 --> 00:19:54.333
เราต้องอ้างอิง

00:19:54.400 --> 00:20:00.533
แต่ในที่นี้เราจะ compare กับ version 7
เรายังไม่ compare กับเจ้าอื่นเนาะนะครับ

00:20:00.600 --> 00:20:02.033
เพราะฉะนั้นใน performance นี่ครับ

00:20:03.200 --> 00:20:08.033
เราเทียบนะครับ ให้เห็นภาพนะครับ
ว่าเรา bulk load เร็วขึ้น

00:20:08.100 --> 00:20:12.833
compare กับ version 7 เราเร็วขึ้น 54% นะครับ

00:20:12.900 --> 00:20:14.533
ในขณะที่ตัวนี้ออกเนี่ยมันออก

00:20:14.600 --> 00:20:17.833
มันภายในเนี่ยเค้าระบุตัวนี้ออกมาก่อนงานอยู่แล้วตั้งนาน

00:20:17.900 --> 00:20:22.133
ซึ่งมีคนเนี่ย อย่างเช่น เราเป็น engineer
ผมเป็น consult engineer ใช่มั้ย

00:20:22.200 --> 00:20:24.733
มันจะมี software engineer, consult engineer

00:20:24.800 --> 00:20:26.933
หรือตัว product engineer นะครับ

00:20:27.000 --> 00:20:31.033
ทุกคนเมื่อรู้ภาพนี้ปุ๊บ ทุกคนมีการทดสอบเลยเพราะว่าลูกค้า

00:20:31.100 --> 00:20:37.533
บางกลุ่มจะถูกเรียกมาให้ใช้งาน
ดังนั้นเขาจะวัดกัน ทุกคนก็จะเริ่มวัดทุกตัวเลย

00:20:37.600 --> 00:20:44.433
นะครับ ข้อดีของการที่เราวัดก็คือว่า
เราจะรู้ limitation สิ่งหนึ่งที่สำคัญมาก ก็คือผมเชื่อว่า

00:20:44.500 --> 00:20:51.233
หลายๆ database ทุกผลิตภัณฑ์นะครับ
จำเป็นที่จะต้องระบุว่าตัวเองมีข้อจำกัดอะไร

00:20:51.300 --> 00:20:58.133
ผมเชื่อว่าทุก database เหมาะกับงานแต่ละงาน
ในปริมาณ data ที่แตกต่างกัน

00:20:58.200 --> 00:21:01.833
เราสามารถจูนได้ทั้งหมด ให้ครอบคลุมจักรวาลก็ได้แบบ

00:21:01.900 --> 00:21:05.033
ทุกธุรกิจเลยสามารถใช้ database ยี่ห้อเดียว แล้วก็สามารถทำได้ ถูกไหมครับ

00:21:05.100 --> 00:21:06.733
แต่เราจำเป็นต้องรู้

00:21:06.800 --> 00:21:12.933
ข้อจำกัดของเขา เพื่อรู้ว่า
โอเค ถ้าคุณอยากจะไปใช้แบบนี้ คุณยังจะแบบทู่ซี้ไปใช้

00:21:13.000 --> 00:21:17.533
ธุรกิจแบบเนี้ย คุณจะต้องจูนมันยังไง
limit เป็นแค่ไหน เราจะรู้ นะครับ

00:21:17.600 --> 00:21:21.333
นั่นคือสิ่งสำคัญครับ ที่ผมบอกว่าทุก database ต้องเปิดเผย

00:21:21.400 --> 00:21:26.633
เราต้องมีการเรียนรู้เพื่อเราจะให้ความรู้แก่คนที่ใช้งาน หรือ developer ให้เข้าใจว่า

00:21:26.700 --> 00:21:31.533
ไม่ใช่แบบว่า โอเค คุณใช้เนี่ยเจ๋ง แต่ว่าคุณรู้ไหมว่า limit มันอยู่ตรงไหน

00:21:31.600 --> 00:21:35.033
ผมเป็นคนหนึ่งที่รู้ limit ค่อนข้างเยอะ
เพราะว่าลูกค้าถามมาว่า

00:21:35.100 --> 00:21:39.533
โอเค ตรงนี้ทำไมมันถึงพัง ตรงนี้มันถึง
มันถึงไม่ผ่าน เราก็จะไปค้นหา

00:21:39.600 --> 00:21:42.033
เราก็จะรู้ว่า โอเค มันคือ limitation

00:21:42.100 --> 00:21:46.733
เราก็สามารถให้คำแนะนำได้ว่า
โอเค limitation แบบนี้ควรจะแก้ท่าไหน ถ้าคุณอยาก

00:21:46.800 --> 00:21:52.533
จะยังคงใช้ MongoDB ของเราอยู่
เราสามารถจะใช้ท่าซิกแซกแบบไหนได้บ้าง เป็นต้น

00:21:52.600 --> 00:21:55.533
เขาจะเห็นภาพว่ามันโหลดเร็วขึ้น มัน read เร็วขึ้น

00:21:55.600 --> 00:21:59.133
ภาพเห็นก็คือเป็นการ compare based on version 7 นะครับ

00:21:59.200 --> 00:22:03.833
ขอย้ำนะ เป็นการ based version 7
ไม่ได้เปรียบเทียบ database ยี่ห้อใดๆ

00:22:03.900 --> 00:22:06.833
แต่เปรียบเทียบของตัวเองนะครับ

00:22:08.600 --> 00:22:11.533
ต่อไปนะครับ เรามาพูดถึงตัว

00:22:11.600 --> 00:22:15.833
performance นะครับ เป็นเรื่องของตัว time series

00:22:15.900 --> 00:22:19.033
ทุกคนรู้จัก time series ไหมครับ

00:22:20.300 --> 00:22:25.733
time series ก็คือมันเป็นโครงสร้างของ collection พิเศษนะครับ

00:22:25.800 --> 00:22:29.433
ที่ถูกออกแบบมาให้เก็บข้อมูลเกี่ยวกับเวลา

00:22:29.500 --> 00:22:34.933
เรามักจะใช้ time series collection นะครับ
ไว้สำหรับเก็บข้อมูลที่มีการ run แบบ real-time

00:22:35.000 --> 00:22:39.633
แล้วก็ดูเป็นเวลา เช่น พวกกราฟต่างๆ พวกที่เป็น crypto

00:22:39.700 --> 00:22:45.333
พวกที่เป็น crypto พวกที่เป็นการเงินนะครับ
เรามีธุรกิจลักษณะนั้นนะครับ แล้วเราก็

00:22:45.400 --> 00:22:48.233
ทำการที่จะออกแบบใส่ time series เข้าไป

00:22:48.300 --> 00:22:52.133
ซึ่ง time series จะมีปัญหาหนึ่งก็คือเรื่องการ group

00:22:52.200 --> 00:22:56.633
เพราะว่าเราต้อง group ถูกไหม
เช่น ข้อมูลที่เป็นประเภท Internet of Things

00:22:56.700 --> 00:23:00.133
เซ็นเซอร์ทั้งหมดเนี่ย วิ่งเร็วขนาดไหน
เรารู้อยู่แล้วตามโรงงาน

00:23:00.200 --> 00:23:03.633
เซ็นเซอร์จะวิ่งหรือยิง
หรือแบบกระทั่งกล้องวงจรปิดที่เราเห็นอยู่

00:23:03.700 --> 00:23:07.133
มันอาจจะส่งข้อมูลไป
ดังนั้นข้อมูลมันจะวิ่งเร็วมากเป็นระดับวินาที

00:23:07.200 --> 00:23:12.433
เพราะฉะนั้นการ grouping ข้อมูลวินาที
แปลว่าข้อมูลอาจจะเป็นแบบล้าน document ขึ้นไป

00:23:13.500 --> 00:23:18.833
ดังนั้นการ group นะครับ
เป็นหนึ่งในคำสั่งที่จะเรียกว่า block

00:23:18.900 --> 00:23:22.433
บล็อกการทำงาน
แปลว่ามันไม่สามารถจะ run แบบ parallel ได้

00:23:22.500 --> 00:23:24.433
มันจะบล็อกให้หยุดการทำงานก่อน

00:23:24.500 --> 00:23:30.033
ดังนั้นเขาก็บอกว่าเราจะเพิ่มประสิทธิภาพในการทำพวก time series ให้ดีขึ้น

00:23:30.100 --> 00:23:31.233
ก็ทำให้เร็วขึ้น

00:23:31.300 --> 00:23:35.633
เพื่อจะเพิ่มประสิทธิภาพ 60% นะครับ อันนี้ผมก็

00:23:35.700 --> 00:23:39.733
คิดว่าเขามีตัว proof อยู่แล้วนะ
เพียงแต่ว่าผมยังไม่ได้ไปอ่านพวก proof point

00:23:39.800 --> 00:23:43.633
แต่นี่คือสิ่งที่ถูกพัฒนาให้ดีขึ้น

00:23:43.700 --> 00:23:48.933
ใน time series ซึ่ง time series
จะเป็น collection ที่เหมาะสำหรับข้อมูลที่

00:23:49.800 --> 00:23:55.033
เราต้องการเก็บข้อมูลขนาดใหญ่ที่มีระดับแบบเป็น 10 ล้าน document

00:23:55.100 --> 00:24:01.833
ขึ้นไป แล้วข้อมูลมันจะ size ใหญ่
แล้วเราต้องการที่จะลดขนาด index

00:24:01.900 --> 00:24:05.533
และขนาด storage เฉพาะ collection นั้น
เราถึงจะทำเป็น time series

00:24:05.600 --> 00:24:09.033
เพราะฉะนั้น time series
ไม่ได้บอกว่าเหมาะสำหรับ time series

00:24:09.100 --> 00:24:10.733
หรือเป็น data time อย่างเดียว

00:24:10.800 --> 00:24:13.233
หรือเป็น data point ที่จะเหมาะกับข้อมูลใดๆ ก็ตามที่คุณอยากจะเก็บมัน

00:24:13.300 --> 00:24:17.933
และคุณอยากจะลด size มัน
แต่คุณต้องรู้ limitation เหมือนเดิมนะ

00:24:18.000 --> 00:24:19.533
คุณสามารถเข้าเว็บไซต์แล้วดู limitation

00:24:19.600 --> 00:24:24.433
เพราะว่าในเว็บไซต์ MongoDB ค่อนข้างที่จะ provide document ค่อนข้างเยอะละกัน

00:24:24.500 --> 00:24:29.533
เพราะฉะนั้นเราต้องถาม Gen AI
ในเว็บไซต์ MongoDB เนี่ย จะมีเมนูที่เป็น Gen AI

00:24:29.600 --> 00:24:32.133
เพื่อให้เราสอบถามแล้วมันก็จะวิ่งไปที่หน้าต่างต่างๆ ให้เรา

00:24:32.200 --> 00:24:35.233
แทนที่เราต้องไปนั่งคลิกๆ นะครับ เหนื่อยเสียเวลา

00:24:35.300 --> 00:24:39.233
เราก็อาจจะใช้วิธีการทำผ่าน Gen AI ของ MongoDB นั่นเองนะครับ

00:24:42.800 --> 00:24:44.333
ต่อไปนะครับ

00:24:50.500 --> 00:24:56.433
MongoDB ใช้ทุกยี่ห้อ หมายความว่า

00:24:57.700 --> 00:24:59.333
ถามเจมส์ เดี๋ยวให้เจมส์ตอบแล้วกัน

00:25:09.800 --> 00:25:13.833
AI ที่อยู่ของเราข้างใน มันจะเป็น Machine Learning Model

00:25:13.900 --> 00:25:16.533
มันไม่ใช่ Language Model มันใช้ Language Model
เราไม่มี Language Model อย่างนั้นครับ

00:25:16.600 --> 00:25:18.133
แต่เราจะมี Machine Learning Model

00:25:18.200 --> 00:25:20.433
ที่จะไว้ทำพวก Searching Vector Search อะไรอย่างเงี้ยครับ

00:25:20.500 --> 00:25:22.533
ซึ่งเดี๋ยวจะต่อไปจะพูดให้เดียวก่อนนะครับ

00:25:23.200 --> 00:25:28.133
ขอบคุณนะครับเจมส์ ก็คือเดี๋ยวรอทางเซคชั่นของคุณเจมส์นะครับ

00:25:28.200 --> 00:25:34.733
ต่อไปนะครับ เรามาพูดถึงตัวที่เป็น Query Execution Improvement นะครับ

00:25:35.300 --> 00:25:42.233
ก็คือเราก็จะลดการทำงานที่ช้าให้ทำงานได้เร็วขึ้น

00:25:42.300 --> 00:25:47.033
แล้วก็ทำการ improve plan cache นะครับ
plan cache คืออะไรนะครับ

00:25:47.100 --> 00:25:50.733
ตอนก่อนหน้านั้นเนี่ย ผมมาทำ relational database มาก่อนเนาะ

00:25:50.800 --> 00:25:54.033
ผมก็ใช้ plan cache ดู แต่ผมยังไม่เข้าใจมันอย่าง 100%

00:25:54.100 --> 00:25:55.533
พอผมมาทำ MongoDB ผมเลยต้องเข้าใจเยอะ

00:25:55.600 --> 00:26:01.233
เพราะว่าเรามีสิ่งหนึ่งที่ช่วยกระตุ้นทำให้เราเรียนรู้มากขึ้นในเชิงของ expert

00:26:01.300 --> 00:26:04.433
ในมุมของ product ของเขาก็เพราะว่าลูกค้าจะถามว่า

00:26:04.900 --> 00:26:10.133
เราทำยังไง
ทำไมเวลาที่เรา query แล้วมันไปเลือก index

00:26:10.200 --> 00:26:14.733
สมมุติว่าเราสร้าง index สองตัวมาใช้สำหรับ query ให้เร็ว

00:26:14.800 --> 00:26:19.133
index สองตัวเนี้ย query ที่เรารันไปเนี่ย
มันเลือก index ตัวที่ 1 แทนที่จะเลือกตัวที่ 2

00:26:19.200 --> 00:26:21.033
เราสร้างตัวที่ 2 มาเพราะว่าเราบอกว่า

00:26:21.100 --> 00:26:24.533
อยากให้ query ของเราเนี่ยไปใช้ index ตัวที่ 2 เพราะว่าประสิทธิภาพ

00:26:24.600 --> 00:26:29.433
เร็วขึ้น มันก็จะมีคนพบว่า
โอเค แสดงว่าทุกครั้งที่เรารันมันจะเก็บสถิติครับ

00:26:29.500 --> 00:26:34.233
สถิติที่มันเลือกใช้แล้วเหมาะสมมันจะเก็บไว้ที่เรียกว่า plan cache

00:26:34.300 --> 00:26:39.833
มันจะเก็บสถิติว่า พอเราเก็บปุ๊บ
แน่นอนครับ มันมีสถิติใหม่ ถูกไหม

00:26:39.900 --> 00:26:44.333
แต่มันบางครั้งเนี่ย มันจะไม่ทำการไป overwrite cache เดิม

00:26:44.400 --> 00:26:48.133
เราเลยต้องทำการเคลียร์มัน เราถึงรู้ว่ามันมี plan cache อยู่

00:26:48.200 --> 00:26:49.733
และ plan cache เนี่ย

00:26:49.800 --> 00:26:56.533
มันจะมี mechanism ในแต่ละ database
ที่เหมาะสมว่าเราควรจะ overwrite มันตอนไหน

00:26:56.600 --> 00:27:00.233
แต่เราสามารถจะบังคับมันเคลียร์ cache ได้

00:27:00.300 --> 00:27:05.633
เราจะเรียกตรงนี้ว่าเป็น plan cache
ในตัว plan cache เราก็จะมีการปรับปรุง

00:27:05.700 --> 00:27:12.433
ทำการ reduce กระบวนการ scan แล้วก็ fetch
ก็คือการหยิบเอกสารที่ถูกต้อง

00:27:12.500 --> 00:27:16.233
ของตัว MongoDB เวลาเรา query ให้ดีขึ้น

00:27:19.600 --> 00:27:23.633
อันนี้คือสิ่งที่มันจะเพิ่มนะครับ

00:27:23.700 --> 00:27:27.433
ก็คือนอกจากมัน improve ก็คือมันจะ improve เรื่องของ index นะครับ

00:27:27.500 --> 00:27:31.833
เรื่องของการเช็ค equality predicate ก็คือ การใช้คำว่าเท่ากับ

00:27:31.900 --> 00:27:36.133
การ find ข้อมูลที่แบบ match จริงๆ
เราจะเรียกว่าเป็นตัว equality นะครับ

00:27:36.200 --> 00:27:40.433
มันจะเพิ่ม stage หนึ่งเรียกว่า express นะครับ
คำว่า stage คืออะไรนะ

00:27:40.500 --> 00:27:44.133
ผมอาจจะบอกคร่าวๆ ว่ามันจะลงลึกไปตรง aggregation framework

00:27:44.200 --> 00:27:47.933
เวลาเราเขียน framework ของ MongoDB เนี่ย มันคือการเขียนแบบ

00:27:48.000 --> 00:27:52.233
เป็น stage ก็คือมองภาพเป็น data pipeline
แต่ละ data pipeline มีแต่ละฐาน

00:27:52.300 --> 00:27:53.433
ผมให้มองเป็นฐานเนาะ

00:27:53.500 --> 00:27:56.733
เพราะฉะนั้นเวลาเราล้อยเรียงกันแต่ละฐานเพื่อออก output

00:27:56.800 --> 00:27:59.533
คุณก็จะมีขั้นตอนฐานที่ 1 2 3 ทำอะไรถูกไหมครับ

00:27:59.600 --> 00:28:05.133
เราจะเรียกตรงเนี้ยว่าเป็น stage ซึ่งแต่ละ stage เนี่ยมันคือการเราเขียนคำสั่งแยกเข้าไป

00:28:05.200 --> 00:28:10.033
พอเราเขียนเข้าไปแต่ละฐานเนี่ย
พอเวลามันไป run อยู่บน MongoDB

00:28:10.100 --> 00:28:16.933
มันก็จะบอกว่า โอเค ฐานนี้ใช้ stage แปลว่าเรียกว่าอะไร เช่น fetch stage, merge stage

00:28:17.000 --> 00:28:20.433
มันก็จะมี stage ใหม่หรือฐานใหม่ที่ชื่อว่า express

00:28:20.500 --> 00:28:25.433
เพื่อช่วยทำการปรับปรุง query ที่เราทำ
ให้มีประสิทธิภาพเพิ่มขึ้น

00:28:25.500 --> 00:28:29.433
นั่นเองนะครับ อันนี้เป็นแบบบอกคร่าวๆ นะครับ
คือการเพิ่มฐานใหม่

00:28:29.500 --> 00:28:32.833
ในการแปลงคำสั่งเรา ชื่อว่า express นะครับ

00:28:34.400 --> 00:28:38.833
ซึ่งนะครับ มันก็จะปรับปรุงตัว latency
latency คือความช้าของแต่ละฐานนะครับ

00:28:38.900 --> 00:28:42.233
เขาก็จะปรับปรุงให้มีประสิทธิภาพเร็วขึ้น 17% นะครับ

00:28:43.800 --> 00:28:49.233
ต่อไปนะครับ เรามาพูดถึงเรื่องของ memory ครับ

00:28:49.900 --> 00:28:55.633
อันนี้ก็จะลงลึกนิดนึงนะครับ ผมว่าจะแบบง่ายๆ เพื่อให้ทุกท่านเข้าใจง่ายๆ ก็คือ

00:28:55.700 --> 00:29:01.833
ปกติเวลาเราอ่านเขียนข้อมูล
มันจะอ่านเขียนข้อมูลผ่าน memory

00:29:01.900 --> 00:29:06.833
สิ่งหนึ่งที่ทำให้เข้าใจก่อนนะครับ ก็คือ MongoDB เรามี RAM 64 GB

00:29:06.900 --> 00:29:11.933
ไม่ว่าคุณไปตั้ง database MongoDB เวอร์ชันอะไรก็ตาม รุ่นอะไรก็ตาม ที่คอมพิวเตอร์คุณ

00:29:12.000 --> 00:29:16.633
ถ้าคุณมี RAM 64 GB คุณไม่ได้เซ็ตอะไรเลย
มันจะใช้เพียงแค่

00:29:16.700 --> 00:29:20.433
50% นะครับ แล้วก็ลบไป 1

00:29:20.500 --> 00:29:25.033
50% แล้วก็ลบไป 1 ก็คือหมายความว่ามันจะใช้ประมาณครึ่งนึง

00:29:25.100 --> 00:29:25.833
ให้มองภาพ

00:29:25.900 --> 00:29:28.533
คุณมี 64 มันใช้แค่ 32

00:29:28.600 --> 00:29:33.733
มันไม่ใช้เกินกว่านั้นที่เป็นตัวหลัก
แต่ว่ามันมีโอกาสไปยืม

00:29:33.800 --> 00:29:38.733
ผมเรียกว่ายืม
ยืมส่วนที่เหลือมาใช้ เพราะว่าเราไปยืมบ่อยๆ

00:29:38.800 --> 00:29:44.633
ปกติแล้วระบบปฏิบัติการจะมองภาพว่า
ให้มองภาพว่าเรามีระบบ OS กับ database ใช่มั้ยครับ

00:29:44.700 --> 00:29:48.933
แล้วถ้า database ขอจองครึ่งหนึ่ง OS บอกว่า
โอเค เอาไปครึ่งหนึ่งพอนะ ขอฉันเป็นอีกครึ่งหนึ่ง

00:29:49.000 --> 00:29:52.833
คุณใช้ query run ไปแบบ run มากๆ เลย
บางคนอาจจะใช้ keyword

00:29:52.900 --> 00:29:55.833
ที่ผมอาจจะบอกว่าคือ keyword เรียกว่า allow disk use นะ

00:29:55.900 --> 00:29:59.133
เวลามันจะมี keyword นี้ ถ้าเราได้ใช้ query เยอะ เราจะเข้าใจ

00:29:59.200 --> 00:30:03.133
ก็คืออยากใช้ RAM เกินแบบ

00:30:03.200 --> 00:30:05.433
เกินกว่าที่มีอยู่นะครับ ไปขอยืม OS

00:30:05.500 --> 00:30:08.933
OS บอกว่า ยืมได้ อ่ะ ฉันให้ ยืมแล้วคืนนะ ยืมแล้วคืน

00:30:09.000 --> 00:30:12.033
มันจะมีบางครั้งครับ ที่เรายืม
ยืมไปถึง 90%

00:30:12.600 --> 00:30:18.033
พอไปถึง 90 OS บอกว่า
เฮ้ย ยืมเกิน 90 แล้ว ผมต้องการจะ

00:30:18.100 --> 00:30:22.433
ไม่ให้คุณยืม ผมจะหยุดคุณเลย
มันก็จะทำการมา stop database ครับ

00:30:22.500 --> 00:30:27.233
ให้ database หยุดทำงาน
นั่นคือการที่มันจะเกิดการ kill process ทิ้ง

00:30:27.300 --> 00:30:31.933
เพราะฉะนั้นแปลว่า ถ้าเราทำๆ ไปแล้วมัน fail
ไม่ต้องตกใจ มันก็คือแปลว่า

00:30:32.000 --> 00:30:37.133
คุณสามารถตรวจสอบกับ log ดูเลยว่ามันเกิดอะไรขึ้น
อันหนึ่งคือคุณใช้ RAM เกิน OS บอกมาห้าม

00:30:37.200 --> 00:30:37.933
เกินไปแล้ว

00:30:38.000 --> 00:30:41.333
ไม่งั้นเกินไปกว่านี้เกิดอะไรขึ้นครับ เครื่อง restart

00:30:41.400 --> 00:30:45.233
ดังนั้น คอมพิวเตอร์
ตัว OS พยายามไม่อยาก restart

00:30:45.300 --> 00:30:47.633
เครื่องตัวเอง เพราะว่า RAM ไม่พอ

00:30:47.700 --> 00:30:51.733
ดังนั้นเขาก็เลยตัดปัญหาว่าเกินปุ๊บจัดการ MongoDB ทิ้งเลย

00:30:51.800 --> 00:30:57.133
ให้ตัวเองพังไป มันก็จะ restart ขึ้นมาใหม่
เราสามารถจะ restart ขึ้นมาใหม่ได้

00:30:57.200 --> 00:31:01.833
ตอนนี้คือความหมายของตัว memory ก่อนนะครับ
นำมาสู่เรื่องของการเก็บ

00:31:01.900 --> 00:31:06.633
ข้อมูลนะครับ เพราะฉะนั้น
MongoDB จะอ่านเขียนผ่าน memory ก่อนเสมอ

00:31:07.900 --> 00:31:13.033
แล้วค่อยในประมาณไม่กี่วินาที
ไม่กี่มิลลิวินาที หรือระดับวินาที

00:31:13.100 --> 00:31:16.733
เราจะทำการเซฟจาก memory ลงบนไฟล์

00:31:16.800 --> 00:31:20.833
MongoDB สุดท้ายแล้วต้องเซฟบนไฟล์
สุดท้ายแล้วผมเชื่อว่า

00:31:20.900 --> 00:31:24.033
ผมเห็น database หลายๆ ยี่ห้อที่เคย run อยู่บน memory

00:31:24.100 --> 00:31:27.633
สุดท้ายต้องบอกตัวเองว่า ฉันเซฟเป็น memory ไม่ไหวเหมือนกัน

00:31:27.700 --> 00:31:30.833
ฉันก็ต้องเซฟบนไฟล์ด้วย
สุดท้ายทุกคนเซฟบนไฟล์ครับ

00:31:30.900 --> 00:31:34.433
เพราะไฟล์คือสิ่งที่การันตีได้ว่าข้อมูลของคุณอยู่ถาวร

00:31:34.500 --> 00:31:36.633
ถ้า hard disk ไม่พัง ไฟล์ไม่เสียจริงไหม

00:31:36.700 --> 00:31:41.433
เพราะฉะนั้น นั่นคือเหตุผลที่ทุกคนจะอ่าน memory เร็วขนาดไหนก็ตาม ทุกคนต้องลงไฟล์ครับ

00:31:41.500 --> 00:31:46.033
ดังนั้น MongoDB ก็เหมือนกันครับ
เราอ่านเขียนอยู่บน RAM

00:31:46.100 --> 00:31:47.833
สุดท้ายเราก็ต้องเอาลงบนไฟล์

00:31:47.900 --> 00:31:51.033
เพราะฉะนั้นเขาก็จะบอกว่าวิธีการจัดการ data file—

00:31:51.100 --> 00:31:52.633
data เนี่ยจะอยู่บน RAM

00:31:52.700 --> 00:31:56.133
เขาก็จะบอกว่ามันจะมีช่องว่างนะครับเวลาที่

00:31:56.200 --> 00:31:59.333
เราเก็บข้อมูลเป็นไฟล์ๆ เนี่ย มันก็จะอ่านเขียนไฟล์นะ

00:31:59.400 --> 00:32:01.733
เหมือนเราอ่าน Excel ครับ ให้มองภาพว่า

00:32:01.800 --> 00:32:06.233
มี Excel 1 Excel แล้วมีประมาณ 10 sheet
แต่ละ sheet เป็น row

00:32:06.300 --> 00:32:07.133
โอเคไหมครับ

00:32:07.200 --> 00:32:09.733
1 document ก็คือ 1 row เพราะฉะนั้นเราลบข้อมูล

00:32:09.800 --> 00:32:13.833
เราอ่านข้อมูลมันก็จะแบบเติม row เข้า row อย่างเงี้ยนะครับ MongoDB ก็จะเป็นแบบนั้นคือ

00:32:13.900 --> 00:32:19.333
มันจะทดแทนชดเชย row ที่หายไปสลับไปสลับมา
เราจะเรียกส่วนนั้นว่าเป็นพวก data page นะ

00:32:19.400 --> 00:32:20.833
ถ้าเรามองภาพ data page

00:32:20.900 --> 00:32:24.633
เพราะฉะนั้นมันจะมี gap นิดนึง
เราพยายามจะลดช่องว่างของ gap ลงนะครับ

00:32:24.700 --> 00:32:30.733
เพื่อจะ improve performance นะครับ
ลดช่องว่างตรงนั้นลงประมาณ 18%

00:32:30.800 --> 00:32:33.333
เพื่อให้มันง่ายขึ้นนะครับ อันนี้เป็นแบบ

00:32:33.400 --> 00:32:37.433
เป็นอธิบายที่ง่ายนะ
มันมี technical ค่อนข้างละเอียดนะครับ

00:32:37.500 --> 00:32:39.233
อันนี้คือการ improve นะครับ

00:32:39.300 --> 00:32:40.633
ต่อไปนะครับ

00:32:46.600 --> 00:32:51.333
…แล้วก็ตัวเซิร์ฟเวอร์ที่มี primary database เนี่ย

00:32:51.400 --> 00:32:57.833
ใช้แรมอยู่ประมาณ 500 GB แล้วเราเห็นว่า memory เนี่ยขึ้นไป 50%

00:32:57.900 --> 00:33:00.833
เรากำลังคิดว่าเวลาที่มันช้าเป็นบางช่าง
เนื่องจากว่ามันเป็น lag

00:33:00.900 --> 00:33:03.433
ที่ตัวฮาร์ดดิสก์ หรือ SSD

00:33:03.500 --> 00:33:10.433
ถ้าเราจ่ายเงินเพื่อซื้อแรมเป็น 1TB ไปเลย
เราคิดว่ามันจะเพิ่มความเร็ว

00:33:10.500 --> 00:33:11.833
แบบมีนัยยะไหม

00:33:15.300 --> 00:33:20.733
ต้องเรียนอย่างนี้ครับ อย่างแรกเลย

00:33:20.800 --> 00:33:23.533
สิ่งที่จะต้อง verify เพราะว่าปัญหาเนี่ย

00:33:23.600 --> 00:33:25.133
เราจะ verify ได้หลายส่วน

00:33:25.200 --> 00:33:28.633
การจ่ายเงินอาจจะไม่สามารถช่วยตรงนั้นได้

00:33:28.700 --> 00:33:33.633
หากเราไม่รู้ตัวคอขวด เพราะฉะนั้นหลักการง่ายๆ
คือเราต้องอ่าน log ก่อน ประเด็นแรกนะครับ

00:33:33.700 --> 00:33:36.933
เพราะโดยปกติแล้ว MongoDB
ก็เหมือน database ทั่วไป

00:33:40.200 --> 00:33:41.733
ครับ

00:33:46.700 --> 00:33:48.533
…ดังนั้นเราจึง…

00:35:11.800 --> 00:35:12.633
ทดสอบ ทดสอบ

00:35:25.000 --> 00:35:29.033
(…จำนวนของ collection ที่ว่าห้ามเกิน…)

00:35:29.100 --> 00:35:34.833
(กี่ collection ต่อ 1 database
ทีนี้ถ้าเกิดในเคสที่ว่าใน 1 node หรือ 1 replica)

00:35:34.900 --> 00:35:40.833
(ผมอาจจะมีอยู่ซัก 20,000 database ใน 1 node นะครับ)

00:35:40.900 --> 00:35:45.533
(ในแต่ละดาต้าเบสก็จะจะมีคอลเลคชั่นซักประมาณ 1000 กว่าตัว)

00:35:45.600 --> 00:35:48.233
(โดยรวมรวมก็เป็นแสน)

00:35:48.300 --> 00:35:49.833
(อย่างนี้จะมีปัญหาไหมครับ)

00:35:49.900 --> 00:35:56.733
ที่จริงแล้วถ้าถามผมก็คือมันจะมีปัญหาแน่นอน
ในเรื่องที่เราต้องดูว่า

00:35:56.800 --> 00:36:01.633
ที่เราต้องดูว่ามันเป็นเรื่องของตัว memory ครับ
ปกติแล้ว data ที่ช้า

00:36:01.700 --> 00:36:05.233
นอกจาก collection ที่ใหญ่แล้ว เราต้องมีการคำนวณดูว่า

00:36:05.300 --> 00:36:08.033
ปกติแล้วมันจะใช้อัตราการ write ครับ

00:36:08.300 --> 00:36:13.933
อัตราการ write ประมาณ 30% ของขนาด sizing ทั้งหมด

00:36:14.000 --> 00:36:17.433
หมายความว่าถ้า 1 terabyte ครับ เราจะใช้ RAM อยู่ประมาณ

00:36:17.500 --> 00:36:19.133
300 GB เนอะ

00:36:19.200 --> 00:36:24.133
300 GB เพื่อให้ประสิทธิภาพเยี่ยมที่สุด ดีที่สุด

00:36:24.200 --> 00:36:26.433
ในความเป็นจริงไม่มีทาง ถูกไหม

00:36:26.500 --> 00:36:30.833
นั่นจึงเป็นเหตุผลที่ MongoDB ออกแบบให้เรามีการ scale out

00:36:30.900 --> 00:36:32.133
ออกไปทำ sharding

00:36:33.300 --> 00:36:38.033
อันนี้เป็นเรื่องปกติเลยนะครับ
เพราะว่าลูกค้าทุกคนเนี่ยเวลาที่เขาถามว่า

00:36:38.100 --> 00:36:39.133
เออ ผมต้องทำ sharding ผมก็บอกว่า

00:36:39.200 --> 00:36:43.033
โอเค คุณต้องดูก่อนนะว่าต้องดูตัวเดียวคือดู collection

00:36:43.100 --> 00:36:50.133
ถ้า collection ใหญ่ถึงประมาณเกิน 500 GB แล้วเนี่ย
คุณควรพิจารณาเอา collection นั้นเริ่มทำ sharding

00:36:50.200 --> 00:36:51.933
เพราะว่าคุณมองภาพว่า

00:36:52.000 --> 00:36:55.633
database ใช้ RAM สำหรับ write และ read

00:36:55.700 --> 00:37:01.333
ไม่ใช่แค่ read อย่างเดียวนะ
write และ read เราต้องมี RAM ที่สำรองในการ manage

00:37:01.400 --> 00:37:04.233
ของเขาประมาณอย่างต่ำ 30%

00:37:04.300 --> 00:37:09.233
นั่นแปลว่าคอมพิวเตอร์เซิร์ฟเวอร์ 1 เครื่อง
คงอัด RAM มากมายขนาดนั้นไม่ได้ จริงไหมครับ

00:37:09.300 --> 00:37:15.133
ดังนั้นมันจะมีประสบปัญหาเรื่องความช้า
แล้วก็ช้าทั้ง read และ write โดยปริยายในอนาคต

00:37:16.100 --> 00:37:17.933
นะครับ ตรงนี้นะครับ

00:37:28.200 --> 00:37:32.433
ที่จริงแล้วมันจะดูด้วย 2 แบบ
ปกติเราสามารถจะดูได้ก็คือ

00:37:32.500 --> 00:37:34.833
ปกติแล้วนะครับเวลามันช้าเนี่ย

00:37:34.900 --> 00:37:37.433
เหตุผลหลักๆ เลยก็คือ index ไม่มี

00:37:38.400 --> 00:37:43.533
ใช้ index ผิด มันจะขึ้นประโยคที่ว่า slow query
เราสามารถอ่านใน log ประเด็นแรกก่อนเลยครับ

00:37:43.600 --> 00:37:48.733
เราใช้ใน log เพราะฉะนั้นเราจะมี tool ตัวหนึ่ง
ที่เป็น open source tool ซึ่งเป็น senior

00:37:48.800 --> 00:37:51.833
เป็น staff engineer ของ MongoDB สร้างไว้ชื่อว่า

00:37:51.900 --> 00:37:56.433
Hatchet H-A-T-C-H-E-T

00:37:56.500 --> 00:37:59.733
เป็น tool ที่พัฒนาเป็น open source
พัฒนาด้วยภาษา Go

00:37:59.800 --> 00:38:02.433
ฉะนั้น tool ตัวนี้จะเป็นตัว analysis ครับ

00:38:02.500 --> 00:38:07.133
และทำให้เราเอา log มา analyze และขึ้นเป็น graph เลย

00:38:07.200 --> 00:38:10.833
แล้วก็จะเป็นคำพูดเป็นประโยชน์เหมือน AI พูด

00:38:10.900 --> 00:38:14.633
เป็นเหมือนชื่อภาษาอังกฤษผู้หญิงผู้ชายสักตัวหนึ่ง พูดเป็นภาษาอังกฤษว่า

00:38:14.700 --> 00:38:15.933
ตอนนี้เครื่องของคุณ

00:38:16.000 --> 00:38:19.933
ฉันอ่าน log ของคุณจากวันที่ A เวลานี้ ถึงวันที่ B เวลานี้

00:38:20.000 --> 00:38:21.233
คุณพบว่าช้าขนาดไหน

00:38:21.300 --> 00:38:23.733
มี collection นี้ run ให้ยากลำบากแค่ไหน

00:38:23.800 --> 00:38:29.333
RAM ของคุณเป็นยังไง driver ของคุณไม่ compatible แล้วหรือยัง

00:38:29.400 --> 00:38:31.933
อันนี้จะเป็นส่วนที่ทำให้เรา analyze ได้

00:38:33.100 --> 00:38:36.333
เพราะฉะนั้นในนั้นจะบอก สุดท้ายเราจะเอาพวกนี้ไป proof หมด

00:38:36.400 --> 00:38:39.733
เพราะบางคนผมเจอว่าดีเหมือนทุกอย่างเลย
แต่ driver เก่า

00:38:41.100 --> 00:38:46.033
แล้วเขาก็ไม่เปลี่ยนหากไม่มีหลักฐานยืนยัน
เราก็ต้องใช้ tool พวกนี้แล้วให้ tool มันบอก

00:38:46.100 --> 00:38:47.033
เพราะเราไม่บอกเอง

00:38:47.100 --> 00:38:52.133
เราบอกว่า โอเค tool เราพัฒนา เราบอกแล้วว่า
driver ของคุณเก่า ช่วยเปลี่ยนเถอะ

00:38:52.200 --> 00:38:56.633
เพื่อมันจะ compatible กับ database ที่คุณเป็นเวอร์ชันใหม่ อย่างนี้เป็นต้น

00:38:56.700 --> 00:39:02.333
ทุกอย่างมีหลักฐาน อันนี้น่าจะตอบคำถามด้วยดูใน log

00:39:03.700 --> 00:39:06.833
ต่อไปนะครับ เขาก็จะ performance ในเรื่องนะครับ

00:39:06.900 --> 00:39:10.533
กลับมาตรงนี้เนอะ ก็คือปกติแล้วทุกคนรู้จัก replica เนาะ

00:39:10.600 --> 00:39:13.633
replica จะมีปัญหาหนึ่งก็คือเรื่อง lag time

00:39:13.700 --> 00:39:17.533
lag time ก็คือหมายความว่าเวลาเราสร้าง server
เราจะวางบน VM

00:39:17.600 --> 00:39:19.833
คุณจะวางไว้ที่ region เดียวกันประเด็นแรก

00:39:19.900 --> 00:39:26.233
วางไว้บนตัว AZ ตัวเดียวกันแบบใกล้เคียงกันคือเช่น

00:39:26.300 --> 00:39:30.933
คุณวางสิงคโปร์ 1 สิงคโปร์ 2 สิงคโปร์ 3
โอเค ยังคงมีระยะทางที่ได้

00:39:31.000 --> 00:39:35.533
หรือถ้าคุณไปวางแบบสิงคโปร์ที อเมริกาที นะครับ

00:39:35.600 --> 00:39:40.933
ญี่ปุ่นที ซึ่งตรงนี้ก็มีเหตุผลเป็นเรื่องปกติ
ที่มันจะเกิดเรื่อง performance หรือ lag time

00:39:41.000 --> 00:39:44.633
คำว่า lag time performance จะเกิดตอนไหน
เกิดตอนที่คุณต้องการจะ

00:39:44.700 --> 00:39:50.833
เกิดหนึ่ง เวลาระบบล่ม
เวลาระบบล่มที่สิงคโปร์มันจะ switch

00:39:50.900 --> 00:39:57.333
สมมุติว่าไปที่ฮ่องกง
การ switch ไปเนี่ยมันช้าหรือเร็วเพราะตัว latency

00:39:57.400 --> 00:40:00.533
กว่ามันจะ switch แอปพลิเคชันคุณต้องแก้ config ให้ถูกต้อง

00:40:00.600 --> 00:40:06.433
ในการ run อยู่ภายใน 10 วินาทีนะ มันก็จะทำได้
ตรงนี้เราจะ improve เรื่อง lag time มากขึ้น

00:40:06.500 --> 00:40:10.133
เพื่อให้การันตีได้ว่าเกิด lag น้อยลงนะครับ

00:40:10.200 --> 00:40:13.233
อันนี้เป็นเรื่องของการทำ HA ของตัว replica set นะครับ

00:40:15.500 --> 00:40:16.233
อ่า นี่นะครับ

00:40:17.300 --> 00:40:22.433
เขาก็จะเขียนว่า จะมีเรื่อง decrease replication
การ acknowledge ที่เร็วขึ้นนะครับ

00:40:22.500 --> 00:40:26.333
ถ้าบางคนไม่รู้จัก acknowledge ก็คือว่า database ทุกตัวครับ ควรจะมีเรื่องนี้

00:40:26.400 --> 00:40:31.033
ก็คือเรื่อง acknowledge MongoDB ใช้ acknowledge
เราจะเรียก acknowledge หรือว่าเป็นตัว w

00:40:31.100 --> 00:40:35.733
เวลามันจะเป็นการ set ที่ connection string ของ application

00:40:35.800 --> 00:40:40.833
ที่ใช้ driver official ของ MongoDB ที่อยู่ภายในนั้นนะครับ

00:40:40.900 --> 00:40:42.533
w แปลว่า write concern

00:40:42.600 --> 00:40:46.933
คำว่า w ก็คือเป็นการบอกว่า
เราจะ acknowledge เร็วแค่ไหน

00:40:47.000 --> 00:40:50.433
เช่น สมมุติว่า w เท่ากับ 0

00:40:50.500 --> 00:40:53.933
ก็คือว่าคุณจะ acknowledge แบบเร็วเลยทันที ไม่ต้อง replica set

00:40:54.000 --> 00:40:56.733
หรือเราใช้ w เท่ากับ majority แปลว่ามี 3 เครื่อง

00:40:56.800 --> 00:41:00.033
จะต้องมี 2 เครื่องที่มี copy data แล้วค่อย acknowledge ไป

00:41:00.100 --> 00:41:00.933
นี้เป็นต้นนะครับ

00:41:01.000 --> 00:41:05.133
อันนี้คือเป็นเรื่องของตัว acknowledge ที่จะพัฒนาให้เร็วขึ้นนั่นเองนะครับ

00:41:06.500 --> 00:41:12.433
โอเค จะเพิ่ม 20% นะครับ ต่อไปนะครับ
นี่คือเป็นการเพิ่ม enhanced performance เนาะนะครับ

00:41:12.500 --> 00:41:15.133
อันนี้ก็จะผ่านไปก่อนเนาะ เพราะมันเป็นเรื่องของภายใน

00:41:15.200 --> 00:41:18.733
ก็คือพูดง่ายๆ Atlas จะปรับปรุงกับตัว self-manage จะปรับปรุงมากขึ้น

00:41:18.800 --> 00:41:20.533
ในเรื่องของ lag ต่างๆ นะครับ

00:41:21.900 --> 00:41:25.333
โอเค นะครับ โห เยอะ…

00:41:25.400 --> 00:41:29.233
ตัวนี้ก็คือจะเป็นเรื่องของตัวจัดการเรื่องพวก plan cache นะครับ

00:41:29.300 --> 00:41:32.033
ตัวนี้ก็ improve ครับ ก็คืออันนี้พูดที่ Atlas

00:41:32.100 --> 00:41:35.533
ผมจะไปที่จุดสำคัญ มันอาจจะค่อนข้างเยอะนะครับ

00:41:35.600 --> 00:41:40.733
ส่วนที่เป็น Atlas นะ Atlas จะมีหน้าจอหนึ่งบน Atlas ก็คือ cloud service ของ MongoDB

00:41:40.800 --> 00:41:44.833
จะมีเรียกว่า query insight จะบอกว่า query ตัวไหน run ช้า run เร็ว

00:41:46.400 --> 00:41:48.533
run collection ตัวไหนบ้าง จะละเอียดกว่าเดิม

00:41:48.600 --> 00:41:51.533
เมื่อก่อนจะไม่ใช่ตัวนี้ เมื่อก่อนจะเป็นแค่แบบ profiler ธรรมดา

00:41:51.600 --> 00:41:55.333
ตอนนี้จะเป็นแบบ query insight เลย
เห็นชัดๆ เลยว่าเป็นตัวไหนนะครับ

00:41:55.400 --> 00:41:56.633
เพื่อช่วยลดปัญหานะครับ

00:41:56.700 --> 00:42:00.533
เขาจะพัฒนามาเพื่อสุดท้ายแล้ว อยากให้ developer มีความรู้แล้วก็แบบ

00:42:01.500 --> 00:42:06.833
อ่านเห็นได้ง่าย เพราะ MongoDB บน cloud เราเรียกว่าเป็น developer data platform

00:42:06.900 --> 00:42:10.033
เป็นแพลตฟอร์มสำหรับ developer ทำงานแทน DBA ได้

00:42:11.000 --> 00:42:15.433
พูดตรงๆ ก็คือเขาพยายามให้ developer ทำงานมี skill DBA ได้ด้วยในตัว

00:42:15.500 --> 00:42:18.833
เพราะฉะนั้นเขาจะทำเรื่อง monitor ให้ง่ายขึ้นนะครับ

00:42:19.900 --> 00:42:24.533
อันนี้เราก็สามารถ compare ได้นะครับ
แล้วก็สามารถดู query trend ได้ด้วยนะครับ

00:42:24.600 --> 00:42:28.933
เป็น plot graph เป็น data point นะครับ แล้วก็สามารถดู shape ได้นะครับ

00:42:29.600 --> 00:42:30.233
โอเค ต่อไป

00:42:30.300 --> 00:42:33.833
มาถึงเรื่องที่ผมคิดว่าน่าสนใจก็คือ query shape นะครับ

00:42:33.900 --> 00:42:37.833
query shape ก็คือเวลาเรา query เราดู plan มันจะมี shape นะครับ

00:42:37.900 --> 00:42:40.333
shape จะเข้ารหัสแบบนี้ เราสามารถ block

00:42:41.600 --> 00:42:45.233
block บอกว่า query เนี้ยหากมี application ยิงมา

00:42:45.300 --> 00:42:49.433
ถ้าเป็น query shape นี้นะ คำว่า shape นี้ไม่ใช่แปลว่า query command อะไรนะ

00:42:49.500 --> 00:42:51.533
มันจะ detect shape นั้น query อาจจะมีหลาย style

00:42:51.600 --> 00:42:54.733
แต่มันตรงกับ shape เนี้ย มันก็ยังคงเป็น shape นี้เสมอ

00:42:54.800 --> 00:42:56.933
งั้นพอมันเป็น shape นี้เรา block shape นี้ได้

00:42:57.000 --> 00:43:01.733
ข้อดีก็คือว่า เราไม่ต้องแก้แอปครับ เราแค่ command เข้าไปบอกเค้าว่า block

00:43:02.800 --> 00:43:07.233
แอปพลิเคชันที่ยิงเข้ามาด้วย shape เดิมจะเกิด error เข้าไปบอกว่า

00:43:07.300 --> 00:43:09.133
เอ้ย คุณโดน block เพราะว่า

00:43:09.200 --> 00:43:14.133
คุณโดนบล็อกเพราะว่าคุณ เขาเรียกว่าอะไร
คุณโดนบล็อกเพราะว่า query ของคุณเนี่ยมีปัญหา

00:43:14.200 --> 00:43:20.033
มันทำการบล็อกคุณ จะมี error ไป detect ทันที
อันนี้เรียกว่าเป็น query shape

00:43:20.100 --> 00:43:21.933
เพราะฉะนั้นอันนี้ก็จะเป็นคำบอกนะ

00:43:22.000 --> 00:43:23.333
ผมลงรายละเอียดไปนิดนึง

00:43:23.400 --> 00:43:25.433
ก็คือเป็นการบอกว่าเราต้องการ reject

00:43:25.500 --> 00:43:29.133
query ที่รันมาแล้วเป็น collection scan เราต้องการบล็อก query นี้

00:43:29.200 --> 00:43:30.433
แล้วก็เข้าไปแก้เลยครับ

00:43:30.500 --> 00:43:36.833
พิมพ์ command ปุ๊บ กดทำ
อันนี้ก็คือสิ่งที่สามารถจะบล็อกได้ทันที

00:43:36.900 --> 00:43:42.433
ต่อไปก็คือเราจะทำเรื่องของพวก timeout ต่างๆ
เรามักจะมีคนถามปัญหาบ่อยว่า

00:43:42.500 --> 00:43:45.833
connect แล้วเกิด timeout
timeout แบบนี้แบบนั้นเราจะทำยังไง

00:43:45.900 --> 00:43:48.433
หนึ่งนั้นก็คือเราสามารถ set default max time

00:43:48.500 --> 00:43:49.633
time ได้นะครับผม

00:43:49.700 --> 00:43:54.033
เพื่อช่วยให้นะครับ การ read เนี่ยมี timeout ได้ด้วยนะครับ

00:43:54.100 --> 00:43:57.633
ตรงนี้เป็นสิ่งที่เพิ่มเติมขึ้นมา ตรงนี้นะครับ

00:43:59.900 --> 00:44:01.033
อ่า ต่อไปนะครับ

00:44:01.100 --> 00:44:06.133
ส่วนนี้คือเป็นส่วนที่เราบอกว่าเราสามารถที่จะเซ็ต query pattern ได้

00:44:06.200 --> 00:44:09.833
ปกติเรามีปัญหาครับ ทุกคนเคย force index ไหมครับ

00:44:09.900 --> 00:44:12.733
เวลาเราเขียน query เรามักจะ force ว่า index มี 3 ตัว

00:44:12.800 --> 00:44:14.533
แต่เราบอกว่าเราฉากใช้ตัวที่ 3 อ่ะ

00:44:14.600 --> 00:44:16.733
เราบอกว่า query เราไม่แตะตัวที่ 3 เลย

00:44:16.800 --> 00:44:20.233
เราบอกว่าเราใช้ hint หรือ force ให้มันใช้ index ตัวที่ 3 ตลอด

00:44:20.300 --> 00:44:23.933
แต่ตอนนี้เราไม่ต้องทำแบบนั้นนะครับ
ไม่ต้องไปแก้ application

00:44:24.000 --> 00:44:24.733
เราบอกเลยว่า

00:44:24.800 --> 00:44:29.533
ตอนเนี้ยใช้ shape เนี้ย
ถ้าคุณมา index ตัวนี้ คุณใช้ shape นี้เลย

00:44:29.600 --> 00:44:33.033
เป็นข้อดีก็คือหมายความว่า คุณจะถูกใช้อันเนี้ยตลอด

00:44:33.400 --> 00:44:35.733
ข้อเสียคือว่า คุณต้องมาเปลี่ยน command เอง

00:44:36.500 --> 00:44:40.533
เพราะว่ามันจะจำถาวร ไม่ว่าเครื่องจะ restart ขึ้นไป

00:44:40.600 --> 00:44:44.833
มันจะไม่ reset index plan ต่างๆ นะครับ ไม่เซ็ตเลยนะครับ

00:44:46.600 --> 00:44:47.733
โอเค นะครับ

00:44:48.600 --> 00:44:54.033
ส่วน scaling นะครับ
พูดง่ายๆ ว่า ทำ sharding สามารถ move

00:44:54.100 --> 00:44:55.933
collection ที่ไม่ shard ได้

00:44:56.000 --> 00:45:00.433
ด้วย command ของมันเอง อัตโนมัติ แล้วก็ทำงานได้เร็ว มีประสิทธิภาพ

00:45:00.500 --> 00:45:02.633
เราจะเรียกตัวนี้ว่าเป็นการ move shard นะครับ

00:45:02.700 --> 00:45:05.533
นี่เขาเรียกว่าเป็นการ move collection เนาะ อัตโนมัติ นะครับ

00:45:07.300 --> 00:45:10.033
ลักษณะก็คือนะครับ ก็คือเราสามารถ move shard ได้เลยเนาะ

00:45:10.100 --> 00:45:11.933
อันนี้ก็คือเป็น

00:45:12.000 --> 00:45:16.033
ตัว feature นึงนะครับ เมื่อก่อนเรา move ยากนะ
เดี๋ยวนี้เรา move ง่ายนะครับ

00:45:16.100 --> 00:45:19.033
แค่พิมพ์ command ว่า move collection ไปอยู่ shard ไหน

00:45:19.100 --> 00:45:21.333
เรา move ได้เลย เพื่อทำให้มัน balance ครับ

00:45:21.900 --> 00:45:24.733
ทำให้ เอ่อ ตัว shard แต่ละ shard มีความ balance

00:45:24.800 --> 00:45:29.333
ทั้ง collection ที่ shard และ uncollection เอ่อ unsharding collection นะครับ

00:45:30.800 --> 00:45:34.833
โอเค ต่อไปก็คือเขาแค่เพิ่มนะครับ ความเร็วในการ

00:45:34.900 --> 00:45:40.433
ประสิทธิภาพในการทำ reshard
คำว่า reshard ก็คือ ทำ shard

00:45:40.500 --> 00:45:42.733
หมายความว่า อันนี้ลงนิดเดียวนะครับ

00:45:42.800 --> 00:45:46.333
การทำ shard ต้องมีการระบุ key ว่าเราจะแบ่ง data ไปแต่ละ

00:45:46.400 --> 00:45:50.733
ไปแต่ละ server ใช้อะไรเป็นตัวแบ่ง
พูดง่ายๆ เจ้าตัวแบ่งเนี่ยนะครับ

00:45:50.800 --> 00:45:54.233
เวลาเราเลือกผิด เรามักจะต้องสร้างตัวแบ่งนี้ใหม่

00:45:54.300 --> 00:45:57.433
สร้างตัวแบ่งนี้ใหม่ ข้อมูลเป็นระดับ 10 terabyte เนี่ย

00:45:57.500 --> 00:45:58.333
ใช้เวลาหลายวัน

00:45:59.400 --> 00:46:03.133
เคยทำด้วย key นี้
10TB เสร็จละ

00:46:03.200 --> 00:46:07.733
วันนี้คือ อ้าว ผิด เลือก key ผิดอ่ะ
ขอเปลี่ยน key ใหม่ reshard ใหม่นะครับ

00:46:07.800 --> 00:46:09.133
ใช้เวลาอีก 10 กว่าวัน

00:46:09.200 --> 00:46:11.533
ในระหว่างทำ
time performance drop อยู่แล้ว

00:46:12.200 --> 00:46:16.833
ดังนั้นเขาก็เลยออกแบบให้มีระบบกระบวนการที่เรียกว่า faster resharding

00:46:16.900 --> 00:46:22.833
ให้เร็วขึ้น คือการเพิ่ม performance นั่นเองนะครับ
อันนี้คือภาพที่เห็นนะครับ จากเมื่อก่อน

00:46:22.900 --> 00:46:28.533
1TB นะครับ มีการใช้ครับ 220 ชั่วโมงนะ เวอร์ชันนี้

00:46:28.600 --> 00:46:30.233
เวอร์ชันนี้ 12 ชั่วโมงนะครับ

00:46:30.300 --> 00:46:34.233
เพราะฉะนั้นแปลว่า เวอร์ชันที่เราใช้เนี่ย ตอนนี้เวลาลดลงเห็นไหมครับ

00:46:34.300 --> 00:46:36.633
จาก 200 กว่าชั่วโมง เหลือแค่ 12 ชั่วโมง

00:46:38.300 --> 00:46:42.233
ทำเร็วขึ้นนะครับ เวอร์ชันนี้ก็คือเป็นเวอร์ชันที่เข้าแล้ว

00:46:42.300 --> 00:46:45.233
เป็นเวอร์ชันคั่นกลางระหว่างเมเจอร์ด้วยกัน

00:46:45.300 --> 00:46:49.433
แต่เราไม่ค่อยนิยมใช้งานจริงๆ แต่ว่ามันจะถูกนำไปทดสอบ

00:46:49.500 --> 00:46:52.533
แล้วก็สุดท้ายนำไปใช้งานจริงบนเวอร์ชัน 8

00:46:52.600 --> 00:46:55.633
ก็คือลดไปประมาณ 10 เท่านะครับ

00:46:57.400 --> 00:47:00.433
ต่อไปนะครับ แบบนี้ก็คือเป็นสิ่งที่อำนวยความสะดวก

00:47:00.500 --> 00:47:04.233
ปกติแล้วเวลาเราทำ shard จะมีเซิร์ฟเวอร์อย่างน้อยๆ เพิ่มอีก 3 เครื่อง

00:47:04.300 --> 00:47:07.933
1 shard ก็คือมี 3 node อยู่แล้ว

00:47:08.000 --> 00:47:09.733
แล้วก็มีอีกสามเครื่อง ดังนั้น

00:47:09.800 --> 00:47:14.933
การทำเซิร์ฟเวอร์ที่เพิ่มเติมขึ้นมา
มันทำให้เราเสีย cost มากขึ้น

00:47:15.000 --> 00:47:17.633
ดังนั้นระบบ shard เลยบอกว่าเราต้องการ

00:47:17.700 --> 00:47:18.633
ยุบ

00:47:18.700 --> 00:47:23.833
ค่าใช้จ่ายของบาง server ลง เราเรียก server ตัวนั้นว่า config นะครับ

00:47:23.900 --> 00:47:25.333
อันนี้อาจจะเป็น detail ไปก่อนนะ

00:47:25.400 --> 00:47:26.433
ก็คือมันชื่อว่า config

00:47:26.500 --> 00:47:28.133
config จะเป็น server ที่เราต้องตั้ง

00:47:28.200 --> 00:47:31.733
ไม่ว่ายังไงเราต้องตั้ง server ไว้ 1 ไว้ 1 set เรียกว่า config

00:47:31.800 --> 00:47:34.833
ดังนั้นเค้าบอกว่ามี config เพิ่มก็มีค่าใช้จ่ายเพิ่ม

00:47:34.900 --> 00:47:40.333
เค้าเลยบอกว่าเราย้าย config ครับ มาอยู่ภายใต้ shard สักเครื่องนึง

00:47:40.400 --> 00:47:44.733
ที่มี performance น้อยลง
แปลว่าแทนที่เราจะต้องสร้างเครื่องคอมพิวเตอร์มา

00:47:44.800 --> 00:47:47.333
มาทำ config server
เราไม่ต้องแล้ว เรารวมมา

00:47:48.300 --> 00:47:54.233
รวมมาอยู่เป็นส่วนหนึ่งของ shard เลยได้เลยนะครับ
เหมาะกับข้อมูลที่มีขนาดอยู่ประมาณไม่เกิน 4TB

00:47:55.400 --> 00:47:59.733
อันนี้ผมสามารถบอกได้เลยนะ ไม่เกิน 4TB นะครับ
ต่อไปนะครับ เรื่อง

00:47:59.800 --> 00:48:03.833
น่าจะสุดท้ายนะครับ ก็คือตัว security

00:48:03.900 --> 00:48:07.633
เพิ่มฟีเจอร์หนึ่ง ปกติแล้วเวอร์ชัน 7 จะมีฟีเจอร์เรื่องการทำ

00:48:07.700 --> 00:48:13.233
OpenID เราสามารถที่จะทำ connect กับ OpenID

00:48:13.300 --> 00:48:16.733
ในการทำ เช่น เราต่อ Azure ID นะ

00:48:16.800 --> 00:48:19.833
สำหรับทำ single sign-on เราสามารถ manage ตรงนั้นได้

00:48:19.900 --> 00:48:22.133
เพื่อเราระบุว่าแอปพลิเคชันเรา base on

00:48:22.200 --> 00:48:24.833
user role อันไหนที่อยู่ใน MongoDB

00:48:24.900 --> 00:48:27.433
เราสามารถ manage ในระดับนั้นได้นะครับ

00:48:27.500 --> 00:48:32.033
เพราะฉะนั้นนี่คือ นี่คือสิ่งที่ เพิ่มความสามารถตรงนั้นลงไปนะครับผม

00:48:32.100 --> 00:48:34.833
ก็คือการทำ workforce หรือ workload นะครับ

00:48:34.900 --> 00:48:39.533
ก่อนหน้านี้เราต้องสร้าง user แบบ one by one ปกตินะ
หรือแม้กระทั่งต่อพวก Azure

00:48:39.600 --> 00:48:41.133
แต่ตอนนี้เราสามารถจะทำแบบ

00:48:41.200 --> 00:48:46.233
link ไปที่พวกตัวที่เป็น OAuth ได้แล้วโดยตรง
หรือพวกที่เป็นตัว service support

00:48:46.300 --> 00:48:49.733
ที่เป็นตัว federation ของ Azure หรือของ GCP ได้นะครับ

00:48:51.600 --> 00:48:56.933
ส่วนนี้ก็คือเรียกว่าการ query
ผมไม่แน่ใจว่าทุกท่าน

00:48:57.000 --> 00:49:01.733
เคยใช้หรือเปล่า ว่าเรามีการ encrypt data ระดับ field ได้

00:49:01.800 --> 00:49:05.933
ซึ่ง encrypt ไม่ใช่เรื่องแปลกนะทุกคน
encrypt database ทุกตัว encrypt ได้

00:49:06.000 --> 00:49:08.433
แต่ encrypt แล้วไม่ต้องแกะ ไม่ต้อง decrypt

00:49:08.500 --> 00:49:13.133
แต่ query ได้
ไม่ decrypt แต่ query ได้

00:49:13.200 --> 00:49:17.733
เบื้องหลังง่ายมากครับ
ก็คือ มันก็คงไม่ง่าย แต่ผมเข้าใจแบบมุมง่ายๆ คือ

00:49:17.800 --> 00:49:21.233
มันใช้วิธีการ เอ่อ ใช้ index ไป compare

00:49:22.400 --> 00:49:26.433
เพราะฉะนั้นเค้าไม่ถอดรหัสนะ
ข้อมูลที่คุณเห็นจะเป็นดาวๆ นะครับ

00:49:26.500 --> 00:49:30.333
ก็คือแสดงผลไม่ได้
นอกจากคุณมี key ไปถอดให้อ่าน

00:49:30.400 --> 00:49:33.433
ดังนั้นไม่มีใครอ่านได้ แต่ query ได้

00:49:34.500 --> 00:49:38.533
เมื่อก่อนมัน query ได้
คือเช่นผมเก็บเลขบัตรประชาชนว่า 1 2 3 นะครับ

00:49:38.600 --> 00:49:40.733
พอผมเข้ารหัสปุ๊บมันจะกลายเป็นดาวๆ ๆ

00:49:40.800 --> 00:49:45.533
ผมต้องการ where ว่าต้องการอ่านข้อมูลที่เป็น ID เท่ากับ 1 2 3 ที

00:49:45.600 --> 00:49:49.333
มันไม่ได้ไปแกะไอ้ดาวๆ ๆ มาเป็น 1 2 3 นะครับ
มันใช้เทคนิค

00:49:49.400 --> 00:49:51.033
อื่นในการจัดการเรื่อง index

00:49:51.100 --> 00:49:54.933
แล้วมันก็ไปค้นแบบ record เนี้ยเป็นเลข 1 2 3 4 มาโชว์ให้เราเห็น

00:49:55.000 --> 00:49:57.133
โดยที่ไม่ต้องถอดรหัสเลย

00:49:57.200 --> 00:49:59.833
เมื่อก่อนมันทำได้แค่ compare แบบเท่ากับ

00:49:59.900 --> 00:50:03.433
ตอนนี้ feature เพิ่มขึ้นก็คือ compare แบบ range ครับ

00:50:03.500 --> 00:50:06.733
ก็คือสามารถทำได้ก็คือมากกว่าน้อยกว่านี่นะครับ

00:50:07.400 --> 00:50:10.833
หรือว่ามากกว่าเท่ากับ หรือว่าน้อยกว่าเท่ากับได้นะครับ

00:50:10.900 --> 00:50:15.133
อันนี้เป็น feature แรกที่ MongoDB ชูเมื่อตอนเป็นเวอร์ชัน 7 เนาะ

00:50:15.200 --> 00:50:15.933
ตอนเวอร์ชัน

00:50:16.000 --> 00:50:20.733
8 ก็เลยเพิ่ม feature ในการทำเรื่อง range นะครับ
อันนี้เราเรียกเป็นตัว

00:50:20.800 --> 00:50:23.733
QE เนาะ ก็คือ queryable encryption นะครับ

00:50:26.100 --> 00:50:29.533
ต่อไปก็คือ เพิ่มมาตรฐานของเรื่อง log format ครับ

00:50:29.600 --> 00:50:33.633
อันนี้ก็เป็นไปตามมาตรฐานนะ
ถ้าใครใช้มาตรฐาน

00:50:33.700 --> 00:50:37.733
open cybersecurity ครับ
format เราสามารถจะเซ็ต

00:50:37.800 --> 00:50:39.533
ให้ log ที่ run ออกมานะครับ

00:50:39.600 --> 00:50:43.633
เข้ามาตรฐานนั้นเพื่อเอาไปใช้งานต่อ หรือไป approve ตามมาตรฐาน

00:50:43.700 --> 00:50:49.733
เพราะว่าเรามีหน่วยงานหลายๆ หน่วยงานที่ต้อง comply ตามมาตรฐานนั่นเองนะครับ

00:50:51.400 --> 00:50:53.633
โอเค นะครับ

00:50:53.700 --> 00:51:01.333
อันนี้ก็คือ สิ่งที่จะเข้ามานะครับ ในเวอร์ชั่น 8 อาจจะเร็วไปนิดนึง

00:51:01.400 --> 00:51:04.633
เพราะ content มันค่อนข้างเยอะมาก จะมีอีกหลายส่วนมากนะครับ

00:51:04.700 --> 00:51:08.333
ก็จะประมาณนี้นะครับผม มีคำถามไหมครับ

00:51:12.800 --> 00:51:15.933
ทำเวลามาก เนื้อหาหนักมากครับ
