WEBVTT

00:00:01.300 --> 00:00:05.532
สวัสดีครับทุกคน วันนี้ผมจะมาพูดถึง

00:00:05.600 --> 00:00:09.833
การใช้ PostgreSQL checkpointer แบบกำหนดเองด้วย LangGraph

00:00:09.900 --> 00:00:13.033
มันอาจจะฟังดูซับซ้อนหน่อย แต่ผมจะพยายามอธิบาย

00:00:13.100 --> 00:00:16.332
ให้เข้าใจง่ายๆ ว่ามันทำงานยังไง

00:00:16.400 --> 00:00:21.333
และวิธีการบันทึกข้อมูลในแอปพลิเคชัน AI ไปสไลด์ต่อไปได้เลยครับ

00:00:21.400 --> 00:00:25.233
ผมชื่อวิล เป็นผู้ก่อตั้ง Reacthor

00:00:25.300 --> 00:00:30.233
เราช่วยบริษัทต่างๆ สร้าง AI workflows ในเอเชียตะวันออกเฉียงใต้

00:00:30.300 --> 00:00:36.133
และในสหรัฐอเมริกา ปัจจุบันเรามีลูกค้า

00:00:36.200 --> 00:00:39.233
สองรายในเอเชียตะวันออกเฉียงใต้ และหนึ่งรายในสหราชอาณาจักร

00:00:39.300 --> 00:00:43.433
ผมจะเล่าให้ฟังเพิ่มเติมเกี่ยวกับการ deploy แอป

00:00:44.300 --> 00:00:48.233
การสร้างแอปพลิเคชันของคุณเอง โดยเฉพาะใน production

00:00:48.300 --> 00:00:51.633
ที่ใช้ AI ในภายหลัง แต่ก่อนอื่นเราจะมาพูดถึง

00:00:51.700 --> 00:00:54.533
วิธีการทำงานของ LangChain กันก่อน

00:00:54.600 --> 00:01:00.333
ก่อนที่ผมจะเริ่ม มีใครเคยใช้ LangChain ใน production บ้างไหมครับ

00:01:00.400 --> 00:01:07.433
แค่ทดสอบ หรือ LangChain? ไม่มี ไม่เคยเลย โอเค เยี่ยมมาก

00:01:08.200 --> 00:01:12.433
ไปสไลด์ต่อไปได้เลยครับ เรื่องแรกคือ

00:01:12.500 --> 00:01:19.133
พวกเขาใช้ SDK จาก OpenAI เพื่อ

00:01:19.200 --> 00:01:23.333
เรียกใช้งาน LLM และ

00:01:23.400 --> 00:01:26.833
พวกเขามี prompt ที่เฉพาะเจาะจง, มี LLM,

00:01:26.900 --> 00:01:30.933
และได้ output ออกมา
ซึ่งความแตกต่างระหว่าง

00:01:31.000 --> 00:01:34.233
การใช้ SDK กับการใช้ LangChain คือ

00:01:34.300 --> 00:01:36.933
คุณมี components หลายประเภทที่สามารถใช้เป็นเครื่องมือได้

00:01:37.000 --> 00:01:40.133
ตัวอย่างเช่น คุณสามารถใช้ tools ที่

00:01:40.200 --> 00:01:45.133
มีคนสร้างไว้แล้ว เช่น การค้นหาบนเว็บ คุณสามารถใช้ tools เพื่อ

00:01:45.200 --> 00:01:47.733
หาข้อมูลที่ทันเหตุการณ์

00:01:47.800 --> 00:01:52.733
เช่นสภาพอากาศ หรือคุณสามารถสร้าง tools เองสำหรับการคำนวณ

00:01:52.800 --> 00:01:55.833
ผมจะอธิบายรายละเอียดเพิ่มเติมเกี่ยวกับประเภทของ tools ที่คุณสามารถ

00:01:55.900 --> 00:02:01.433
ใช้ใน production ได้ แต่คุณยังสามารถใช้เทคนิค RAG สำหรับ

00:02:01.500 --> 00:02:05.833
การดึงข้อมูล และคุณยังสามารถ

00:02:05.900 --> 00:02:09.333
ใช้ประวัติการแชทของคุณเมื่อคุณกำลังโต้ตอบ

00:02:09.400 --> 00:02:12.533
กับแอป LLM ของคุณ

00:02:12.600 --> 00:02:17.632
ตัวอย่างเช่น หลายครั้งที่คุณใช้ SDK

00:02:17.700 --> 00:02:23.233
มันไม่มีความสามารถในการบันทึกความจำได้ ดังนั้น LangChain จึงมีความสามารถ

00:02:23.300 --> 00:02:28.533
ในการบันทึก memory ของคุณและดึงข้อมูลจากมัน

00:02:28.600 --> 00:02:33.533
มีใครเคยใช้ LangGraph บ้างไหมครับ? ไม่มี โอเค

00:02:33.600 --> 00:02:35.833
แน่นอน ถ้าคุณไม่เคยใช้ LangChain คุณก็คง

00:02:35.900 --> 00:02:40.333
ไม่เคยใช้ LangGraph ไปสไลด์ต่อไปได้เลยครับ

00:02:40.400 --> 00:02:44.132
LangGraph คืออะไร LangGraph ถูกสร้างขึ้นโดย

00:02:44.200 --> 00:02:47.933
ทีม LangChain และมันอิงจาก Pregel ซึ่ง

00:02:48.000 --> 00:02:52.233
ถูกสร้างขึ้นโดย Google เดิมที Pregel ถูกสร้างขึ้นเพื่อ rerank

00:02:52.300 --> 00:02:54.733
ดังนั้นโดยปกติเมื่อคุณจัดอันดับเว็บไซต์ใหม่

00:02:54.800 --> 00:02:59.933
และคุณกำลังประมวลผล request แบบ batch ดังนั้นมันถูกสร้างขึ้นเพื่อสร้าง

00:03:00.000 --> 00:03:02.733
graph database เพื่อให้คุณสามารถดึงข้อมูล

00:03:02.800 --> 00:03:04.733
และส่งผ่านข้อมูลได้อย่างรวดเร็ว

00:03:05.400 --> 00:03:10.733
LangGraph ทำงานโดยมี graph

00:03:10.800 --> 00:03:14.132
มี node หลัก นี่เป็นเพียงตัวอย่าง

00:03:14.200 --> 00:03:17.333
และมี tools เช่น คุณสามารถค้นหา

00:03:17.400 --> 00:03:20.933
โรงแรม หาราคาที่ดีที่สุด

00:03:21.000 --> 00:03:25.632
ถ้าคุณเป็นพนักงาน Agoda

00:03:25.700 --> 00:03:28.533
คุณน่าจะรู้จักสิ่งนี้ และคุณสามารถยืนยันการเลือกโรงแรม

00:03:28.600 --> 00:03:31.933
และส่งลิงก์การชำระเงิน จากนั้นก็มี state

00:03:32.000 --> 00:03:36.933
ผมเดาว่าพวกคุณส่วนใหญ่ใช้ JavaScript ใช่ไหม? โอเค เยี่ยม

00:03:37.000 --> 00:03:40.733
พวกคุณใช้ React เยี่ยมมาก การจัดการ state เยี่ยม

00:03:40.800 --> 00:03:44.333
นั่นคือ state ของคุณ และสิ่งที่คุณทำได้คือ

00:03:44.400 --> 00:03:48.933
บันทึกข้อความ เพิ่มข้อความ และมีตัวเลือกโรงแรม

00:03:49.000 --> 00:03:53.632
และประวัติการจองของคุณอยู่ตรงนั้น เลื่อนลงมาหน่อยครับ

00:03:53.700 --> 00:03:57.033
ตัวอย่างเช่น สำหรับ travel agent

00:03:57.100 --> 00:04:00.733
ที่เรากำลังสร้างอยู่ในตอนนี้ หนึ่งในข้อกำหนดคือ

00:04:00.800 --> 00:04:03.833
เราต้องการหาราคาที่ดีที่สุด และเราต้องการให้สามารถจอง

00:04:03.900 --> 00:04:06.933
travel agent ของคุณได้โดยตรงในแอป

00:04:07.000 --> 00:04:10.533
หลายครั้งที่คุณใช้ ChatGPT

00:04:10.600 --> 00:04:13.533
เบื้องหลังมันใช้หลายสิ่งหลายอย่าง

00:04:13.600 --> 00:04:17.132
เช่นสถาปัตยกรรมที่คุณอาจไม่คุ้นเคย

00:04:17.200 --> 00:04:19.832
เราจะลงรายละเอียดเกี่ยวกับสถาปัตยกรรมที่คุณสามารถ

00:04:19.899 --> 00:04:24.832
ใช้เมื่อคุณสร้างแอป AI

00:04:24.900 --> 00:04:27.733
ในภายหลัง แต่สถาปัตยกรรมนี้เรียกว่า

00:04:27.800 --> 00:04:30.933
supervisor architecture โดยพื้นฐานแล้วคุณมี

00:04:31.000 --> 00:04:34.033
คำถาม มันเรียกใช้ travel node จากนั้นคุณมี router

00:04:34.100 --> 00:04:37.533
ซึ่งเป็น conditional node มันจะทำ

00:04:37.600 --> 00:04:42.133
sentiment analysis ว่านี่เป็นคำถาม

00:04:42.200 --> 00:04:46.933
เกี่ยวกับการหาโรงแรมหรือไม่ และถ้าใช่

00:04:47.000 --> 00:04:50.233
มันจะไปยัง node ถัดไป และมันจะ

00:04:50.300 --> 00:04:56.733
เรียกใช้คำสั่ง search hotel จากนั้นก็ find the best prices

00:04:56.800 --> 00:04:58.733
และเรามี interrupt

00:04:58.800 --> 00:05:02.133
interrupt คือเมื่อผู้ใช้ตัดสินใจว่า

00:05:02.200 --> 00:05:05.733
พวกเขาต้องการเลือกโรงแรมนั้นหรือไม่

00:05:05.800 --> 00:05:09.033
โรงแรมที่สอง หรือโรงแรมที่สี่ โรงแรมใดก็ได้ที่พวกเขาต้องการ

00:05:09.100 --> 00:05:13.633
และเมื่อผู้ใช้เลือกแล้ว

00:05:13.700 --> 00:05:16.533
เราสามารถยืนยันการเลือกโรงแรม และเราอัปเดต state

00:05:16.600 --> 00:05:20.933
โดยตรง จากนั้นเราใช้

00:05:21.000 --> 00:05:23.733
conditional router เพื่ออัปเดตตัวเลือก

00:05:23.800 --> 00:05:28.332
และเราสามารถส่งลิงก์การชำระเงิน ซึ่งเป็น tool อีกตัวหนึ่ง

00:05:28.400 --> 00:05:32.832
คุณสามารถนึกถึงชุดเครื่องมือของคุณ และคุณมี travel agent

00:05:32.900 --> 00:05:36.433
ซึ่งเป็น node ที่เชื่อมต่อกับมัน

00:05:36.500 --> 00:05:41.332
ดังนั้น LLM ของคุณมีตัวช่วยที่มันสามารถ

00:05:41.400 --> 00:05:45.832
ดึงข้อมูลหรือค้นหาเพื่อช่วย

00:05:45.900 --> 00:05:48.033
มันได้ ผมคิดว่าความแตกต่างหลัก

00:05:48.100 --> 00:05:51.733
คือเมื่อคุณสร้างแอปพลิเคชันมาตรฐาน เช่น ที่ Agoda

00:05:51.800 --> 00:05:55.733
คุณกำลังสร้างระบบการค้นหา แอปพลิเคชัน

00:05:55.800 --> 00:05:58.733
ที่เราเห็นก่อนหน้านี้ มันคือ CRUD ใช่ไหม

00:05:58.800 --> 00:06:02.332
สร้าง อ่าน อัปเดต ลบ มันแตกต่างกันเล็กน้อยเพราะ

00:06:02.400 --> 00:06:06.033
คุณกำลังให้พลังแก่ LLM ในการ

00:06:06.100 --> 00:06:10.233
ตัดสินใจดึงข้อมูลหรือใช้ tool ที่มันต้องการ

00:06:10.300 --> 00:06:12.832
ดังนั้นมันจึงเป็นการเปลี่ยนแปลงวิธีคิดของคุณ

00:06:12.900 --> 00:06:16.033
ในแง่ของการคิด ถ้าคุณกำลังคิดถึง

00:06:16.100 --> 00:06:21.033
การเขียนโปรแกรมแบบ declarative และ imperative ทั่วไป ซึ่งคุณมีเงื่อนไขต่างๆ

00:06:21.100 --> 00:06:25.233
ที่คุณต้องกำหนดเงื่อนไขเองทั้งหมด แต่ที่นี่คุณมี

00:06:25.300 --> 00:06:29.933
รายการกฎต่างๆ และ LLM ต้องตัดสินใจว่าจะใช้ tools ไหน

00:06:30.000 --> 00:06:33.533
หรือไม่ใช้ tools เหล่านั้นเลย — เลื่อนลงมาหน่อยครับ

00:06:33.600 --> 00:06:35.832
ผมไม่รู้ว่าพวกคุณเห็นไหม

00:06:35.900 --> 00:06:38.633
ลองคลิกดูได้ไหม

00:06:39.900 --> 00:06:44.733
มันเล็กมาก คุณน่าจะคลิกได้ โอเค

00:06:44.800 --> 00:06:48.033
นี่คือวิธีการทำงาน คุณมี state

00:06:48.100 --> 00:06:51.133
อยู่ด้านบน checkpointer ซึ่งเราจะพูดถึงในภายหลัง

00:06:51.200 --> 00:06:56.233
ซึ่งเป็น Postgres saver และหลังจากนั้นคุณ

00:06:56.300 --> 00:06:59.233
initialize state ของคุณ และคุณมี travel agent

00:06:59.300 --> 00:07:01.633
นี่คือที่ที่คุณควบคุม state

00:07:01.700 --> 00:07:04.933
และโดยทั่วไปภายในนั้นคุณจะมีสิ่งต่างๆ เช่น

00:07:05.000 --> 00:07:09.832
tools ของคุณ และการเรียกใช้ graph

00:07:09.900 --> 00:07:13.133
ผมไม่มีรูปภาพตรงนั้น แต่ถ้าพวกคุณ

00:07:13.200 --> 00:07:15.933
อยากคุยกับผมเพิ่มเติม ผมยินดีที่จะ

00:07:16.000 --> 00:07:18.033
โชว์โค้ดให้ดู และนี่คือที่ที่คุณ

00:07:18.100 --> 00:07:21.033
เรียกใช้งาน นี่คือภาษา Python ขออภัยถ้าคุณ

00:07:21.100 --> 00:07:32.133
เป็นนักพัฒนา JavaScript แต่ Python ดีกว่ามาก

00:07:32.800 --> 00:07:36.033
ใช่ มันง่ายกว่ามาก

00:07:36.100 --> 00:07:40.233
และประสิทธิภาพก็ดีกว่า นี่คือ endpoint เดียว

00:07:40.300 --> 00:07:44.733
ที่คุณสามารถเรียกใช้ได้ และมันจะหาราคาที่ดีที่สุด

00:07:44.800 --> 00:07:51.733
และข้อมูลอื่นๆ — ซูมออกได้ครับ

00:07:51.800 --> 00:07:54.633
เรามาดูกันว่า checkpointer คืออะไร

00:07:54.700 --> 00:08:00.533
โดยพื้นฐานแล้ว checkpointer คือที่ที่คุณสามารถจัดเก็บ

00:08:00.600 --> 00:08:03.832
state ใน graph และความแตกต่างระหว่างการบันทึก

00:08:03.900 --> 00:08:08.733
ข้อมูลใน database ทั่วไป อย่างที่ผมได้กล่าวไปคือ

00:08:08.800 --> 00:08:14.133
คุณกำลังทำในระดับพื้นฐาน CRUD ใช่ไหม? สำหรับ checkpointer

00:08:14.200 --> 00:08:18.332
มันแตกต่างกันเล็กน้อยตรงที่คุณมี connection

00:08:18.400 --> 00:08:22.033
ซึ่งก็คือ PostgreSQL URL ของคุณ มันอาจจะเป็น URL

00:08:22.100 --> 00:08:26.332
ที่คุณใช้บน Supabase

00:08:26.400 --> 00:08:29.133
และคุณมี concurrency ซึ่งก็คือ pipeline ของคุณ

00:08:29.200 --> 00:08:33.933
pipeline concurrency คือที่ที่มัน

00:08:34.000 --> 00:08:40.033
set up database ที่ซึ่งมันสร้างตาราง

00:08:40.100 --> 00:08:44.232
และถ้ามันถูกเปิดใช้งาน นี่คือส่วนที่

00:08:44.300 --> 00:08:46.833
แตกต่างจาก CRUD

00:08:46.900 --> 00:08:51.433
คือมันจะรวมคำสั่ง SQL

00:08:52.100 --> 00:08:58.433
เช่น put, tuple list, และ writes

00:08:58.500 --> 00:09:03.333
ดังนั้นมันจึงแตกต่างกันเล็กน้อยตรงที่ทุกครั้งที่เรียกใช้

00:09:03.400 --> 00:09:07.033
LLM หรือ chain ของคุณ มันจะ

00:09:07.100 --> 00:09:10.233
รวม request บางอย่างเข้าด้วยกัน และผมจะแสดงให้คุณเห็นว่ามันทำงานอย่างไร

00:09:10.300 --> 00:09:14.433
เลื่อนลงมา โอเค กลับไปที่ตัวอย่างของเรา

00:09:14.500 --> 00:09:18.533
เรามี travel agent node ถ้าคุณ

00:09:18.600 --> 00:09:21.433
เลื่อนขึ้นไปนิดหน่อย

00:09:21.500 --> 00:09:24.333
นี่คือคำถาม

00:09:24.400 --> 00:09:29.233
และตรงนี้ ถ้าคุณจำที่ผมพูดถึง

00:09:29.300 --> 00:09:32.733
Checkpointer ได้ ทุก checkpointer มี thread

00:09:32.800 --> 00:09:36.733
และ thread นั้นจะถูกบันทึก คุณสามารถคิดว่านี่เป็นเหมือน

00:09:36.800 --> 00:09:40.833
ประวัติข้อความของคุณที่บันทึกไว้กับ agent state

00:09:40.900 --> 00:09:45.133
นี่คือที่ที่มันถูกบันทึกไว้ และทุกครั้งที่คุณ

00:09:45.200 --> 00:09:48.033
ส่งคำถาม สมมติว่าคุณต้องการค้นหา

00:09:48.100 --> 00:09:51.133
การจองที่ไหนสักแห่ง มันจะดึงเวอร์ชันปัจจุบัน

00:09:51.200 --> 00:09:55.833
ของ graph state ดังนั้นมันจะรัน batch สำหรับ aget

00:09:55.900 --> 00:10:00.433
และถ้าคุณซูมออก คุณจะมี conditional node ว่า

00:10:00.500 --> 00:10:03.933
มันกำลังค้นหาโรงแรมหรือไม่ และเมื่อคุณไปถึงจุดที่ผู้ใช้

00:10:04.000 --> 00:10:08.133
ที่กำลังเลือกโรงแรม ซึ่งก็คือโรงแรมที่หนึ่ง นี่คือที่ที่เรา

00:10:08.200 --> 00:10:12.633
รวมการดำเนินการเช่น aget และ aput ที่ซึ่งคุณต้องดึงเวอร์ชันปัจจุบันของ state

00:10:12.700 --> 00:10:17.833
และจากนั้นคุณอัปเดต

00:10:17.900 --> 00:10:22.533
ตัวเลือกโรงแรม โรงแรมที่หนึ่ง และนี่คือที่ที่คุณ

00:10:22.600 --> 00:10:26.233
อัปเดต state และในที่สุด

00:10:26.300 --> 00:10:30.333
ผู้ใช้อนุมัติ และคุณได้รับคำตอบโดยตรงถึงผู้ใช้

00:10:30.400 --> 00:10:35.333
สมมติว่าคุณกำลังใช้ SDK จาก OpenAI หรือ Vertex

00:10:35.400 --> 00:10:38.433
การสร้างแอปพลิเคชันแบบนี้อาจ

00:10:38.500 --> 00:10:43.533
ยากสักหน่อย เพราะคุณไม่มี control flow เมื่อ

00:10:43.600 --> 00:10:47.233
คุณใช้ SDK เดียว ดังนั้น LangChain จึงช่วยให้คุณ

00:10:47.300 --> 00:10:51.133
สามารถออกแบบ workflow ให้ AI แอปของคุณ

00:10:51.200 --> 00:10:55.533
ในแบบที่คุณมี human in the loop

00:10:56.600 --> 00:10:58.033
โอเค

00:10:58.100 --> 00:11:03.033
นี่คือวิธีที่ checkpointer บันทึกข้อมูลไว้ภายใน Postgres

00:11:03.100 --> 00:11:05.733
คุณมี thread ID อีกครั้งอย่างที่ผมได้กล่าวไป

00:11:06.300 --> 00:11:10.933
และแต่ละ thread แสดงถึงเวอร์ชันของ state

00:11:11.000 --> 00:11:16.033
และสิ่งหนึ่งที่ผมลืมพูดถึงคือ สมมติว่าคุณอยู่ที่

00:11:16.100 --> 00:11:20.233
เวอร์ชันสามของ graph state ทุก thread มี

00:11:20.300 --> 00:11:25.533
parent_ts ซึ่งอ้างอิงถึง state ก่อนหน้าของ

00:11:25.600 --> 00:11:31.133
parent และ child และ timestamp

00:11:31.200 --> 00:11:36.133
ซึ่งไม่ได้อยู่ในนั้น โอเค เราไปต่อได้

00:11:36.200 --> 00:11:38.933
ผมจะยกตัวอย่างในโลกจริง

00:11:39.000 --> 00:11:41.433
เรากำลังทำงานกับ Salary Hero อยู่ในขณะนี้

00:11:41.500 --> 00:11:47.133
พวกเขามีปัญหาที่พวกเขากำลังเติบโตประมาณ 20% ทุกเดือนต่อ

00:11:47.200 --> 00:11:50.133
บริษัทที่พวกเขากำลังทำงานด้วย

00:11:50.200 --> 00:11:57.033
และพวกเขามีพนักงานประมาณหนึ่งพันคน

00:11:57.100 --> 00:12:02.233
ที่เข้ามาและโต้ตอบกับแอป และพวกเขาต้องการความช่วยเหลือมาก

00:12:02.300 --> 00:12:06.633
หมายถึง พวกเขาต้องการข้อมูลเกี่ยวกับสินเชื่อ พวกเขาต้องการดึง

00:12:06.700 --> 00:12:10.233
ข้อมูลเกี่ยวกับว่าพวกเขาสามารถ

00:12:10.300 --> 00:12:14.433
กู้เงินเดือนนี้หรือเดือนหน้าได้หรือไม่ และพวกเขากำลังได้รับประมาณ

00:12:14.500 --> 00:12:18.933
สมมติว่า 800 คำขอต่อวัน และพวกเขามีเพียงห้าคน

00:12:19.000 --> 00:12:21.533
ฝ่ายสนับสนุนลูกค้าห้าคน

00:12:21.600 --> 00:12:26.033
และพวกเขาสามารถตอบกลับได้เพียง

00:12:26.100 --> 00:12:29.733
300 ข้อความต่อวัน ดังนั้นพวกเขาจึงถูกจำกัด

00:12:29.800 --> 00:12:31.833
ในสภาพแวดล้อมนั้น ดังนั้นพวกเขาจึงพยายามไปที่

00:12:31.900 --> 00:12:34.533
ผู้ขายรายอื่น แต่พวกเขาไม่สามารถ

00:12:34.600 --> 00:12:38.333
สร้างโซลูชันแบบกำหนดเองได้ เพราะข้อมูลของพวกเขา

00:12:38.400 --> 00:12:43.733
กระจัดกระจายไปทั่ว พวกเขามีข้อมูลใน Excel

00:12:43.800 --> 00:12:47.033
ข้อมูลใน Google Sheets แทบทุกที่

00:12:47.100 --> 00:12:53.233
ดังนั้นโดยพื้นฐานแล้ว เราเข้ามาและสิ่งแรกที่เราทำคือสร้าง

00:12:53.300 --> 00:12:57.433
แบบจำลองกราฟแบบนี้ เพื่อ

00:12:57.500 --> 00:13:01.633
แสดงสถานะต่างๆ ของ flow

00:13:02.200 --> 00:13:04.433
นี่เป็นเพียงส่วนหนึ่ง ผมจะไม่แสดงทั้งหมด

00:13:04.500 --> 00:13:09.633
แต่คุณสามารถนึกภาพผู้ใช้เข้ามาพร้อมกับคำถาม

00:13:09.700 --> 00:13:12.333
พร้อมกับ sentiment analysis ก่อนที่ผมจะอธิบาย

00:13:12.400 --> 00:13:15.533
ปัญหาส่วนหนึ่งที่พวกเขามีคือ

00:13:15.600 --> 00:13:19.333
ผู้ใช้ของพวกเขาออนไลน์ ดังนั้นเราต้องระบุตัวตน

00:13:19.400 --> 00:13:24.033
ผู้ใช้ สิ่งหนึ่งคือสิ่งที่พวกเขา

00:13:24.100 --> 00:13:28.233
ทำด้วยตนเองคือ พวกเขาโต้ตอบกับลูกค้าโดยตรง

00:13:28.300 --> 00:13:32.133
และพยายามหาว่าเป็นใคร ค้นหาใน database ว่าเป็นใคร

00:13:32.200 --> 00:13:36.633
บริษัทไหน ลำดับความสำคัญหนึ่ง

00:13:36.700 --> 00:13:39.633
แล้วพวกเขาก็ตอบกลับผู้ใช้

00:13:39.700 --> 00:13:44.333
เราลบขั้นตอนทั้งหมดนั้น

00:13:44.400 --> 00:13:47.033
ที่มนุษย์ทำ สิ่งแรกที่เราทำคือ

00:13:47.100 --> 00:13:50.233
ทักทายผู้ใช้ หลังจากทักทายผู้ใช้

00:13:50.300 --> 00:13:52.733
เราอัปเดต state ว่า greeting = true

00:13:52.800 --> 00:13:56.433
หลังจากนั้น เราจะยืนยันตัวตนผู้ใช้

00:13:56.500 --> 00:13:58.933
นี่คือที่ที่ LLM ทำงาน

00:13:59.000 --> 00:14:03.733
เรียกใช้คำสั่ง authentication เพื่อให้ผู้ใช้สามารถเข้าสู่ระบบได้

00:14:03.800 --> 00:14:07.833
เมื่อผู้ใช้เข้าสู่ระบบแล้ว เราบันทึกไว้ใน state และ

00:14:07.900 --> 00:14:12.433
เปลี่ยนเส้นทางพวกเขาตามลำดับความสำคัญ ดังนั้นจึงถูกเปลี่ยนเส้นทางไปยังฝ่ายสนับสนุนลูกค้า

00:14:12.500 --> 00:14:16.333
LLM ที่สามารถ

00:14:16.400 --> 00:14:20.133
ให้ข้อมูลแก่ผู้ใช้ สิ่งหนึ่งเมื่อพวกเขา

00:14:20.200 --> 00:14:24.533
ถูกเปลี่ยนเส้นทางมาที่นี่ — ผมไม่แน่ใจว่าพวกคุณคุ้นเคย

00:14:24.600 --> 00:14:28.333
กับคำว่า crews หรือไม่ — โดยพื้นฐานแล้วคุณมี master

00:14:28.400 --> 00:14:31.733
agent ถ้าคุณเลื่อนขึ้นไปด้านบน

00:14:31.800 --> 00:14:35.733
คุณกำหนดว่าคำถามคืออะไร

00:14:35.800 --> 00:14:39.433
และคุณมี master agent และ master agent นั้น

00:14:39.500 --> 00:14:43.033
สามารถส่งต่อข้อมูลนั้น

00:14:43.100 --> 00:14:46.333
ส่งต่อไปยัง agent ที่ถูกต้อง เช่น นโยบายบริษัท ข้อมูลทั่วไป

00:14:46.400 --> 00:14:51.433
การขอสินเชื่อ การชะลอการชำระเงิน และ master agent นั้นมี tools

00:14:51.500 --> 00:14:54.833
ถ้าคุณจำได้ tools เหล่านั้นมี

00:14:54.900 --> 00:14:58.633
กรณีการใช้งานที่แตกต่างกัน tools จะดึง

00:14:58.700 --> 00:15:02.133
ข้อมูลจาก Google ดึงข้อมูลจาก

00:15:02.200 --> 00:15:05.533
sheets พวกเขาทำการปรับแต่งมากมาย

00:15:05.600 --> 00:15:09.933
เพื่อตอบกลับผู้ใช้ เช่น การชะลอการชำระเงิน

00:15:10.000 --> 00:15:13.533
พวกเขาได้รับคำขอชะลอการชำระเงินจำนวนมาก

00:15:13.600 --> 00:15:16.733
สิ่งที่เราทำคือ เราสังเกตเห็นว่า มีการชะลอการชำระเงิน

00:15:16.800 --> 00:15:22.033
จากนั้นเราเรียกใช้ tool ที่ตอบกลับและส่ง

00:15:22.100 --> 00:15:25.433
อีเมลไปยังทีมสนับสนุนลูกค้าว่า มีผู้ใช้ประมาณ 800 คน

00:15:25.500 --> 00:15:29.733
ที่กำลังขอ

00:15:29.800 --> 00:15:34.233
ชะลอการชำระเงิน ดังนั้นเราต้อง

00:15:34.300 --> 00:15:37.533
ดูแลเรื่องนี้ นี่เป็นวิธีที่แตกต่างกัน

00:15:37.600 --> 00:15:41.633
ที่คุณสามารถออกแบบได้ — ถ้าคุณเลื่อนลงไปอีกหน่อย

00:15:41.700 --> 00:15:47.933
และออกจากตรงนี้ — เพื่อให้คุณ

00:15:48.000 --> 00:15:51.233
เข้าใจวิธีการสร้างแอปพลิเคชันประเภทนี้

00:15:51.300 --> 00:15:55.233
คุณสามารถไปที่ langchain.com

00:15:55.300 --> 00:15:59.533
แต่เมื่อคุณไปถึง LangGraph มันอาจจะซับซ้อนขึ้นเล็กน้อย

00:15:59.600 --> 00:16:03.433
ดังนั้นผมขอแนะนำให้อ่านเอกสาร

00:16:03.500 --> 00:16:06.933
อย่างละเอียดเพื่อทำความเข้าใจ แต่ส่วนแรกที่ผม

00:16:07.000 --> 00:16:09.933
กล่าวถึง เมื่อนี่คือกรณีการใช้งานสำหรับ Salary Hero

00:16:11.400 --> 00:16:14.333
บริษัทที่เรากำลังทำงานด้วยคือ เราทักทายผู้ใช้ก่อน

00:16:14.400 --> 00:16:19.333
นี่คือ LLM เดี่ยวที่ไม่มี tools เลย เพียงแค่ทักทายผู้ใช้

00:16:19.400 --> 00:16:23.733
สถาปัตยกรรมที่สองเรียกว่า basic supervisor agent

00:16:23.800 --> 00:16:29.333
ซึ่งมี supervisor และ tools ที่สามารถใช้พูดคุยกับ

00:16:29.400 --> 00:16:34.933
ผู้ใช้และยืนยันตัวตนผู้ใช้ และคุณมี crews

00:16:35.000 --> 00:16:38.833
คุณสามารถนึกถึง crews ได้ สมมติว่าเป็นครู

00:16:38.900 --> 00:16:42.933
และคุณมีผู้ช่วยเกี่ยวกับเรื่องต่างๆ

00:16:43.000 --> 00:16:46.333
คนหนึ่งเปลี่ยนผ้าอ้อมนักเรียน อีกคน

00:16:46.400 --> 00:16:49.833
สอนนักเรียนและช่วยเหลือนักเรียน

00:16:49.900 --> 00:16:53.133
ครูสามารถเรียกใช้ tools ต่างๆ คนต่างๆ

00:16:53.200 --> 00:16:57.933
ที่มีในชุดเครื่องมือ เพื่อดึงข้อมูล

00:16:58.000 --> 00:17:00.533
หรือให้ข้อมูล นี่เป็นสิ่งเดียวกันเมื่อ

00:17:00.600 --> 00:17:03.733
คุณมีทีม crew แบบลำดับชั้น แต่ในกรณีนั้น

00:17:03.800 --> 00:17:08.233
จะเป็นครูใหญ่ที่ทำสิ่งนั้น และนี่เป็นบทความที่ดีที่ควรอ่าน

00:17:08.300 --> 00:17:11.633
ถ้าคุณไม่เคยสร้างระบบประเภทนี้มาก่อน

00:17:11.700 --> 00:17:13.933
คุณจะไม่เข้าใจมัน ผมไม่เข้าใจอะไรเลย

00:17:14.000 --> 00:17:17.933
ผมแค่ใส่ลงใน ChatGPT และให้มันอธิบายสิ่งนี้ให้

00:17:18.000 --> 00:17:21.032
แต่มันเยี่ยมมาก มันทำให้คุณ

00:17:21.099 --> 00:17:23.633
มีมุมมองเกี่ยวกับวิธีการสร้าง

00:17:23.700 --> 00:17:28.433
ระบบ multi-agent เหล่านี้ ทุกครั้งที่ผมพูดถึง

00:17:28.500 --> 00:17:31.233
การสร้าง customer support agent

00:17:31.300 --> 00:17:36.133
มันอาจจะดูง่าย แต่ส่วนที่ยากที่สุดคือ

00:17:36.200 --> 00:17:40.233
ข้อมูลกระจัดกระจายไปทั่ว ขึ้นอยู่กับองค์กร

00:17:40.300 --> 00:17:44.133
และการสร้างเครื่องมือเฉพาะสำหรับลูกค้า คือสิ่งที่พวกเขากำลังมองหา

00:17:47.900 --> 00:17:53.133
ขอบคุณครับ
Reacthor เราอยู่บน LinkedIn

00:17:53.200 --> 00:17:56.133
นี่คืออีเมลของผม ถ้าคุณต้องการติดต่อ

00:17:56.200 --> 00:17:59.033
ถ้าคุณต้องการพูดคุยเพิ่มเติมเกี่ยวกับสิ่งที่ผม

00:17:59.100 --> 00:18:02.133
พูดถึงในระหว่างการพูดคุยนี้ ยินดีครับ ถ้าคุณต้องการให้ผมแสดง

00:18:02.200 --> 00:18:06.033
ตัวอย่างแอปพลิเคชันที่ผมกำลังสร้างอยู่กับบริษัทต่างๆ

00:18:06.100 --> 00:18:09.933
ยินดีครับ และถ้าคุณ

00:18:10.000 --> 00:18:12.433
ต้องการพูดคุย ผมอยู่ที่นี่

00:18:12.500 --> 00:18:13.233
ขอบคุณครับ
