WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:45.079 --> 00:00:47.237
Okay, ladies and gentlemen, let me tell you a little bit

00:00:47.320 --> 00:00:50.760
after this section, for this section, our speaker,

00:00:51.399 --> 00:00:54.799
he has his own mission, so he's not present here today with us.

00:00:55.399 --> 00:00:58.996
Anyway, we will use the technology for everyone of you

00:00:59.079 --> 00:01:04.080
that he's going to do the live skype from India

00:01:04.280 --> 00:01:07.600
to over us, over here at the javascript bangkok.

00:01:07.960 --> 00:01:10.280
So right now we're setting up the system a little bit.

00:01:10.799 --> 00:01:13.600
So let me tell you a little bit about our hashtag

00:01:13.720 --> 00:01:15.880
for this event, which is jsbangkok.

00:01:17.280 --> 00:01:19.239
All the photos in our event, please,

00:01:19.400 --> 00:01:21.480
once you post it on your social network,

00:01:21.640 --> 00:01:24.679
do not forget to hashtag to jsbangkok.

00:01:25.040 --> 00:01:27.877
And for more information, update, any information

00:01:27.960 --> 00:01:30.517
about our events, our next event, our promotions

00:01:30.600 --> 00:01:33.117
or something like that, please do not forget

00:01:33.200 --> 00:01:37.396
to add our line, line application,

00:01:37.479 --> 00:01:41.079
which is @jsbangkok, the same one,

00:01:42.320 --> 00:01:44.005
@, just add the @ sign in the front, @jsbangkok.

00:03:34.224 --> 00:03:36.840
I'd like to say thank you so much for all the sponsors.

00:03:37.200 --> 00:03:41.397
Without them, this event would never happen in Thailand,

00:03:41.480 --> 00:03:44.317
in Bangkok, for a JavaScript Bangkok over here.

00:03:44.400 --> 00:03:48.997
The first one is KBTG, beyond tech capabilities,

00:03:49.080 --> 00:03:52.960
OOZOU, Bangkok's best digital agency,

00:03:53.400 --> 00:03:56.276
ExxonMobil Limited, we are ExxonMobil,

00:03:56.359 --> 00:04:01.519
ODDS, AppMan, the number one insurance digital partner.

00:04:01.799 --> 00:04:03.716
We have expanded to three countries

00:04:03.799 --> 00:04:05.840
and more to come in the future.

00:04:06.239 --> 00:04:12.040
NEXMO, Event Pop, Next Hop, HotNow, Nextzy,

00:04:12.439 --> 00:04:16.237
Skooldio, Thailand's leading tech school,

00:04:16.320 --> 00:04:17.716
and Seven Peaks Software,

00:04:17.799 --> 00:04:26.157
international software and design agency in Bangkok.

00:04:26.680 --> 00:04:29.837
Thank you for all the sponsors for your great support.

00:04:29.920 --> 00:04:34.126
Alright, now we are ready for the next topic.

00:04:34.210 --> 00:04:36.436
It will be an introduction to writing codemods.

00:04:36.520 --> 00:04:39.076
Why they are good, and what techniques are there.

00:04:39.159 --> 00:04:42.046
The speaker will share some great experiences with us.

00:04:42.129 --> 00:04:44.356
Let's listen together.

00:04:44.439 --> 00:04:46.969
With the topic "The Art of Crafting Codemods".

00:04:47.053 --> 00:04:53.011
By Mr. Rajasegar Chandran.

00:04:53.095 --> 00:04:54.670
A front-end developer from Freshworks Inc.

00:04:54.754 --> 00:04:56.120
From India.

00:04:56.960 --> 00:05:00.079
Next section is The Art of Crafting Codemods.

00:05:00.759 --> 00:05:03.676
Please welcome Mr. Rajasegar Chandran,

00:05:03.759 --> 00:05:07.560
front-end developer from Freshworks Inc. from India,

00:05:08.080 --> 00:05:24.679
on the screen!

00:05:25.199 --> 00:05:28.877
Hi. Hello. Namaskar.

00:05:28.960 --> 00:05:30.556
Welcome from Chennai, India.

00:05:30.639 --> 00:05:33.240
I am Rajasekar Chandran.

00:05:33.720 --> 00:05:35.760
I'm sorry I couldn't make it to Bangkok.

00:05:36.240 --> 00:05:37.477
So the organizers were kind enough

00:05:37.560 --> 00:05:39.600
to let me connect from remote.

00:05:41.479 --> 00:05:44.920
I'm very honored and privileged to be here with you all,

00:05:45.080 --> 00:05:46.760
javascript bangkok.

00:05:47.120 --> 00:05:49.120
Okay, so let's get started.

00:05:49.560 --> 00:05:51.039
I'm going to share my screen.

00:06:03.840 --> 00:06:08.119
Are you guys able to hear my screen?

00:06:08.880 --> 00:06:09.319
Thank you.

00:06:11.520 --> 00:06:15.279
So in this talk, I'm going to talk about codemods.

00:06:15.880 --> 00:06:17.840
I'm going to put an idea into your minds,

00:06:18.199 --> 00:06:19.720
an idea about codemods,

00:06:20.440 --> 00:06:24.277
an idea about how you can make large scale refactoring

00:06:24.360 --> 00:06:28.359
tasks less painful and more effective.

00:06:29.000 --> 00:06:31.556
It is said that once the human mind is completely

00:06:31.639 --> 00:06:32.919
exposed to an idea,

00:06:33.599 --> 00:06:36.119
it will never regain its original dimensions.

00:06:36.319 --> 00:06:37.520
At the end of this talk,

00:06:38.000 --> 00:06:40.836
I hope you all feel confident making large scale

00:06:40.919 --> 00:06:43.400
changes with your code base.

00:06:44.919 --> 00:06:46.717
The tooling and the techniques which we are going

00:06:46.800 --> 00:06:50.079
to discuss will enable you to do that.

00:06:51.759 --> 00:06:53.600
I posted my slides here in this URL

00:06:53.880 --> 00:06:55.719
tinyurl.com/jsbkcodemods.

00:06:56.720 --> 00:06:58.599
You can follow along if you want.

00:06:59.199 --> 00:07:04.999
I'll tweet the URL.

00:07:10.080 --> 00:07:13.959
You can follow along if you want.

00:07:16.360 --> 00:07:17.200
This is about me.

00:07:17.360 --> 00:07:20.399
I'm a front-end developer from Freshworks.

00:07:21.039 --> 00:07:24.556
Freshworks enables platform for small and medium

00:07:24.639 --> 00:07:26.796
sized businesses to support customers through

00:07:26.879 --> 00:07:30.480
various channels like chat, caller, etc.

00:07:31.240 --> 00:07:32.676
If you want to know more about Freshworks,

00:07:32.759 --> 00:07:34.839
you can message me on Twitter.

00:07:35.120 --> 00:07:36.200
My DMs are open.

00:07:39.160 --> 00:07:42.559
I'm rajasegar on GitHub and rajasegar_c on Twitter.

00:07:42.800 --> 00:07:45.477
I also write occasionally some blog articles in

00:07:45.560 --> 00:07:47.800
hangaroundtheweb.com, my personal blog.

00:07:48.199 --> 00:07:50.439
I'm based out of Chennai, India.

00:07:51.039 --> 00:07:52.959
Let's discuss the problems first.

00:07:53.479 --> 00:07:55.676
We'll discuss little bit about the problems

00:07:55.759 --> 00:07:59.076
codemods solve for us before diving into

00:07:59.159 --> 00:08:01.160
the central theme of the discussion.

00:08:01.360 --> 00:08:03.597
Let's start with the more familiar problem,

00:08:03.680 --> 00:08:05.279
making changes in code.

00:08:06.039 --> 00:08:09.240
I think we change code more often as developers.

00:08:09.479 --> 00:08:11.157
Instead of adding and deleting code,

00:08:11.240 --> 00:08:12.479
it's part of a daily job.

00:08:13.840 --> 00:08:15.880
Let's start with a small example.

00:08:16.919 --> 00:08:17.917
A little disclaimer here,

00:08:18.000 --> 00:08:21.720
I'm going to be showing a lot of code snippets.

00:08:23.039 --> 00:08:24.197
This is a simple example.

00:08:24.280 --> 00:08:25.836
We have a variable declaration,

00:08:25.919 --> 00:08:27.360
let hello equal to Bangkok,

00:08:27.479 --> 00:08:30.917
and a function which says hello Bangkok.

00:08:31.000 --> 00:08:33.399
So I'm going to replace hello with Bangkok.

00:08:33.839 --> 00:08:35.479
How do I make this change?

00:08:36.080 --> 00:08:38.520
This is a simple change, actually.

00:08:39.640 --> 00:08:42.196
Usually I can do it with my find and replace

00:08:42.279 --> 00:08:43.959
in my code editor.

00:08:44.760 --> 00:08:47.879
If you want to do it in multiple places or files,

00:08:48.120 --> 00:08:50.000
you need to write a script for automating.

00:08:51.560 --> 00:08:53.917
Let's say you take this tool called sed,

00:08:54.000 --> 00:08:54.997
which is stream editor.

00:08:55.080 --> 00:08:57.717
This is one of the oldest Unix tools which works

00:08:57.800 --> 00:08:59.077
with regular expressions.

00:08:59.160 --> 00:09:02.876
You give regular expressions to identify the pattern,

00:09:02.959 --> 00:09:05.880
source and destination, and you replace with it.

00:09:07.200 --> 00:09:10.320
After running the script, this is what I got.

00:09:11.000 --> 00:09:12.360
As you can see here,

00:09:13.360 --> 00:09:18.159
the word hello has been changed to Bangkok everywhere.

00:09:18.440 --> 00:09:20.040
Instead of just the variable name,

00:09:20.720 --> 00:09:22.597
this is the possible side effect that could happen

00:09:22.680 --> 00:09:26.037
if you're not careful with the regex replacements

00:09:26.120 --> 00:09:28.120
throughout your code base.

00:09:29.120 --> 00:09:30.480
This is what happened.

00:09:30.880 --> 00:09:32.677
I started with the problem and I ended with

00:09:32.760 --> 00:09:36.080
multiple problems using regular expressions.

00:09:38.079 --> 00:09:40.357
The main problem here is with regular expressions,

00:09:40.440 --> 00:09:42.240
it doesn't work like with context.

00:09:42.480 --> 00:09:44.996
It doesn't know what context we are going

00:09:45.079 --> 00:09:46.200
to make the change.

00:09:46.880 --> 00:09:49.280
The original requirement of replacing hello

00:09:49.519 --> 00:09:51.517
with Bangkok becomes more specific like

00:09:51.600 --> 00:09:54.196
I want to replace only the variable name hello

00:09:54.279 --> 00:09:55.680
with Bangkok.

00:09:57.000 --> 00:09:58.919
This is a drawback and limitation with

00:09:59.399 --> 00:10:00.279
regular expressions.

00:10:03.440 --> 00:10:07.040
Because regular expressions are low level primitives,

00:10:07.160 --> 00:10:09.797
doesn't able to capture the semantic information

00:10:09.880 --> 00:10:13.037
associated with your code like which one is

00:10:13.120 --> 00:10:15.919
a variable name, which one is a function name,

00:10:16.200 --> 00:10:19.560
which one is a string literal.

00:10:20.279 --> 00:10:22.077
Then the next problem I'm going to talk about

00:10:22.160 --> 00:10:24.840
is upgrading code bases.

00:10:25.440 --> 00:10:26.557
At a very high level,

00:10:26.640 --> 00:10:28.760
there are two types of upgrades.

00:10:29.040 --> 00:10:31.196
First type of upgrade is upgrading to new

00:10:31.279 --> 00:10:33.159
language syntax and features,

00:10:33.680 --> 00:10:36.316
like you can upgrade to ES6 arrow function,

00:10:36.399 --> 00:10:38.597
you can upgrade from callbacks to promises

00:10:38.680 --> 00:10:41.480
to async/await, those kind of upgrades.

00:10:41.880 --> 00:10:44.196
The second type of upgrade is upgrading your

00:10:44.279 --> 00:10:46.957
library or framework to a newer version,

00:10:47.040 --> 00:10:49.117
like you can upgrade React to the latest version,

00:10:49.200 --> 00:10:51.399
Vue.js to the latest version, something like that.

00:10:51.519 --> 00:10:53.640
Let's see an example of these things.

00:10:53.920 --> 00:10:54.876
The first type of upgrade,

00:10:54.959 --> 00:10:57.200
upgrading to new language syntax features.

00:10:57.360 --> 00:10:59.079
Before arrow functions are part of the

00:10:59.399 --> 00:11:00.597
JavaScript specification,

00:11:00.680 --> 00:11:01.720
we used to do this.

00:11:01.959 --> 00:11:04.480
Store a reference to the variable self.

00:11:04.920 --> 00:11:06.880
And if you want to use it inside a function,

00:11:08.320 --> 00:11:10.360
we use that reference for the context.

00:11:11.680 --> 00:11:13.199
Now with arrow functions,

00:11:13.399 --> 00:11:15.360
we don't have to do this anymore.

00:11:15.920 --> 00:11:16.917
The parent context,

00:11:17.000 --> 00:11:20.720
the arrow functions can make use of the parent context.

00:11:21.399 --> 00:11:23.080
This is an example from Vue.js.

00:11:23.600 --> 00:11:24.759
If you want to upgrade from Vue 1.x to 2.0,

00:11:27.279 --> 00:11:30.637
there is a deprecation with the attached lifecycle.

00:11:30.720 --> 00:11:32.800
Attached lifecycle hook has been renamed to mounted.

00:11:33.560 --> 00:11:36.400
Whatever you have to do inside the attached hook,

00:11:36.519 --> 00:11:39.599
you have to wrap it with the next tick function.

00:11:40.120 --> 00:11:42.436
These kind of changes are not simply possible

00:11:42.519 --> 00:11:46.120
with regular expressions because regular expressions

00:11:46.880 --> 00:11:48.800
are low level primitives.

00:11:49.120 --> 00:11:51.237
They assume that your source code is just

00:11:51.320 --> 00:11:52.837
a stream of characters.

00:11:52.920 --> 00:11:55.397
But instead, we need a better tooling to work

00:11:55.480 --> 00:11:57.597
with the higher level abstraction than

00:11:57.680 --> 00:11:59.120
regular expressions.

00:11:59.240 --> 00:12:02.199
We'll see what the tooling is shortly.

00:12:02.639 --> 00:12:05.117
So now you know that making changes to code

00:12:05.200 --> 00:12:07.240
is not just find and replace,

00:12:07.360 --> 00:12:10.316
is a lot other stuff like you add code,

00:12:10.399 --> 00:12:15.240
you delete code, you do more, actually.

00:12:15.600 --> 00:12:18.120
So it's time to stop and reflect.

00:12:19.360 --> 00:12:20.597
As it said earlier,

00:12:20.680 --> 00:12:23.079
regular expressions are low level primitives

00:12:23.639 --> 00:12:27.277
for just replacing textual representation

00:12:27.360 --> 00:12:28.400
of your source code.

00:12:28.680 --> 00:12:31.556
It is not suited for making large scale refactoring

00:12:31.639 --> 00:12:35.240
or code upgrades or making changes with context.

00:12:37.839 --> 00:12:40.517
So on a side note, if you want to do large scale

00:12:40.600 --> 00:12:45.361
refactoring tasks or a major overhaul of your codebases,

00:12:46.000 --> 00:12:46.157
okay?

00:12:46.240 --> 00:12:49.917
The goal of this would be like, how can I do this

00:12:50.000 --> 00:12:50.797
efficiently?

00:12:50.880 --> 00:12:52.717
How can I do this with less friction?

00:12:52.800 --> 00:12:55.560
That is the goal of every project manager or team lead

00:12:56.320 --> 00:13:01.279
when carrying out a large migration of source code.

00:13:02.199 --> 00:13:05.277
This is a book by Chad Fowler called "My Job Went to

00:13:05.360 --> 00:13:07.200
India: 52 Ways to Save Your Job."

00:13:07.360 --> 00:13:10.517
Chad Fowler is an acclaimed software developer, musician,

00:13:10.600 --> 00:13:11.196
and author.

00:13:11.279 --> 00:13:13.477
He worked with some of the world's largest companies like

00:13:13.560 --> 00:13:15.720
Facebook, Google, Microsoft.

00:13:16.160 --> 00:13:19.597
This book is his experience of training and mentoring an

00:13:19.680 --> 00:13:23.240
offshore development center in Bangalore, India.

00:13:23.760 --> 00:13:26.637
And later, for some reason, the same book got renamed to

00:13:26.720 --> 00:13:28.360
"The Passionate Programmer."

00:13:28.600 --> 00:13:32.200
I think 52 is not a very lucky number for Chad.

00:13:32.760 --> 00:13:36.077
In this book, Chad discusses three ways to increase the

00:13:36.160 --> 00:13:37.720
throughput.

00:13:37.839 --> 00:13:41.760
The first is to get faster people to do the work.

00:13:42.160 --> 00:13:44.679
The second, get more people to do the work.

00:13:45.279 --> 00:13:48.760
And the third, automate the work.

00:13:49.440 --> 00:13:53.717
But in reality, it is not possible to simply get faster

00:13:53.800 --> 00:13:57.477
people or add more people to do the work.

00:13:57.560 --> 00:14:00.277
It seems like a classic mistake in software development.

00:14:00.360 --> 00:14:03.479
So the best sensible thing to do here is to automate

00:14:03.800 --> 00:14:04.957
the work.

00:14:05.040 --> 00:14:07.079
This is where codemods comes into the picture.

00:14:07.240 --> 00:14:11.319
Codemods is a tool or library to refactor large scale

00:14:11.519 --> 00:14:12.319
codebases.

00:14:13.560 --> 00:14:17.237
You do it with partial automation, with a little human

00:14:17.320 --> 00:14:20.116
oversight and occasional intervention.

00:14:20.199 --> 00:14:23.320
So codemods is basically to make large scale changes

00:14:23.440 --> 00:14:28.200
automated with better tooling than regular expressions.

00:14:28.320 --> 00:14:29.759
So what can codemods do?

00:14:30.079 --> 00:14:32.999
These are some of the major applications of codemods,

00:14:33.160 --> 00:14:35.477
but they are actually quite capable of doing other

00:14:35.560 --> 00:14:36.120
things.

00:14:36.560 --> 00:14:40.676
You can easily update your codebase to fit your coding

00:14:40.759 --> 00:14:41.436
conventions.

00:14:41.519 --> 00:14:44.397
Let's say you want to adopt a style guide or coding

00:14:44.480 --> 00:14:45.800
convention for your codebase.

00:14:46.000 --> 00:14:47.879
You can do very well with codemods.

00:14:49.160 --> 00:14:52.999
And if you want to make widespread changes when an API

00:14:53.120 --> 00:14:56.797
is modified, or if you want to automate large scale

00:14:56.880 --> 00:14:57.837
refactoring tasks.

00:14:57.920 --> 00:15:00.676
So most of the time, the codemods will be applicable

00:15:00.759 --> 00:15:01.599
in this area.

00:15:01.959 --> 00:15:06.357
Frameworks like ReactJS, VueJS are making use of

00:15:06.440 --> 00:15:09.199
codemods for their migration path.

00:15:09.959 --> 00:15:13.920
Especially EmberJS, which I am working with in my

00:15:14.800 --> 00:15:15.520
workplace.

00:15:16.079 --> 00:15:18.316
Usually we work with large EmberJS codebases.

00:15:18.399 --> 00:15:21.756
Ember automatically provides migration paths from one

00:15:21.839 --> 00:15:24.196
version of the framework to other version using

00:15:24.279 --> 00:15:24.841
codemods.

00:15:25.279 --> 00:15:28.397
Can use automated tools to automatically update your

00:15:28.480 --> 00:15:30.597
codebase from one version to the other version by

00:15:30.680 --> 00:15:31.680
running codemods.

00:15:33.279 --> 00:15:35.717
And you also take advantage of newer language features,

00:15:35.800 --> 00:15:38.236
which we discussed earlier, upgrading your codebases

00:15:38.319 --> 00:15:41.080
to make use of new language features.

00:15:41.440 --> 00:15:44.160
And if you want to know what codemods are out there

00:15:44.360 --> 00:15:47.277
and what they are capable of doing, I put together

00:15:47.360 --> 00:15:48.239
an awesome list.

00:15:48.639 --> 00:15:49.756
So please check it out.

00:15:49.839 --> 00:15:51.841
There are a lot of codemods available for many

00:15:52.680 --> 00:15:53.320
purposes.

00:15:53.680 --> 00:15:54.879
So please have a look at it.

00:15:55.399 --> 00:16:00.078
And this is a very high level overview of how codemods

00:16:00.199 --> 00:16:00.599
work.

00:16:01.199 --> 00:16:03.316
So the first stage, you'll convert the source code

00:16:03.399 --> 00:16:04.400
into something called AST.

00:16:05.040 --> 00:16:08.196
AST is called Abstract Syntax Tree representation.

00:16:08.279 --> 00:16:10.917
And you manipulate the AST representation of your

00:16:11.000 --> 00:16:11.760
source code.

00:16:12.240 --> 00:16:14.756
Then you again convert the AST representation back to

00:16:14.839 --> 00:16:14.999
source code.

00:16:15.759 --> 00:16:18.397
This is at a very high level how the transformations

00:16:18.480 --> 00:16:21.359
take place or codemods work.

00:16:21.959 --> 00:16:23.720
So what is an AST?

00:16:24.439 --> 00:16:26.876
AST is basically a tree representation of your source

00:16:26.959 --> 00:16:27.276
code.

00:16:27.359 --> 00:16:29.077
Your source code is converted into a tree data

00:16:29.160 --> 00:16:31.639
structure, and that becomes your AST.

00:16:32.519 --> 00:16:36.879
Whenever I try to explain AST, people are not able to

00:16:37.000 --> 00:16:39.000
grasp the idea very clearly.

00:16:39.120 --> 00:16:41.920
So I'll come up with this analogy often.

00:16:42.560 --> 00:16:45.200
Even though this is an oversimplification, it works

00:16:45.560 --> 00:16:47.876
much better and clearer to understand the concept.

00:16:47.959 --> 00:16:50.280
So AST is basically the DOM for your code.

00:16:50.639 --> 00:16:52.797
The Document Object Model, which is a tree

00:16:52.880 --> 00:16:55.799
representation of your markup code, right?

00:16:56.399 --> 00:16:58.397
So how is the AST created in the first place?

00:16:58.480 --> 00:17:01.360
Your AST is created by the compiler systems.

00:17:01.839 --> 00:17:05.797
Your code passes through stages like lexical analyzer,

00:17:05.880 --> 00:17:07.839
syntax analyzer.

00:17:08.199 --> 00:17:09.956
And at the end of the syntax analysis stage, you get

00:17:10.039 --> 00:17:10.679
the AST.

00:17:11.439 --> 00:17:14.040
So this is how the lexical analysis stages work.

00:17:14.360 --> 00:17:16.716
You give the code, there is something called a scanner

00:17:16.799 --> 00:17:19.557
which parses the code and converts into a token stream

00:17:19.640 --> 00:17:21.080
of characters.

00:17:21.280 --> 00:17:23.800
And later, the tokens are converted into a tree

00:17:24.120 --> 00:17:27.360
representation using the parser, which is AST.

00:17:28.240 --> 00:17:30.397
A little disclaimer here, I'm leaving out a lot of

00:17:30.480 --> 00:17:34.037
details about compilers because they make use of other

00:17:34.120 --> 00:17:36.960
sophisticated stuff to create ASTs like symbol tables.

00:17:37.520 --> 00:17:40.840
So this is just a simple overview of how ASTs are

00:17:41.280 --> 00:17:41.840
created.

00:17:42.440 --> 00:17:44.797
This is your source code representation, and this is

00:17:44.880 --> 00:17:47.039
your AST, Abstract Syntax Tree.

00:17:47.360 --> 00:17:49.760
Usually it is represented in object format.

00:17:50.440 --> 00:17:53.439
In JavaScript, it is generally represented using JSON

00:17:54.360 --> 00:17:55.000
notation.

00:17:55.360 --> 00:17:57.520
And this is the tool which you will be using to

00:17:58.280 --> 00:18:00.959
visualize or explore your ASTs.

00:18:01.320 --> 00:18:05.640
Let's have a quick look at the tool.

00:18:06.320 --> 00:18:09.760
So let me resize it for you.

00:18:10.799 --> 00:18:14.200
Okay. So this is the sample code I've shown you.

00:18:14.880 --> 00:18:17.237
And this is AST representation.

00:18:17.320 --> 00:18:19.757
So at the root, you have a file node.

00:18:19.840 --> 00:18:20.800
This is called a node.

00:18:21.320 --> 00:18:23.639
And these are children, so child nodes.

00:18:24.159 --> 00:18:26.596
Under file, you have program, and you have variable

00:18:26.679 --> 00:18:28.960
declaration, this particular statement.

00:18:29.679 --> 00:18:32.200
And this is function declaration, which is this one.

00:18:32.679 --> 00:18:35.917
So inside variable declaration, you have a variable

00:18:36.000 --> 00:18:38.956
declarator, which you have different type of child

00:18:39.039 --> 00:18:41.797
nodes like identifier and something which identifies

00:18:41.880 --> 00:18:43.959
a specific part of your code.

00:18:44.559 --> 00:18:49.920
Okay, so we'll come back to this later.

00:18:50.520 --> 00:18:52.800
So now you know ASTs, right?

00:18:52.960 --> 00:18:55.040
So where exactly your ASTs are used?

00:18:55.320 --> 00:18:57.277
ASTs are used in a lot of places,

00:18:57.360 --> 00:18:59.476
right from syntax highlighting, code completion,

00:18:59.559 --> 00:19:00.280
static analysis.

00:19:00.880 --> 00:19:05.277
So without ASTs, your JavaScript tooling is not at all

00:19:05.360 --> 00:19:05.956
possible.

00:19:06.039 --> 00:19:08.160
So if you want to build advanced tooling,

00:19:09.120 --> 00:19:10.640
you need to make use of your ASTs.

00:19:11.200 --> 00:19:14.280
Like Babel makes use of AST, TypeScript,

00:19:14.400 --> 00:19:15.680
everything makes use of ASTs.

00:19:15.880 --> 00:19:18.836
These are some of the tools widely known in the

00:19:18.919 --> 00:19:21.317
JavaScript ecosystem, making use of ASTs to do

00:19:21.400 --> 00:19:23.637
their job, like ESLint, Babel, Parcel,

00:19:23.720 --> 00:19:26.560
your builders, everything.

00:19:26.760 --> 00:19:30.000
So this is how the codemods work overall.

00:19:30.600 --> 00:19:33.956
Like as I said earlier, your code is converted into

00:19:34.039 --> 00:19:36.760
AST and then AST back to code.

00:19:37.360 --> 00:19:39.559
So these are the different tools coming into play.

00:19:39.720 --> 00:19:41.637
At the first stage, this is called parse,

00:19:41.720 --> 00:19:43.479
which is done by a tool called Recast,

00:19:43.919 --> 00:19:46.279
and then the transform, and then the print.

00:19:46.799 --> 00:19:49.880
So we'll see that in detail.

00:19:50.400 --> 00:19:51.800
So what is JSCodeShift?

00:19:52.080 --> 00:19:55.076
JSCodeShift is the de facto tool for running your

00:19:55.159 --> 00:19:57.681
codemods on your codebases.

00:19:58.240 --> 00:20:00.956
So you create a transform function and you run it

00:20:01.039 --> 00:20:03.237
with JSCodeShift.

00:20:03.320 --> 00:20:06.200
It's created by Facebook and later open-sourced it.

00:20:07.320 --> 00:20:08.917
This CodeShift is made up of two things.

00:20:09.000 --> 00:20:11.476
One is called the runner and the other one is called

00:20:11.559 --> 00:20:12.400
the wrapper.

00:20:12.840 --> 00:20:15.836
The runner is actually a CLI, command-line interface

00:20:15.919 --> 00:20:19.677
tool, and the wrapper is a wrapper on top of a

00:20:19.760 --> 00:20:21.399
library called Recast.

00:20:21.919 --> 00:20:23.877
So what you have to do, you have to install the

00:20:23.960 --> 00:20:27.237
JSCodeShift tool globally or you can install it

00:20:27.320 --> 00:20:30.596
local, and you pass something called the transforms

00:20:30.679 --> 00:20:33.757
to the JSCodeShift and the filenames or the file

00:20:33.840 --> 00:20:34.240
paths.

00:20:34.440 --> 00:20:36.439
You can also pass in some options.

00:20:36.799 --> 00:20:40.080
The transforms contains the manipulation logic of

00:20:40.200 --> 00:20:44.600
your ASTs, the node manipulation logic of your ASTs.

00:20:45.120 --> 00:20:49.680
So you can also pass folders to that.

00:20:50.360 --> 00:20:54.480
And this is how, why JSCodeShift is very popular or

00:20:54.720 --> 00:20:58.120
a standard tool for running codemods, because it

00:20:58.840 --> 00:21:02.917
spawns multiple processes parallelly to apply the

00:21:03.000 --> 00:21:06.160
transform function throughout your codebase.

00:21:06.720 --> 00:21:09.120
Like if you have hundreds of files, so JSCodeShift

00:21:09.320 --> 00:21:11.437
can be capable of spawning multiple processes and

00:21:11.520 --> 00:21:15.199
running the transform against the files.

00:21:15.799 --> 00:21:16.917
So and then Recast.

00:21:17.000 --> 00:21:20.039
Recast is the library which JSCodeShift uses to

00:21:20.799 --> 00:21:23.956
apply the transformations on the ASTs or abstract

00:21:24.039 --> 00:21:24.800
syntax trees.

00:21:25.200 --> 00:21:27.877
Recast is AST to AST transformer.

00:21:27.960 --> 00:21:30.877
It is also a pretty printer, which means it keeps

00:21:30.960 --> 00:21:33.400
your source code formatting very intact.

00:21:33.720 --> 00:21:36.517
It does not change the formatting, something like

00:21:36.600 --> 00:21:37.799
Prettier JS will do.

00:21:38.520 --> 00:21:41.639
And it also generates source map.

00:21:42.559 --> 00:21:45.956
And this is how the overall architecture of code

00:21:46.039 --> 00:21:47.359
transformations work.

00:21:48.039 --> 00:21:50.877
So first stage, we'll parse the code with the

00:21:50.960 --> 00:21:54.840
Recast and then you get the AST, and then the AST

00:21:55.039 --> 00:21:58.121
can be manipulated using the JSCodeShift APIs.

00:21:58.640 --> 00:22:02.080
Like you can find AST nodes, you can create new AST

00:22:02.240 --> 00:22:05.640
nodes, you can update AST nodes.

00:22:06.159 --> 00:22:08.997
Once the manipulations are done, you can print them

00:22:09.080 --> 00:22:10.360
back to the source code.

00:22:10.960 --> 00:22:13.596
So this is the overall idea or bird's eye view of

00:22:13.679 --> 00:22:16.959
how the codemod transformations take place.

00:22:17.559 --> 00:22:20.397
So if you don't understand all the stuff I've said

00:22:20.480 --> 00:22:23.677
previously, so as I said earlier, the AST is your

00:22:23.760 --> 00:22:24.076
DOM.

00:22:24.159 --> 00:22:26.797
So I'll come up with more analogies to reinforce

00:22:26.880 --> 00:22:27.440
the idea.

00:22:28.039 --> 00:22:30.677
So you inspect the DOM with your browser, right?

00:22:30.760 --> 00:22:33.037
You inspect the DOM with your browser and you

00:22:33.120 --> 00:22:35.000
manipulate it with something called jQuery.

00:22:35.440 --> 00:22:38.157
So similarly, you inspect your ASTs or abstract

00:22:38.240 --> 00:22:41.317
syntax trees with AST Explorer and you can

00:22:41.400 --> 00:22:43.680
manipulate the ASTs with JSCodeShift.

00:22:44.600 --> 00:22:45.877
So that is the overall idea.

00:22:45.960 --> 00:22:48.157
If you understand this and then you are an expert

00:22:48.240 --> 00:22:49.040
in codemods.

00:22:50.400 --> 00:22:52.237
Okay, so let's see a demo.

00:22:52.320 --> 00:22:55.559
So let's switch to AST Explorer tab.

00:23:00.080 --> 00:23:00.400
Okay.

00:23:01.039 --> 00:23:04.720
So let me turn on the transform space.

00:23:05.320 --> 00:23:08.279
So this is the original source code and this is

00:23:08.480 --> 00:23:11.076
AST, and this is the transform function I was

00:23:11.159 --> 00:23:12.039
talking about.

00:23:12.559 --> 00:23:16.559
So the default transform comes with reversing your

00:23:16.679 --> 00:23:17.840
identifier names.

00:23:18.200 --> 00:23:22.157
But what we want to replace the variable names,

00:23:22.240 --> 00:23:22.720
right?

00:23:22.919 --> 00:23:27.120
So I'll delete this part.

00:23:30.760 --> 00:23:35.039
So what we are going to do is we're going to change

00:23:38.320 --> 00:23:48.200
the name to something like Bangkok.

00:23:48.880 --> 00:23:52.557
See, again we are doing the same mistake, right?

00:23:52.640 --> 00:23:54.479
We have changed everything to Bangkok.

00:23:54.919 --> 00:23:56.677
So you have to be careful here.

00:23:56.760 --> 00:23:58.880
So this context is everything.

00:23:59.080 --> 00:24:01.797
So what we have find is, we are finding all the

00:24:01.880 --> 00:24:03.199
identifiers in the code.

00:24:03.679 --> 00:24:06.639
So you have identifiers here in your variable

00:24:07.840 --> 00:24:10.160
declarators, right?

00:24:10.760 --> 00:24:14.557
So and you have identifiers inside your function

00:24:14.640 --> 00:24:17.160
name also.

00:24:17.840 --> 00:24:22.120
So as you can see here, call object.

00:24:22.640 --> 00:24:24.199
We have identifiers here also.

00:24:24.679 --> 00:24:26.677
So what I'm going to do is I'm going to find all

00:24:26.760 --> 00:24:31.397
the variable declarators instead, instead of finding

00:24:31.480 --> 00:24:35.960
just identifiers.

00:24:36.080 --> 00:24:45.120
So I'll say variable declarators.

00:24:45.240 --> 00:24:51.399
And I'm going to find the variable declarators.

00:24:51.919 --> 00:24:56.797
So here you can see, inspect the node, the ID and

00:24:56.880 --> 00:24:57.639
name hello.

00:24:59.120 --> 00:25:37.080
So I'm going to write Okay.

00:25:37.760 --> 00:25:41.600
Let me try it again.

00:25:42.200 --> 00:25:49.400
Find variable declarators with the name hello,

00:25:50.000 --> 00:25:50.480
rename to Bangkok.

00:25:56.210 --> 00:25:58.760
Yep, we got it.

00:25:59.120 --> 00:26:01.877
So, this is the right API to find your variable

00:26:01.960 --> 00:26:02.677
declarators.

00:26:02.760 --> 00:26:07.196
So, instead of finding all the identifiers, you can

00:26:07.279 --> 00:26:09.960
make use of this API with JSCodeShift.

00:26:11.440 --> 00:26:13.240
I hope this demo made sense.

00:26:13.760 --> 00:26:19.119
And then let's switch back to the presentation.

00:26:20.360 --> 00:26:22.757
So, now you know that finding nodes and manipulating

00:26:22.840 --> 00:26:25.601
nodes is the core part of writing codemods.

00:26:26.000 --> 00:26:27.637
So, I'm going to introduce a couple of tools which

00:26:27.720 --> 00:26:30.880
will make your job easier in writing codemods.

00:26:31.480 --> 00:26:34.159
The first is finding nodes.

00:26:34.679 --> 00:26:36.877
For this, we're going to make use of tool called

00:26:36.960 --> 00:26:38.000
AST Finder.

00:26:38.200 --> 00:26:40.080
So, you can find it here.

00:26:40.760 --> 00:26:44.119
I'll show a demo of that.

00:26:44.799 --> 00:26:46.037
This is how the code will work.

00:26:46.120 --> 00:26:47.200
Let me resize.

00:26:47.640 --> 00:26:51.157
Okay, so you give a code expression, source code

00:26:51.240 --> 00:26:54.196
expression, and it will automatically help you to

00:26:54.279 --> 00:26:57.799
figure out how you can find it in the AST node.

00:26:58.039 --> 00:27:02.557
So, this code is basically a call expression with a

00:27:02.640 --> 00:27:06.237
callee of type member expression, and then it is

00:27:06.320 --> 00:27:08.797
having parameters like object name and property

00:27:08.880 --> 00:27:09.999
name foo.

00:27:10.919 --> 00:27:11.157
Right?

00:27:11.240 --> 00:27:14.596
So, this will help you to write codemods, so you

00:27:14.679 --> 00:27:18.517
don't have to remember all these APIs for JSCodeShift

00:27:18.600 --> 00:27:22.037
because JSCodeShift has got very poor documentation.

00:27:22.120 --> 00:27:24.237
When you are starting with codemods, it's a lot of

00:27:24.320 --> 00:27:25.800
things to learn.

00:27:26.320 --> 00:27:30.080
So, the next tool I'm going to introduce is

00:27:30.760 --> 00:27:31.840
AST Builder.

00:27:32.200 --> 00:27:35.196
So, which will help you to build the AST nodes from

00:27:35.279 --> 00:27:36.199
your source code.

00:27:36.799 --> 00:27:41.557
So, usually, when we are replacing code, sometimes,

00:27:41.640 --> 00:27:43.917
most of the times, you need to build new nodes and

00:27:44.000 --> 00:27:46.880
add it to the AST for your code to work.

00:27:47.440 --> 00:27:50.799
So, instead, you can make use of this tool.

00:27:51.120 --> 00:27:53.120
So, this is called AST Builder.

00:27:53.640 --> 00:27:56.037
So, the same thing, you give the source code as your

00:27:56.120 --> 00:27:59.076
input, and you know how to build that particular

00:27:59.159 --> 00:27:59.920
AST node.

00:28:00.360 --> 00:28:04.797
So, this is an expression statement, and inside the

00:28:04.880 --> 00:28:06.836
expression statement, you have a call expression and

00:28:06.919 --> 00:28:10.040
member expression, which is of type identifier foo

00:28:10.240 --> 00:28:10.879
and bar.

00:28:11.039 --> 00:28:12.917
So, anything that comes with dot is a member

00:28:13.000 --> 00:28:13.637
expression.

00:28:13.720 --> 00:28:15.476
So, this is an identifier, and this is an identifier.

00:28:15.559 --> 00:28:19.280
foo.bar is a member expression within, inside a call

00:28:20.240 --> 00:28:21.040
expression.

00:28:21.240 --> 00:28:25.040
And then the last tool I'm going to introduce.

00:28:25.519 --> 00:28:28.200
So far, we have built codemods, right?

00:28:28.799 --> 00:28:32.557
So, what we find it difficult for me when I started

00:28:32.640 --> 00:28:35.397
writing codemods is, a lot of the time, I didn't

00:28:35.480 --> 00:28:40.037
know how AST APIs are, I don't know how the node

00:28:40.120 --> 00:28:41.840
manipulation APIs work.

00:28:42.440 --> 00:28:45.080
So, when I tell my junior developers to do the same,

00:28:45.480 --> 00:28:48.476
they are finding it a little difficult to find

00:28:48.559 --> 00:28:49.160
the APIs.

00:28:49.760 --> 00:28:52.440
So, you have to read all the existing codemods and

00:28:54.000 --> 00:28:55.160
know about these APIs.

00:28:55.720 --> 00:28:58.117
So, instead, what if you have a tool which will

00:28:58.200 --> 00:29:00.239
automatically write codemods for you?

00:29:00.919 --> 00:29:01.316
Right?

00:29:01.399 --> 00:29:04.037
So, that is the tool called Jarvis.

00:29:04.120 --> 00:29:05.560
I built it recently.

00:29:05.840 --> 00:29:10.357
So, it is very beta quality, but it works.

00:29:10.440 --> 00:29:11.280
It is a start.

00:29:12.120 --> 00:29:14.600
So, let me give you a demo.

00:29:15.200 --> 00:29:16.877
So, this is the tool I was talking about.

00:29:16.960 --> 00:29:19.757
So, this is the input code, and this is the output

00:29:19.840 --> 00:29:22.560
code, and automatically the tool will write the

00:29:22.799 --> 00:29:25.240
codemod for you.

00:29:26.000 --> 00:29:28.476
So, as you can see, it automatically finds the call

00:29:28.559 --> 00:29:30.637
expression with the filter, and it'll just

00:29:30.720 --> 00:29:31.440
replace it.

00:29:32.200 --> 00:29:35.357
So, it works with the assumption that if you want to

00:29:35.440 --> 00:29:38.397
change the node, you have to replace the node.

00:29:38.480 --> 00:29:42.919
So, let me show the example which we were working,

00:29:43.840 --> 00:29:46.319
like replacing the variable name.

00:29:46.600 --> 00:29:53.716
So, let hello to Bangkok.

00:29:53.799 --> 00:29:56.799
I'm sorry.

00:29:57.399 --> 00:30:05.670
Yeah, Bangkok.

00:30:13.200 --> 00:30:15.917
Okay, so as you can see, it automatically figures

00:30:16.000 --> 00:30:17.959
out what you have to do.

00:30:19.559 --> 00:30:22.120
So, that's it.

00:30:23.000 --> 00:30:27.277
So, how Jarvis works is it uses two npm packages,

00:30:27.360 --> 00:30:29.316
AST Node Finder, AST Node Builder, and you have a

00:30:29.399 --> 00:30:31.960
rule engine.

00:30:32.480 --> 00:30:35.476
So, we also have a codemod CLI tool to generate and

00:30:35.559 --> 00:30:36.877
bootstrap your codemods.

00:30:36.960 --> 00:30:39.237
You can share it with the outside community by

00:30:39.320 --> 00:30:41.439
publishing as npm package.

00:30:41.799 --> 00:30:44.960
I'll just skip through these slides.

00:30:45.480 --> 00:30:49.997
So, what is the takeaway here is that when you are

00:30:50.080 --> 00:30:51.956
making large-scale changes, you need to build

00:30:52.039 --> 00:30:54.360
transformation tools that you can be confident in.

00:30:54.679 --> 00:30:56.800
So, without breaking things.

00:30:57.080 --> 00:31:00.679
So, with this tooling and the AST, you can do that.

00:31:01.279 --> 00:31:07.797
And also, tool-assisted code modifications will help

00:31:07.880 --> 00:31:10.640
you to maintain large-scale codebases in a better way.

00:31:11.279 --> 00:31:12.519
So, that's all from me.

00:31:12.720 --> 00:31:17.836
Hope I made sense with codemods, and hope I can think

00:31:17.919 --> 00:31:19.637
about codemods when you are thinking about

00:31:19.720 --> 00:31:21.920
large-scale code migrations.

00:31:22.120 --> 00:31:23.277
Thank you.

00:31:23.360 --> 00:31:24.959
Thank you very much.

00:31:28.799 --> 00:31:57.240
Thank you for Rajasegar Chandran from India.

00:32:43.799 --> 00:32:47.560
Before we move up to the next section from our

00:32:47.799 --> 00:32:48.760
beloved sponsor,

00:32:49.159 --> 00:32:51.637
I would like to introduce all of you to know more

00:32:51.720 --> 00:32:55.880
about our special products that we provide you for

00:32:59.159 --> 00:33:00.400
this event only.

00:33:01.000 --> 00:33:03.797
For example, we have like hoodie or parka, we have

00:33:03.880 --> 00:33:06.917
black t-shirt with the logo of our event, and we

00:33:07.000 --> 00:33:11.280
have a cap, tumbler, water container, and a sock.

00:33:11.960 --> 00:33:15.917
And we provide you with a special set too in the

00:33:16.000 --> 00:33:17.596
special price, special discount.

00:33:17.679 --> 00:33:21.076
So, if you are interested in buying our products,

00:33:21.159 --> 00:33:25.997
please contact our product booth on the seventh

00:33:26.080 --> 00:33:29.240
floor, beside the registration desk.