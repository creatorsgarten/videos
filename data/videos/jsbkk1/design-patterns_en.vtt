WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:36.360 --> 00:00:39.120
So now it's time for next session.

00:00:39.239 --> 00:00:41.996
Optimization Design Patterns from Games to Web.

00:00:42.079 --> 00:00:46.558
Please welcome Mr. Yonatan Kra, Staff Engineer from WalkMe.

00:01:04.280 --> 00:01:06.160
Good morning, Bangkok.

00:01:06.600 --> 00:01:11.360
How are you today? Anyone?

00:01:11.880 --> 00:01:12.716
It's time to wake up.

00:01:12.799 --> 00:01:15.240
I know it's morning.

00:01:15.680 --> 00:01:17.840
But let's wake up a little bit.

00:01:19.040 --> 00:01:20.720
Okay, thank you for having me here.

00:01:20.960 --> 00:01:23.080
I've had a pleasant time so far at Bangkok.

00:01:23.439 --> 00:01:25.080
You have a very beautiful city.

00:01:26.159 --> 00:01:28.479
A lot of what to see and enjoy.

00:01:29.079 --> 00:01:33.320
I'd like to start with a personal story of mine.

00:01:34.560 --> 00:01:37.759
About six years ago, I started doing JavaScript professionally.

00:01:37.880 --> 00:01:41.280
Until then, I was doing MATLAB and PHP and stuff like that.

00:01:41.880 --> 00:01:44.797
And I worked for an enterprise company,

00:01:44.880 --> 00:01:48.720
and I created a real-time big data application.

00:01:48.840 --> 00:01:51.320
And I created it, it was very beautiful.

00:01:51.520 --> 00:01:56.877
AngularJS, Kendo UI, and a lot of sprinkles and design.

00:01:56.960 --> 00:02:00.999
And then I had to connect it to the actual server.

00:02:01.399 --> 00:02:06.719
And then I got the out-snap screen that some of you might know.

00:02:07.399 --> 00:02:08.879
And I had two choices.

00:02:09.560 --> 00:02:12.600
I could quit and find a new job,

00:02:12.959 --> 00:02:19.117
or I could fight this browser thing that keeps on crashing

00:02:19.200 --> 00:02:21.200
and found out what's happening.

00:02:21.480 --> 00:02:25.080
So I'm standing here today because I kept on fighting.

00:02:25.360 --> 00:02:30.677
And this talk is part of the journey that I experienced.

00:02:30.760 --> 00:02:33.317
I found out ways to optimize my application

00:02:33.400 --> 00:02:38.117
for it to withstand a big load of data

00:02:38.200 --> 00:02:41.317
that's coming into both the Node.js server

00:02:41.400 --> 00:02:44.840
and the actual client in the browser.

00:02:45.280 --> 00:02:47.156
So I hope you enjoy it,

00:02:47.239 --> 00:02:49.796
and I sprinkled some gaming.

00:02:49.879 --> 00:02:52.840
Anyone actually likes to play computer games here?

00:02:53.080 --> 00:02:55.880
Raise your hands so I'll know.

00:02:56.560 --> 00:02:56.880
Yay!

00:02:57.560 --> 00:02:59.117
Okay, so we can talk about it later,

00:02:59.200 --> 00:03:04.560
maybe do some game party or something.

00:03:04.840 --> 00:03:06.277
Okay, so a little bit about me.

00:03:06.360 --> 00:03:07.640
I'm Yonatan.

00:03:07.920 --> 00:03:09.720
I'm a Staff Engineer at WalkMe.

00:03:10.200 --> 00:03:11.880
I used to be CTO at WebEx.

00:03:12.440 --> 00:03:14.317
I used to be a neuroscientist.

00:03:14.400 --> 00:03:15.719
I can talk about it later.

00:03:16.319 --> 00:03:20.800
I'm a speaker, blogger, I'm an Egghead instructor.

00:03:21.000 --> 00:03:22.277
And I'm also a runner.

00:03:22.360 --> 00:03:24.239
This is me winning a half marathon,

00:03:24.480 --> 00:03:27.600
which is kind of one of my best achievements in life.

00:03:28.200 --> 00:03:29.720
And this is my son,

00:03:29.959 --> 00:03:32.876
which is one of the three best achievements in life.

00:03:32.959 --> 00:03:34.199
I have three kids.

00:03:35.000 --> 00:03:41.880
He's running with me and continues the legacy.

00:03:42.400 --> 00:03:44.600
So what are we going to talk about today?

00:03:45.319 --> 00:03:47.480
I'll speak a bit about motivation

00:03:47.640 --> 00:03:52.919
of when and when not to use design patterns for optimization.

00:03:53.159 --> 00:03:54.876
We'll look at design patterns

00:03:54.959 --> 00:03:57.719
and how they affect our actual machine.

00:03:57.920 --> 00:04:00.959
Because JavaScript developers usually develop,

00:04:01.319 --> 00:04:05.120
and they don't tend to think about how their code

00:04:05.319 --> 00:04:10.397
is affecting the actual machine, memory, CPU, and stuff like that.

00:04:10.480 --> 00:04:13.159
We develop for the browser.

00:04:13.599 --> 00:04:19.079
And eventually, we'll summarize because I needed a third part.

00:04:19.759 --> 00:04:21.840
Okay, so design patterns.

00:04:22.800 --> 00:04:26.520
It's kind of a big word or big term.

00:04:27.639 --> 00:04:29.560
And but you use it all the time.

00:04:29.759 --> 00:04:31.116
I mean, if you're doing a for loop,

00:04:31.199 --> 00:04:33.800
you're using the iterator pattern.

00:04:34.560 --> 00:04:35.956
And you're using them all the time

00:04:36.039 --> 00:04:38.157
because design patterns are things

00:04:38.240 --> 00:04:42.160
that were kind of made up or made official

00:04:42.400 --> 00:04:44.240
because they solve a common problem.

00:04:44.560 --> 00:04:48.359
Which means it's a problem you stumble upon every day

00:04:48.520 --> 00:04:50.840
at your day job.

00:04:51.800 --> 00:04:53.160
And why gaming?

00:04:53.840 --> 00:04:55.320
We'll see a short video now.

00:04:55.880 --> 00:04:57.077
Let's see if it's working.

00:04:57.160 --> 00:04:58.799
I hope it is.

00:04:59.720 --> 00:05:04.000
Try to focus on what the user says, if you can hear it.

00:05:04.840 --> 00:05:09.200
You can't hear sound?

00:05:10.639 --> 00:05:10.959
Okay.

00:05:18.960 --> 00:05:20.320
It's not that important.

00:05:33.160 --> 00:05:34.319
Okay, we don't need the sound.

00:05:34.720 --> 00:05:36.960
It's okay, I can skip it.

00:05:38.520 --> 00:05:41.917
So what you were supposed to see from this video is

00:05:42.000 --> 00:05:44.520
how the player reacts to the game.

00:05:44.960 --> 00:05:46.199
The player, if you could hear it,

00:05:46.639 --> 00:05:49.357
is swearing and giving comments

00:05:49.440 --> 00:05:51.200
as if he's inside the game.

00:05:51.800 --> 00:05:54.357
And this is part of the reason why

00:05:54.440 --> 00:05:57.799
the gaming industry leads the software world

00:05:58.880 --> 00:06:00.599
when it comes to performance.

00:06:00.880 --> 00:06:03.760
Because they need to make sure that

00:06:04.280 --> 00:06:07.480
the user gets the best experience it can have.

00:06:08.080 --> 00:06:10.717
If the user does not get the best experience,

00:06:10.800 --> 00:06:12.080
let's say you have junk,

00:06:12.479 --> 00:06:14.120
like the animation is jumpy,

00:06:14.720 --> 00:06:17.477
so he won't swear at the creatures of the game,

00:06:17.560 --> 00:06:20.560
he would swear at the developer of the game.

00:06:20.840 --> 00:06:24.040
And you don't want someone swearing at you.

00:06:24.800 --> 00:06:27.116
So this is a little bit about motivation,

00:06:27.199 --> 00:06:29.197
about design patterns,

00:06:29.280 --> 00:06:30.357
why you shouldn't be afraid of it

00:06:30.440 --> 00:06:32.520
because you're actually using it all the time.

00:06:33.120 --> 00:06:35.640
And gaming, why learn from gaming?

00:06:37.039 --> 00:06:39.997
I'll have references to the gaming industry

00:06:40.080 --> 00:06:41.440
as we go along.

00:06:42.080 --> 00:06:43.720
A few points to consider,

00:06:44.000 --> 00:06:49.396
there's a kind of triangle of points to consider

00:06:49.479 --> 00:06:52.197
when you want to use some design pattern

00:06:52.280 --> 00:06:53.600
or any solution.

00:06:53.960 --> 00:06:55.077
It's true for any solution.

00:06:55.160 --> 00:06:57.240
You should consider architecture.

00:06:57.360 --> 00:07:01.359
And architecture stands for reusability.

00:07:02.440 --> 00:07:05.197
My former talk was about web components,

00:07:05.280 --> 00:07:07.199
reusable components,

00:07:08.360 --> 00:07:10.277
or clean code and stuff like that

00:07:10.360 --> 00:07:13.079
that architects preach about.

00:07:13.599 --> 00:07:16.757
And sometimes performance collides with that

00:07:16.840 --> 00:07:22.000
because sometimes hard coding something

00:07:22.280 --> 00:07:24.159
is the most performant thing to do.

00:07:24.800 --> 00:07:27.239
So at performant sensitive places,

00:07:27.680 --> 00:07:29.560
you'll ditch the architecture aside

00:07:29.759 --> 00:07:32.319
and do something that looks kind of nasty,

00:07:33.319 --> 00:07:35.717
but it will be good for performance.

00:07:35.800 --> 00:07:37.319
And of course, you have deadlines.

00:07:37.720 --> 00:07:39.956
Most of us or all of us have deadlines

00:07:40.039 --> 00:07:41.437
because we work at a company

00:07:41.520 --> 00:07:42.516
that needs to make money

00:07:42.599 --> 00:07:44.396
and we need to deliver eventually.

00:07:44.479 --> 00:07:45.956
So you have to consider these

00:07:46.039 --> 00:07:47.836
or put them in the back of your head

00:07:47.919 --> 00:07:52.040
when you're considering a solution.

00:07:52.400 --> 00:07:57.080
Okay, so let's jump into the actual design patterns.

00:07:57.560 --> 00:07:59.239
The first stop will be memory

00:07:59.560 --> 00:08:02.277
and I'll explain a bit about the problems we have.

00:08:02.360 --> 00:08:05.880
So this is a picture from a game called Star Control.

00:08:06.440 --> 00:08:08.917
And you can see all the explosions around this ship

00:08:09.000 --> 00:08:11.556
and this ship firing the laser bursts

00:08:11.639 --> 00:08:13.600
or whatever they are.

00:08:16.280 --> 00:08:21.277
And almost every pixel can be a class

00:08:21.360 --> 00:08:23.279
that is instantiated.

00:08:24.280 --> 00:08:27.040
And if it would have been done naively,

00:08:27.400 --> 00:08:28.757
this could have been a problem

00:08:28.840 --> 00:08:30.040
and we'll soon see why.

00:08:30.879 --> 00:08:33.200
In order to understand the problem,

00:08:33.719 --> 00:08:38.360
I'll remind you some computer science terms.

00:08:38.640 --> 00:08:40.320
Allocation is the first one.

00:08:41.000 --> 00:08:42.640
So we have some data in memory

00:08:42.839 --> 00:08:44.997
and we want to create an array with five members.

00:08:45.080 --> 00:08:47.480
So it finds a place in memory

00:08:47.680 --> 00:08:50.880
and then we want to push to the array another element.

00:08:51.240 --> 00:08:53.677
So it needs to allocate a place in memory

00:08:53.760 --> 00:08:55.479
for this element.

00:08:55.959 --> 00:08:58.120
So this is allocation.

00:08:58.320 --> 00:09:01.037
And fragmentation happens when we delete something.

00:09:01.120 --> 00:09:03.240
So we have a cool thing and we instantiate it,

00:09:04.000 --> 00:09:05.517
a lousy thing that we instantiate,

00:09:05.600 --> 00:09:06.720
another cool thing,

00:09:06.839 --> 00:09:10.439
and then we delete the lousy thing.

00:09:11.519 --> 00:09:14.000
And we have a hole in memory.

00:09:14.640 --> 00:09:16.399
And this is a fragmented memory.

00:09:16.600 --> 00:09:19.756
If anyone remembers the defrag software

00:09:19.839 --> 00:09:22.880
from Windows 7 or XP,

00:09:23.880 --> 00:09:26.280
so this is it just in RAM.

00:09:27.040 --> 00:09:28.680
And why is it bad?

00:09:29.440 --> 00:09:31.440
Because allocation takes time.

00:09:33.399 --> 00:09:35.357
And fragmentation makes it worse

00:09:35.440 --> 00:09:37.597
because now it needs to find a place in memory

00:09:37.680 --> 00:09:40.397
and sometimes the fragment doesn't really fit

00:09:40.480 --> 00:09:43.680
to what we need and we need to sometimes even defrag.

00:09:44.200 --> 00:09:46.600
And it makes the allocation worse.

00:09:47.200 --> 00:09:50.120
And what's very relevant to us

00:09:50.360 --> 00:09:52.120
is garbage collection.

00:09:52.440 --> 00:09:54.797
When we delete something in JavaScript,

00:09:54.880 --> 00:09:57.000
an object or whatever,

00:09:57.640 --> 00:09:59.440
it is being garbage collected.

00:10:00.360 --> 00:10:02.077
And garbage collection is the process

00:10:02.160 --> 00:10:04.797
that runs periodically and cleans up our memory

00:10:04.880 --> 00:10:07.800
from unneeded objects.

00:10:08.240 --> 00:10:10.599
And it also takes time.

00:10:11.279 --> 00:10:12.839
So let's see some code.

00:10:13.640 --> 00:10:14.520
Hope it'll work.

00:10:14.680 --> 00:10:15.880
Let's see.

00:10:19.920 --> 00:10:23.316
So what's the problem with garbage collection?

00:10:23.399 --> 00:10:25.519
So we'll go to the performance tab.

00:10:26.279 --> 00:10:28.240
And let's see what the code does.

00:10:31.040 --> 00:10:34.680
So our code has this demo class.

00:10:35.680 --> 00:10:38.717
And what it does, it instantiates the class

00:10:38.800 --> 00:10:41.756
a thousand times, four thousand times,

00:10:41.839 --> 00:10:45.277
and it does that ten times.

00:10:45.360 --> 00:10:53.040
So it's ten million instantiations and deletions.

00:10:54.079 --> 00:10:58.917
Let's see what happens when I do these all

00:10:59.000 --> 00:11:00.556
instantiations and deletions.

00:11:00.639 --> 00:11:02.720
So I start recording.

00:11:03.000 --> 00:11:05.040
I do create and destroy.

00:11:05.480 --> 00:11:07.959
And we see that it took around two seconds to run,

00:11:08.279 --> 00:11:09.160
pretty fast.

00:11:09.760 --> 00:11:12.600
But I see below here, can you see it on screen?

00:11:12.720 --> 00:11:13.120
Yeah.

00:11:13.839 --> 00:11:17.999
All these GC, garbage collection instances.

00:11:18.279 --> 00:11:20.917
And we see that the whole thing took us two seconds.

00:11:21.000 --> 00:11:22.239
It might be too much.

00:11:22.600 --> 00:11:24.679
But can we solve it?

00:11:25.519 --> 00:11:27.519
Let's see.

00:11:28.440 --> 00:11:38.237
So the solution would be to use something that's called

00:11:38.320 --> 00:11:40.960
a design pattern called an object pool.

00:11:42.279 --> 00:11:45.957
An object pool is, in essence, to create an array of

00:11:46.040 --> 00:11:48.959
the objects that you intend to instantiate.

00:11:49.079 --> 00:11:53.477
And instead of instantiating them dynamically during

00:11:53.560 --> 00:11:56.196
the for loop, you do it before the for loop,

00:11:56.279 --> 00:11:58.759
or even when your application loads.

00:11:59.920 --> 00:12:03.316
And then you don't need to do all these memory

00:12:03.399 --> 00:12:08.039
allocation and garbage collection stuff.

00:12:08.639 --> 00:12:14.000
So let's look at the code again.

00:12:17.199 --> 00:12:19.280
This create and destroy was the naive way.

00:12:20.040 --> 00:12:23.040
And below, we have the create with a pool.

00:12:23.600 --> 00:12:25.840
And you can see that before I start the whole

00:12:26.519 --> 00:12:29.996
operation, I actually instantiate a pool with

00:12:30.079 --> 00:12:31.880
a thousand demos.

00:12:32.480 --> 00:12:36.240
And what I do here is I ask for a free demo.

00:12:37.880 --> 00:12:39.840
I do what I want with it.

00:12:40.680 --> 00:12:42.077
And then I release everything.

00:12:42.160 --> 00:12:45.116
I tell it just release the object that I don't

00:12:45.199 --> 00:12:46.720
need it anymore.

00:12:49.800 --> 00:12:52.637
So let's see what's the difference would be now

00:12:52.720 --> 00:12:54.277
when I'm using this method.

00:12:54.360 --> 00:12:56.800
So I'll just delete that, let's garbage collect

00:12:57.079 --> 00:12:59.280
everything, and start recording.

00:13:00.360 --> 00:13:02.357
So I create with a pool, and you can see that

00:13:02.440 --> 00:13:07.319
it took like four times faster.

00:13:07.839 --> 00:13:11.159
Might be even more.

00:13:13.399 --> 00:13:15.237
You can see that with the pool, it took like

00:13:15.320 --> 00:13:16.400
half a second.

00:13:16.800 --> 00:13:18.996
And without the pool, it took us in the last time

00:13:19.079 --> 00:13:21.079
two seconds, and now three seconds.

00:13:21.519 --> 00:13:24.160
And it's clearly faster with the pool.

00:13:24.600 --> 00:13:26.556
But let's look at the difference in the

00:13:26.639 --> 00:13:27.520
performance tool.

00:13:28.560 --> 00:13:31.679
Without the pool, we still have the minor GC.

00:13:32.680 --> 00:13:36.477
And with the pool, we actually made the garbage

00:13:36.560 --> 00:13:38.600
collection disappear.

00:13:38.800 --> 00:13:41.037
And this is a very important thing to notice that

00:13:41.120 --> 00:13:44.320
we can actually improve the performance in our

00:13:44.440 --> 00:13:48.360
application and save on CPU time and memory

00:13:49.000 --> 00:13:57.280
and make animations even better for our users.

00:14:02.160 --> 00:14:05.440
So to summarize, when to use this?

00:14:06.000 --> 00:14:08.397
When you have a lot of objects of the same type

00:14:08.480 --> 00:14:12.640
or class that you instantiate and delete a lot.

00:14:12.880 --> 00:14:15.037
For instance, if you have a socket connection

00:14:15.120 --> 00:14:18.477
that brings in a lot of updates to your application,

00:14:18.560 --> 00:14:20.477
some of them are create commands,

00:14:20.560 --> 00:14:21.517
some of them are deletes,

00:14:21.600 --> 00:14:26.399
some of them are updates to existing objects.

00:14:27.279 --> 00:14:28.560
But this can save you a lot.

00:14:29.240 --> 00:14:33.277
And you should actually see even reduction

00:14:33.360 --> 00:14:35.316
in cloud costs because as I showed you,

00:14:35.399 --> 00:14:37.200
you actually save on CPU time.

00:14:37.720 --> 00:14:39.600
And let's say you're using Lambda,

00:14:39.720 --> 00:14:41.556
you actually pay for the time you're using

00:14:41.639 --> 00:14:44.319
the CPU or the machine.

00:14:44.759 --> 00:14:47.277
And this can actually save you a lot of time,

00:14:47.360 --> 00:14:50.919
especially when you scale.

00:14:51.759 --> 00:14:54.399
So we saw the pros in this.

00:14:54.880 --> 00:14:58.316
The cons are that as you saw in the code

00:14:58.399 --> 00:15:00.480
that we're now not using arrays.

00:15:00.680 --> 00:15:03.159
So a new developer needs to learn the API

00:15:03.360 --> 00:15:05.600
for the pool you created, for instance.

00:15:06.079 --> 00:15:08.637
So in terms of architecture,

00:15:08.720 --> 00:15:12.077
you need to actually build some mechanism

00:15:12.160 --> 00:15:14.199
and then teach your developers how to use it.

00:15:14.440 --> 00:15:15.756
And this can be cumbersome.

00:15:15.839 --> 00:15:18.196
So always monitor and see if you really need

00:15:18.279 --> 00:15:19.120
this solution.

00:15:19.240 --> 00:15:20.760
Now it helps you.

00:15:21.440 --> 00:15:23.320
And you can read more in this link.

00:15:23.800 --> 00:15:24.797
It's a link to my blog.

00:15:24.880 --> 00:15:26.436
I've written a few articles about it

00:15:26.519 --> 00:15:28.880
with some more use cases that you can see

00:15:29.120 --> 00:15:33.960
and see if it fits to your needs.

00:15:35.440 --> 00:15:39.639
The second station in our machine would be the bus.

00:15:40.319 --> 00:15:41.079
What is the bus?

00:15:41.720 --> 00:15:44.280
Before that, let's see a problem

00:15:45.399 --> 00:15:48.559
and why we need this next solution.

00:15:48.920 --> 00:15:51.436
So according to Moore's law,

00:15:51.519 --> 00:15:56.157
our machines getting much faster every year,

00:15:56.240 --> 00:15:58.719
every month even, some would say.

00:15:59.040 --> 00:16:03.079
But the CPU gets a lot faster than our memory.

00:16:03.519 --> 00:16:07.876
And that means that if the CPU relies on things

00:16:07.959 --> 00:16:12.440
in memory, it will slow us down.

00:16:13.120 --> 00:16:14.556
So this is the system.

00:16:14.639 --> 00:16:16.556
So we have the CPU, we have the memory,

00:16:16.639 --> 00:16:18.316
and we have the bus that brings data

00:16:18.399 --> 00:16:21.160
from the memory to the CPU.

00:16:22.880 --> 00:16:25.320
And we said that the memory is slow.

00:16:25.480 --> 00:16:28.277
So what happens in modern machines,

00:16:28.360 --> 00:16:31.120
we have the cache memory inside the CPU.

00:16:31.800 --> 00:16:34.917
And what the cache memory is actually is that

00:16:35.000 --> 00:16:37.239
the CPU requires memory from,

00:16:38.160 --> 00:16:40.480
tells the bus to bring something from the memory.

00:16:40.600 --> 00:16:43.116
The bus goes to the memory and brings the memory

00:16:43.199 --> 00:16:46.559
the CPU required plus a little bit from the sides.

00:16:47.279 --> 00:16:49.440
Because the memory is kind of a big array.

00:16:49.759 --> 00:16:53.316
So it goes to the address that the CPU required

00:16:53.399 --> 00:16:55.157
and takes a little bit from the side.

00:16:55.240 --> 00:16:57.120
You can think about it as an array.

00:16:57.720 --> 00:17:01.116
And that's all good and well.

00:17:01.199 --> 00:17:04.159
But sometimes the cache misses.

00:17:04.839 --> 00:17:06.879
And that's called the cache miss.

00:17:07.559 --> 00:17:09.359
And it happens in this case.

00:17:09.839 --> 00:17:11.920
So this is the memory that we need in the CPU,

00:17:12.600 --> 00:17:15.319
and it starts to process the data.

00:17:15.720 --> 00:17:17.756
Then it finds out that it needs this part

00:17:17.839 --> 00:17:19.680
of the memory as well.

00:17:20.439 --> 00:17:22.637
So it looks at the cache,

00:17:22.720 --> 00:17:24.437
but the cache limit is here.

00:17:24.520 --> 00:17:26.880
So the cache missed the data that we need.

00:17:27.439 --> 00:17:29.836
And now the CPU needs to wait until the bus goes

00:17:29.919 --> 00:17:32.797
to the slow memory and brings the missing data,

00:17:32.880 --> 00:17:34.920
and then it continues.

00:17:35.480 --> 00:17:37.797
So we actually, the CPU set idle

00:17:37.880 --> 00:17:42.360
for a few even microseconds or I don't know.

00:17:42.960 --> 00:17:45.117
But it has a big effect,

00:17:45.200 --> 00:17:46.956
especially when you're developing a game

00:17:47.039 --> 00:17:48.917
that needs to run really fast

00:17:49.000 --> 00:17:51.440
or an application when you scale up

00:17:51.640 --> 00:17:56.160
and you really need things to move very fast.

00:17:57.159 --> 00:17:58.476
But you're a JavaScript developer.

00:17:58.559 --> 00:17:59.476
What, why should you care?

00:17:59.559 --> 00:18:01.280
You're running the browser or in Node.js

00:18:01.840 --> 00:18:03.557
or in Electron or whatever.

00:18:03.640 --> 00:18:06.797
But let's see a website that might tell you something.

00:18:06.880 --> 00:18:08.840
Anyone knows this website?

00:18:09.280 --> 00:18:11.479
Raise your hand if you know this website.

00:18:11.919 --> 00:18:12.920
Yeah. jsPerf.

00:18:13.640 --> 00:18:17.600
It's a website to measure performance,

00:18:17.799 --> 00:18:21.437
to compare scripts and their performance.

00:18:21.520 --> 00:18:23.640
So if you look at the bottom one,

00:18:23.799 --> 00:18:27.439
this is actually running over an array

00:18:28.520 --> 00:18:29.560
in the simple way.

00:18:32.480 --> 00:18:35.480
And this one is running on the same array,

00:18:35.919 --> 00:18:40.240
but every thousandth index.

00:18:40.360 --> 00:18:43.557
So you run at 0, 1000, 2000, and so on.

00:18:43.640 --> 00:18:47.919
And then 1001, 2001, and so on.

00:18:48.679 --> 00:18:51.320
And you can see that this one is slower by 90%.

00:18:53.919 --> 00:18:55.280
And how does this happen?

00:18:56.440 --> 00:18:59.840
Because the CPU runs on your array,

00:19:00.360 --> 00:19:01.557
and then it runs on,

00:19:01.640 --> 00:19:05.039
it needs to get to the thousands index

00:19:05.400 --> 00:19:07.160
after being in the zero,

00:19:07.320 --> 00:19:08.600
but it's not in its cache.

00:19:09.200 --> 00:19:11.277
So it need to ask the bus to bring it

00:19:11.360 --> 00:19:13.237
the thousand index, and it's waiting.

00:19:13.320 --> 00:19:15.197
Then it needs the 2000s,

00:19:15.280 --> 00:19:16.640
and it's not in its cache now.

00:19:16.840 --> 00:19:19.917
So it needs to send the bus almost every iteration

00:19:20.000 --> 00:19:22.079
to bring the data and just sits idle.

00:19:22.520 --> 00:19:25.557
And this is how cache miss can affect

00:19:25.640 --> 00:19:26.880
your JavaScript code.

00:19:29.080 --> 00:19:31.199
So go local with your code,

00:19:31.760 --> 00:19:38.920
and we'll see an example for this.

00:19:40.080 --> 00:19:46.520
So let's look at the code.

00:19:47.559 --> 00:19:49.716
So this is the exact same code I showed before.

00:19:49.799 --> 00:19:51.520
Let's see it in time.

00:19:52.200 --> 00:19:53.877
And there is another use case here

00:19:53.960 --> 00:19:56.159
that I'd like you to see.

00:19:56.919 --> 00:19:58.399
So let's run the locality.

00:19:58.840 --> 00:20:01.076
So when we're running it with local,

00:20:01.159 --> 00:20:05.596
we see it takes around 600 milliseconds.

00:20:05.679 --> 00:20:07.277
And then when we run it not local,

00:20:07.360 --> 00:20:10.599
it takes 3½ seconds.

00:20:11.039 --> 00:20:12.877
And this is the sorted example.

00:20:12.960 --> 00:20:16.437
It shows you how important it is to access data

00:20:16.520 --> 00:20:18.076
that is closer in memory

00:20:18.159 --> 00:20:20.640
in order to improve performance in this case.

00:20:21.320 --> 00:20:26.080
The non-local sorted is actually the same array.

00:20:26.799 --> 00:20:28.080
Only I sorted it.

00:20:28.720 --> 00:20:33.040
So let's say that the 0, the thousand,

00:20:33.159 --> 00:20:36.360
and the one and all these objects

00:20:36.720 --> 00:20:41.720
were closer to each other in memory.

00:20:42.240 --> 00:20:45.596
So this is how you can improve the speed.

00:20:45.679 --> 00:20:49.040
So if you make sure to sort your arrays all the time

00:20:49.799 --> 00:20:53.600
and make sure the objects that are closer in memory,

00:20:54.799 --> 00:20:57.877
that objects that you need to process together

00:20:57.960 --> 00:21:00.200
are closer in memory,

00:21:00.960 --> 00:21:03.637
that would actually save you a lot of time

00:21:03.720 --> 00:21:05.680
and CPU cycles.

00:21:05.919 --> 00:21:13.840
So your code would run faster.

00:21:14.360 --> 00:21:17.080
Okay, let's summarize when to use it.

00:21:17.559 --> 00:21:19.679
You'll use it when you have a lot of data.

00:21:20.880 --> 00:21:24.557
Actually, cache I think is around 64 kilobytes.

00:21:24.640 --> 00:21:26.557
So you don't really need a lot of data.

00:21:26.640 --> 00:21:29.800
You just need to run a lot of times over the data.

00:21:30.400 --> 00:21:33.600
For instance, if you have a change detector,

00:21:33.880 --> 00:21:35.640
like in Angular.

00:21:39.240 --> 00:21:41.000
And you want to save on CPU time,

00:21:41.400 --> 00:21:46.039
and you want to make your application much faster.

00:21:47.480 --> 00:21:49.080
The pros, I just showed you.

00:21:49.559 --> 00:21:50.836
You'll have a better performance,

00:21:50.919 --> 00:21:53.557
but the cons is that you'll need to create a mechanism

00:21:53.640 --> 00:21:57.200
to make sure your objects are closer in memory.

00:21:58.679 --> 00:22:02.357
And this can be costly because sorting is also costly.

00:22:02.440 --> 00:22:06.520
So you have to monitor and see if it works for you.

00:22:06.720 --> 00:22:09.080
You can enter the live example I just showed you

00:22:09.559 --> 00:22:11.400
and test for yourself.

00:22:11.760 --> 00:22:13.159
And you can read more again.

00:22:13.520 --> 00:22:20.277
I've written about data locality and some more use cases

00:22:20.360 --> 00:22:24.760
for this if you'd like to see.

00:22:25.520 --> 00:22:29.596
Okay, the last one we'll talk about today is in gaming.

00:22:29.679 --> 00:22:32.960
It's very much related to GPU.

00:22:34.039 --> 00:22:37.360
In JavaScript, we also use it in GPU when you use WebGL.

00:22:37.960 --> 00:22:41.677
But for most use cases, it will be relevant for bandwidth

00:22:41.760 --> 00:22:45.120
and memory, and we'll soon see why.

00:22:45.880 --> 00:22:49.076
So the problem here is in gaming is that we have

00:22:49.159 --> 00:22:54.476
a repeating scenery with a lot of similar properties.

00:22:54.559 --> 00:22:56.920
For instance, if you look at the fans in this game,

00:22:57.480 --> 00:23:00.237
they'll kind of look similar with, I don't know,

00:23:00.320 --> 00:23:01.877
just the shirt is a bit different,

00:23:01.960 --> 00:23:03.959
the position is a bit different,

00:23:04.159 --> 00:23:07.199
but the mesh and the texture are kind of the same.

00:23:07.640 --> 00:23:10.320
And you can see here the trees in the background.

00:23:10.440 --> 00:23:12.517
They're all kind of the same with, you know,

00:23:12.600 --> 00:23:14.997
a little bit different branching,

00:23:15.080 --> 00:23:19.119
maybe a little bit tint in the color and stuff like that.

00:23:20.159 --> 00:23:22.997
And let's focus on the fans again.

00:23:23.080 --> 00:23:26.120
So if I take a fan and I call it a person,

00:23:26.559 --> 00:23:33.080
I can naively save it like this with all the properties

00:23:33.760 --> 00:23:34.240
inside.

00:23:34.880 --> 00:23:36.320
And then I have something like this.

00:23:36.520 --> 00:23:38.117
So I have mesh, shirt, head, scarf,

00:23:38.200 --> 00:23:41.757
and some params that are the actual unique parameters

00:23:41.840 --> 00:23:43.720
for the person.

00:23:44.240 --> 00:23:47.240
But maybe a better way to do it would be to take

00:23:47.480 --> 00:23:51.997
the person model outside, which is the common stuff.

00:23:52.080 --> 00:23:58.076
It's called the intrinsic properties and just inject it

00:23:58.159 --> 00:24:01.476
to the person and keep the extrinsic properties,

00:24:01.559 --> 00:24:03.800
which are the unique, inside the person.

00:24:03.960 --> 00:24:06.079
And then I have something like this.

00:24:07.600 --> 00:24:12.039
And this I get by reference and I save on memory.

00:24:12.559 --> 00:24:16.000
So this is called the flyweight design pattern.

00:24:16.440 --> 00:24:20.360
And we use it in several ways in production, actually,

00:24:20.640 --> 00:24:23.200
at WalkMe and even in other places.

00:24:23.760 --> 00:24:28.076
For instance, WalkMe allows users to get search results

00:24:28.159 --> 00:24:31.840
from various search providers.

00:24:32.120 --> 00:24:34.316
And search providers get us a lot of results,

00:24:34.399 --> 00:24:38.280
and a lot of the objects that we get have similar

00:24:39.279 --> 00:24:40.159
properties.

00:24:40.440 --> 00:24:43.757
For instance, Google sends us stuff and all of the stuff

00:24:43.840 --> 00:24:47.479
have common properties.

00:24:47.679 --> 00:24:50.277
So what we do is we create a Google model, Bing model,

00:24:50.360 --> 00:24:52.160
and Yahoo model for instance,

00:24:52.360 --> 00:24:56.596
and all the search results refer to the common properties.

00:24:56.679 --> 00:24:58.400
And then we save memory and bandwidth.

00:25:01.360 --> 00:25:03.120
So let's see some code again.

00:25:03.480 --> 00:25:07.080
This will be the last example.

00:25:07.520 --> 00:25:10.397
So here I have the request data and request

00:25:10.480 --> 00:25:12.160
the flyweight data.

00:25:13.640 --> 00:25:17.199
So let's look at the network first.

00:25:17.799 --> 00:25:18.560
Let's do it anew.

00:25:19.720 --> 00:25:22.357
So I request the data and I request the lightweight data,

00:25:22.440 --> 00:25:29.437
and I see that I save around 70 kilobytes.

00:25:29.520 --> 00:25:31.640
It might sound not too much,

00:25:31.760 --> 00:25:33.920
but this example is very simple,

00:25:34.080 --> 00:25:35.476
and probably in your application,

00:25:35.559 --> 00:25:37.920
you have more complex data.

00:25:38.760 --> 00:25:42.279
In addition, imagine that you have customers or users

00:25:42.840 --> 00:25:44.760
with slow internet connection.

00:25:44.880 --> 00:25:47.797
And these 70 kilobytes can be the difference between

00:25:47.880 --> 00:25:52.760
page loads in two seconds or page loads in a second.

00:25:54.720 --> 00:25:57.440
Another thing is, let's go to the memory.

00:25:57.960 --> 00:26:00.520
I'll just request the data.

00:26:01.200 --> 00:26:04.840
And then I'll request the flyweight data.

00:26:05.520 --> 00:26:07.319
And then I'll compare between them.

00:26:07.919 --> 00:26:16.716
And I see that the flyweight took 160 kilobytes less

00:26:16.799 --> 00:26:19.920
than the regular data.

00:26:20.679 --> 00:26:23.239
So I save both on bandwidth and memory.

00:26:23.679 --> 00:26:25.720
And again, this is a very simple example.

00:26:33.919 --> 00:26:35.279
Okay, so when to use it?

00:26:36.200 --> 00:26:39.716
When we have a lot of objects with common properties,

00:26:39.799 --> 00:26:42.000
and we can save memory and bandwidth.

00:26:42.200 --> 00:26:46.279
And I didn't mention how you use it with WebGL,

00:26:46.399 --> 00:26:48.517
but it can save you a lot with WebGL.

00:26:48.600 --> 00:26:51.999
You can look at libraries like CesiumJS, for instance.

00:26:52.279 --> 00:26:53.120
Pros and cons.

00:26:53.679 --> 00:26:54.797
The pros I just showed you.

00:26:54.880 --> 00:26:57.637
The cons is that you again need to build a mechanism

00:26:57.720 --> 00:27:03.560
to match the common properties to the unique.

00:27:04.080 --> 00:27:06.277
And you can read more about it again in my blog.

00:27:06.360 --> 00:27:08.757
I actually explain how to build one such mechanism

00:27:08.840 --> 00:27:13.719
if you'd like to see, and some use cases we use it.

00:27:14.559 --> 00:27:17.120
So to summarize, we went over the motivation,

00:27:17.320 --> 00:27:21.639
why to use, or when and when not to use design patterns.

00:27:21.919 --> 00:27:24.760
I didn't stress it enough that you need to monitor.

00:27:24.919 --> 00:27:27.557
Always monitor to see if the solution is good for you

00:27:27.640 --> 00:27:30.280
and if it's working and if it's worth the effort.

00:27:31.080 --> 00:27:34.677
I highly recommend this book, "Game Programming Patterns".

00:27:34.760 --> 00:27:35.797
It's actually a free book.

00:27:35.880 --> 00:27:38.000
You can read it online.

00:27:38.840 --> 00:27:40.520
It's one of the best I've seen.

00:27:41.120 --> 00:27:42.557
And you can also read at my blog.

00:27:42.640 --> 00:27:46.759
I write a lot about performance and how you can improve it.

00:27:47.519 --> 00:27:48.080
Thank you.

00:27:48.760 --> 00:27:51.119
Thank you so much.

00:27:51.799 --> 00:27:53.240
Thank you very much, Mr. Kra.

00:27:53.760 --> 00:27:56.680
So, ladies and gentlemen, if you like to talk to Mr. Kra

00:27:57.120 --> 00:27:59.757
personally, he will be, after this session,

00:27:59.840 --> 00:28:02.040
he will be at the Q&A room.

00:28:02.279 --> 00:28:05.397
The Q&A room is, once you get out of the theater,

00:28:05.480 --> 00:28:07.640
on your right-hand side is the Q&A room.