WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:46.199 --> 00:00:49.039
And right now, ladies and gentlemen, with the next topic,

00:00:49.239 --> 00:00:52.919
Adventures with the Event Loop by Erin Zimmer,

00:00:53.359 --> 00:00:57.439
Senior Engineer and Thought Leader from Shine Solutions Australia!

00:01:20.960 --> 00:01:21.120
Hi.

00:01:21.680 --> 00:01:24.839
For some reason, I insist on using weird versions of OSes

00:01:24.960 --> 00:01:27.200
when I'm going to give talks in strange places.

00:01:27.520 --> 00:01:28.437
I don't.

00:01:28.520 --> 00:01:30.680
All right, so today we're going to talk about the event loop,

00:01:31.159 --> 00:01:34.520
which is a pretty important part of how JavaScript works.

00:01:39.560 --> 00:01:39.720
No.

00:01:48.640 --> 00:01:50.517
Maybe we're just going to look at this picture of a dinosaur.

00:01:50.600 --> 00:01:52.920
That's fun, too.

00:01:54.119 --> 00:01:55.716
The screen's not in focus,

00:01:55.799 --> 00:01:58.559
so the clicker's not receiving the clicks.

00:02:00.240 --> 00:02:05.880
Just this one?

00:02:06.079 --> 00:02:06.237
All right.

00:02:06.320 --> 00:02:07.917
I'm going to stand behind the lectern and do this.

00:02:08.000 --> 00:02:08.799
It's going to be fun.

00:02:09.319 --> 00:02:09.596
All right.

00:02:09.679 --> 00:02:11.439
My name is Erin Zimmer.

00:02:12.080 --> 00:02:15.600
I work for a consulting company in Melbourne called Shine Solutions.

00:02:15.800 --> 00:02:19.880
I am both a Mozilla Tech Speaker and a Google Developer Expert.

00:02:20.400 --> 00:02:23.400
And I'm available on Twitter if you would like to talk about

00:02:23.599 --> 00:02:27.719
the event loop or things going wrong in tech or anything like that.

00:02:28.319 --> 00:02:29.919
And if you'd like to play along at home,

00:02:30.120 --> 00:02:32.480
these slides are available at event-loop.ez.codes.

00:02:33.040 --> 00:02:33.796
I will warn you though,

00:02:33.879 --> 00:02:38.240
I built all the demos using web components with HTML imports,

00:02:38.680 --> 00:02:40.880
which seemed like a good idea at the time,

00:02:41.480 --> 00:02:44.519
and isn't supported in any browser except for Chrome

00:02:44.720 --> 00:02:47.080
up to the current one.

00:02:47.840 --> 00:02:48.197
Cool.

00:02:48.280 --> 00:02:49.999
So, what even is the event loop?

00:02:50.360 --> 00:02:53.239
So, the event loop is basically the part of the browser

00:02:53.599 --> 00:02:56.400
that controls when your JavaScript runs.

00:02:57.000 --> 00:02:59.680
So, if we have a page that's being loaded over the web,

00:03:00.360 --> 00:03:02.360
this one is actually Twitter.

00:03:02.720 --> 00:03:04.520
When the browser receives the HTML,

00:03:04.959 --> 00:03:06.320
it's going to parse the HTML

00:03:06.519 --> 00:03:08.639
and it's going to build the Document Object Model.

00:03:09.159 --> 00:03:10.760
It's going to parse all the styles

00:03:11.200 --> 00:03:13.560
and build the CSS Object Model.

00:03:14.080 --> 00:03:15.960
And whenever it runs into a script tag,

00:03:16.480 --> 00:03:19.397
whether it's an inline script or an external script,

00:03:19.480 --> 00:03:22.799
it's going to stop what it's doing and immediately run that script.

00:03:24.159 --> 00:03:26.600
None of that has anything to do with the event loop.

00:03:27.200 --> 00:03:30.516
And if that was the only JavaScript that we ever ran on a page,

00:03:30.599 --> 00:03:33.320
this talk would be very short.

00:03:34.159 --> 00:03:35.160
But as it turns out,

00:03:35.280 --> 00:03:37.757
most of the JavaScript that we write in that initial stage

00:03:37.840 --> 00:03:41.240
is actually setting up JavaScript that we're going to run later.

00:03:41.840 --> 00:03:44.040
So, it could be stuff like a timer,

00:03:44.439 --> 00:03:47.919
which is going to just run a bit of JavaScript in the future.

00:03:48.439 --> 00:03:49.997
It could be an event listener,

00:03:50.080 --> 00:03:51.996
which is going to wait for the user to perform

00:03:52.079 --> 00:03:53.760
some kind of interaction with the page

00:03:53.879 --> 00:03:56.360
and then run some JavaScript.

00:03:56.560 --> 00:03:58.356
Or it could be something like a network request

00:03:58.439 --> 00:04:00.160
where we're going to use fetch or XHR

00:04:00.840 --> 00:04:03.436
and fetch some resource over the network

00:04:03.519 --> 00:04:05.520
and then run a callback in response to that.

00:04:06.120 --> 00:04:12.159
So, the event loop controls when these things get executed.

00:04:13.000 --> 00:04:14.477
So, this is what it looks like basically.

00:04:14.560 --> 00:04:18.880
We have these, oh no, I can't see my cursor.

00:04:19.400 --> 00:04:19.597
All right.

00:04:19.680 --> 00:04:21.680
We have these inputs.

00:04:21.959 --> 00:04:26.477
So, we have like user interactions, we have timers,

00:04:26.560 --> 00:04:27.960
and we have network requests.

00:04:28.160 --> 00:04:29.396
Each of these things is going to run

00:04:29.479 --> 00:04:33.077
and then once the timer comes back or the network request returns,

00:04:33.160 --> 00:04:35.680
then the browser is going to find the related callback

00:04:35.840 --> 00:04:37.760
and it's going to put it in this queue.

00:04:38.360 --> 00:04:41.960
And the event loop is going to control how this queue is run.

00:04:42.720 --> 00:04:47.600
At its simplest,

00:04:48.360 --> 00:04:49.959
The event loop looks something like this.

00:04:50.240 --> 00:04:51.877
So, if we were to write it in pseudocode,

00:04:51.960 --> 00:04:53.720
it's just a while loop that runs forever.

00:04:54.080 --> 00:04:54.956
Each turn of the loop,

00:04:55.039 --> 00:04:57.760
it's going to grab the first task off the task queue

00:04:58.479 --> 00:04:59.720
and then it's going to run that task.

00:05:00.840 --> 00:05:04.080
If we looked at it with our example from before,

00:05:04.600 --> 00:05:08.676
we can have some events running,

00:05:08.759 --> 00:05:09.959
they're going to go in the queue,

00:05:10.479 --> 00:05:14.160
and the event loop is just going to run them all in order.

00:05:14.680 --> 00:05:14.877
Cool.

00:05:14.960 --> 00:05:16.920
Does that make sense to everybody?

00:05:17.120 --> 00:05:17.437
Yep.

00:05:17.520 --> 00:05:17.917
Good.

00:05:18.000 --> 00:05:25.320
Because it turns out it's a little bit more complicated than that.

00:05:26.000 --> 00:05:28.317
So the event loop runs in conjunction with the

00:05:28.400 --> 00:05:29.600
rendering pipeline.

00:05:30.039 --> 00:05:32.157
The rendering pipeline is responsible for displaying

00:05:32.240 --> 00:05:33.360
what you see on the screen.

00:05:33.479 --> 00:05:35.077
So it's going to take that DOM, it's going to take

00:05:35.160 --> 00:05:37.757
the CSSOM, it's going to build a render tree.

00:05:37.840 --> 00:05:40.037
It's going to turn that into a bitmap and display it

00:05:40.120 --> 00:05:41.519
on the screen.

00:05:42.039 --> 00:05:44.676
The rendering pipeline likes to run once every time

00:05:44.759 --> 00:05:46.119
the screen refreshes.

00:05:46.319 --> 00:05:48.997
So if you've got a 60 hertz monitor, that means it's

00:05:49.080 --> 00:05:50.517
going to run 60 times a second.

00:05:50.600 --> 00:05:54.437
So once every 16 milliseconds.

00:05:54.520 --> 00:05:57.917
Our event loop works with our rendering pipeline

00:05:58.000 --> 00:05:58.599
like this.

00:06:02.319 --> 00:06:05.197
The way that it works is that we can have events

00:06:05.280 --> 00:06:07.439
added to the queue.

00:06:08.039 --> 00:06:11.477
And then the event loop is going to run through those

00:06:11.560 --> 00:06:14.637
events, one at a time until it's time to render,

00:06:14.720 --> 00:06:16.437
when the 16 milliseconds is up, and then it's going

00:06:16.520 --> 00:06:18.080
to go over and do a render.

00:06:18.520 --> 00:06:20.317
Right, so it's going to run task, task, task and

00:06:20.400 --> 00:06:21.360
then run a render.

00:06:21.800 --> 00:06:25.556
The important thing though is that when you're

00:06:25.639 --> 00:06:27.640
running a task from the task queue,

00:06:28.160 --> 00:06:30.116
that task is always going to run start to finish.

00:06:30.199 --> 00:06:31.240
There's no interruption.

00:06:31.680 --> 00:06:34.197
You're guaranteed that if you have a JavaScript task,

00:06:34.280 --> 00:06:37.440
it will finish completion before anything else happens.

00:06:37.880 --> 00:06:40.197
So that means if we're in the middle of a task and

00:06:40.280 --> 00:06:42.040
the rendering pipeline wants to run,

00:06:42.280 --> 00:06:44.319
the rendering pipeline has to wait.

00:06:45.560 --> 00:06:48.556
So if you're writing JavaScript, it's a good idea to

00:06:48.639 --> 00:06:51.399
not have extremely long running tasks.

00:06:51.919 --> 00:06:54.240
If you've got stuff that runs for more than 16

00:06:54.720 --> 00:06:55.637
milliseconds,

00:06:55.720 --> 00:06:57.997
your browser's going to start dropping frames and

00:06:58.080 --> 00:07:00.359
your animations are going to look a bit janky.

00:07:00.520 --> 00:07:02.757
So if you do have long running tasks, either split

00:07:02.840 --> 00:07:04.480
them into smaller tasks,

00:07:05.080 --> 00:07:07.279
or you can use something like a web worker to move

00:07:08.639 --> 00:07:13.640
the processing off the main thread.

00:07:14.160 --> 00:07:16.236
Okay. So now our event loop looks something like this.

00:07:16.319 --> 00:07:17.320
It's an infinite loop.

00:07:17.680 --> 00:07:19.357
For every turn of the loop, we're going to take a

00:07:19.440 --> 00:07:22.480
task off the task queue and run that task.

00:07:23.080 --> 00:07:25.599
Then if it's time to repaint, we're going to repaint.

00:07:26.039 --> 00:07:27.560
Everyone's cool with that?

00:07:28.160 --> 00:07:31.077
Good. Because it turns out, it's a little bit more

00:07:31.160 --> 00:07:32.919
complicated than that.

00:07:33.599 --> 00:07:37.480
See, an event loop can have one or more task queues.

00:07:38.160 --> 00:07:40.920
This is just like the text out of the spec.

00:07:41.520 --> 00:07:42.877
And when I was preparing the talk, I thought what

00:07:42.960 --> 00:07:43.317
I'll do is

00:07:43.400 --> 00:07:46.037
I'll go and find some code in a browser, like an

00:07:46.120 --> 00:07:46.796
open source browser,

00:07:46.879 --> 00:07:48.796
and I'll look at the code and I'll find a browser

00:07:48.879 --> 00:07:51.120
that has one or more task queues

00:07:51.360 --> 00:07:54.357
and I'll show you an example of a real world browser

00:07:54.440 --> 00:07:56.320
that has one or more task queues.

00:07:57.000 --> 00:08:01.360
The thing is though, browsers are written in C++.

00:08:02.120 --> 00:08:04.279
And I'm a front-end developer.

00:08:04.479 --> 00:08:08.637
And as far as I can tell, C++ is mostly just

00:08:08.720 --> 00:08:11.359
punctuation and the word delegate.

00:08:11.639 --> 00:08:14.320
And I don't really know what's going on.

00:08:15.080 --> 00:08:18.277
So instead, we're going to have a theoretical browser

00:08:18.360 --> 00:08:20.480
with multiple task queues.

00:08:21.039 --> 00:08:22.877
This one is actually the example from the spec.

00:08:22.960 --> 00:08:26.600
So I didn't just make it up, somebody else did.

00:08:27.360 --> 00:08:29.320
Okay. So in this browser, we have two queues.

00:08:29.599 --> 00:08:32.477
One queue for user actions and one queue for

00:08:32.560 --> 00:08:33.277
everything else.

00:08:33.360 --> 00:08:34.917
So if we have our user actions, they're going to go

00:08:35.000 --> 00:08:35.999
in one queue.

00:08:36.919 --> 00:08:39.917
And our timer and Wi-Fi actions will go in the other

00:08:40.000 --> 00:08:41.200
queue when they get there.

00:08:41.800 --> 00:08:44.717
This browser prioritizes user interactions.

00:08:44.800 --> 00:08:46.597
So as long as there's anything in the user

00:08:46.680 --> 00:08:47.237
interaction queue,

00:08:47.320 --> 00:08:49.357
it's going to run that before it runs anything in

00:08:49.440 --> 00:08:50.319
the other queue.

00:08:50.839 --> 00:08:52.517
And then the rendering pipeline just works the same

00:08:52.600 --> 00:08:56.600
as normal.

00:08:57.120 --> 00:08:57.477
All right.

00:08:57.560 --> 00:08:59.117
It's not a complete free-for-all with these multiple

00:08:59.200 --> 00:08:59.756
queues though.

00:08:59.839 --> 00:09:00.879
There are a few rules.

00:09:01.399 --> 00:09:04.077
The queues can be executed in any order, so you can

00:09:04.160 --> 00:09:05.720
pick that yourself.

00:09:06.000 --> 00:09:08.677
Tasks in the same queue must be executed in the order

00:09:08.760 --> 00:09:09.477
they arrived.

00:09:09.560 --> 00:09:11.800
So that just means that the queues are queues.

00:09:13.279 --> 00:09:15.517
And finally, tasks from the same source have to go in

00:09:15.600 --> 00:09:16.237
the same queue.

00:09:16.320 --> 00:09:18.237
So in our case, all of the user interactions went in

00:09:18.320 --> 00:09:19.080
the same queue.

00:09:19.440 --> 00:09:21.996
If you're familiar with Node.js, it uses a model like

00:09:22.079 --> 00:09:24.637
this, and all of the timer events go in one queue,

00:09:24.720 --> 00:09:27.840
all of the network events go in another queue.

00:09:30.120 --> 00:09:33.560
So now, our event loop looks like this.

00:09:34.240 --> 00:09:35.440
It's an infinite loop.

00:09:35.800 --> 00:09:37.436
For every turn of the loop, we're going to pick a

00:09:37.519 --> 00:09:37.759
queue.

00:09:38.519 --> 00:09:40.316
Then we're going to take the first task off that

00:09:40.399 --> 00:09:40.879
queue.

00:09:41.399 --> 00:09:42.679
And we're going to run that task.

00:09:43.040 --> 00:09:46.360
Then, if it's time to repaint, we'll repaint.

00:09:46.800 --> 00:09:48.520
So is everybody good with that?

00:09:49.120 --> 00:09:49.440
Cool.

00:09:49.600 --> 00:09:51.996
Because it turns out, it's a little bit more

00:09:52.079 --> 00:09:54.240
complicated than that.

00:09:54.920 --> 00:09:57.720
We also have something called microtasks.

00:09:57.920 --> 00:10:01.920
Now a microtask is a task that happens between tasks,

00:10:02.440 --> 00:10:04.600
which is a bit confusing.

00:10:04.880 --> 00:10:08.200
They're originally created for dealing with mutation

00:10:08.360 --> 00:10:09.160
observers.

00:10:09.360 --> 00:10:13.157
So a mutation observer is an event that gets fired

00:10:13.240 --> 00:10:15.320
when a particular bit of DOM changes.

00:10:15.560 --> 00:10:18.200
So if something gets added to it or removed or

00:10:18.560 --> 00:10:22.440
shuffled around, whatever, you get this event fired.

00:10:23.040 --> 00:10:25.157
The thing with these events though is that when the

00:10:25.240 --> 00:10:27.799
DOM changes, you often want to do something else

00:10:28.200 --> 00:10:30.279
that's also going to change the DOM.

00:10:30.959 --> 00:10:33.316
So that means that you don't want the rendering

00:10:33.399 --> 00:10:36.477
pipeline to run in the middle, else your users are

00:10:36.560 --> 00:10:39.397
going to see that like halfway state between the two

00:10:39.480 --> 00:10:40.040
things.

00:10:40.480 --> 00:10:44.000
So microtasks give us a way to ensure that our

00:10:44.480 --> 00:10:46.797
callback is going to run before the rendering

00:10:46.880 --> 00:10:48.760
pipeline runs again.

00:10:49.560 --> 00:10:52.117
Mutation observers don't get used that much.

00:10:52.200 --> 00:10:54.277
Something that you might be more familiar with though

00:10:54.360 --> 00:10:55.679
is promises.

00:10:55.959 --> 00:10:58.880
So all promise callbacks are microtasks.

00:10:59.800 --> 00:11:02.637
If you happen to really like microtasks, you can

00:11:02.720 --> 00:11:03.919
also just create them.

00:11:04.440 --> 00:11:06.600
Just 𝚠𝚒𝚗𝚍𝚘𝚠.𝚚𝚞𝚎𝚞𝚎𝙼𝚒𝚌𝚛𝚘𝚝𝚊𝚜𝚔 will give you a

00:11:07.760 --> 00:11:08.480
microtask.

00:11:09.040 --> 00:11:10.117
So what does that look like?

00:11:10.200 --> 00:11:12.677
So we have here our two queues from before and our

00:11:12.760 --> 00:11:15.277
microtask queue just on the beside the rendering

00:11:15.360 --> 00:11:16.277
pipeline there.

00:11:16.360 --> 00:11:18.717
And we have our inputs across the top, the ones we

00:11:18.800 --> 00:11:23.320
had from before, plus the microtask queue.

00:11:24.240 --> 00:11:27.320
So say our user runs some tasks, sets some timers,

00:11:27.480 --> 00:11:28.200
whatever.

00:11:28.480 --> 00:11:32.920
And one of these callbacks creates a promise.

00:11:33.360 --> 00:11:37.080
And that's going to go in the microtask queue.

00:11:38.560 --> 00:11:41.556
Now as soon as any task finishes running, the

00:11:41.639 --> 00:11:43.440
microtask queue is going to run.

00:11:44.120 --> 00:11:46.597
Even if the rendering pipeline wanted to run, it has

00:11:46.680 --> 00:11:50.159
to wait until the microtask queue runs.

00:11:50.839 --> 00:11:56.517
If the microtask queue creates more microtasks, then

00:11:56.600 --> 00:11:58.400
all of those are going to run as well.

00:11:59.639 --> 00:12:02.637
So as you can imagine, you can really stuff up the

00:12:02.720 --> 00:12:05.876
rendering if you have microtasks that generate

00:12:05.959 --> 00:12:06.839
microtasks.

00:12:06.959 --> 00:12:11.560
So if your promise callbacks have really long

00:12:12.839 --> 00:12:14.876
callbacks that do a bunch of stuff and run for a

00:12:14.959 --> 00:12:16.717
really long time, it's really going to bugger up

00:12:16.800 --> 00:12:18.520
your rendering.

00:12:18.800 --> 00:12:21.880
So be careful with that.

00:12:26.399 --> 00:12:26.799
Okay.

00:12:27.399 --> 00:12:30.400
So now our event loop looks like this.

00:12:31.000 --> 00:12:32.120
It's an infinite loop.

00:12:32.720 --> 00:12:34.679
For each turn of the loop, we're going to pick a

00:12:34.920 --> 00:12:35.080
queue.

00:12:35.920 --> 00:12:38.357
Then for each queue, we're going to take the first

00:12:38.440 --> 00:12:40.756
task off the queue, and we're going to run that

00:12:40.839 --> 00:12:41.239
task.

00:12:41.839 --> 00:12:44.477
Then as long as there are tasks in the microtask

00:12:44.560 --> 00:12:46.840
queue, we're going to run all of those.

00:12:47.360 --> 00:12:50.957
Then once all of the microtasks are done, then if

00:12:51.040 --> 00:12:54.399
it's time to repaint, we'll repaint.

00:12:54.839 --> 00:12:56.839
Everybody cool with that?

00:12:57.519 --> 00:12:57.919
Cool.

00:12:58.320 --> 00:13:00.717
Because it turns out it's a little bit more

00:13:00.800 --> 00:13:04.000
complicated than that.

00:13:04.680 --> 00:13:07.119
We also have the animation frame callback queue.

00:13:07.959 --> 00:13:09.837
Now you can add something to the animation frame

00:13:09.920 --> 00:13:13.077
callback queue by calling 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎.

00:13:14.440 --> 00:13:16.360
Why would you want to do that?

00:13:17.680 --> 00:13:19.797
Well, you're probably not surprised to learn that

00:13:19.880 --> 00:13:23.840
it's to do with animating things.

00:13:24.360 --> 00:13:33.037
So imagine you have a box, and you want to animate

00:13:33.120 --> 00:13:37.797
it so that it moves across the screen in a sine kind

00:13:37.880 --> 00:13:41.120
of movement.

00:13:41.639 --> 00:13:46.717
If we were to code that naively, we might write

00:13:46.800 --> 00:13:47.637
something like this.

00:13:47.720 --> 00:13:50.517
So it's a loop that's going to run as long as the

00:13:50.600 --> 00:13:53.196
right side of the box hasn't reached the right side

00:13:53.279 --> 00:13:54.119
of the screen.

00:13:54.639 --> 00:13:56.917
For each turn of the loop, we're going to calculate

00:13:57.000 --> 00:13:59.840
how much time has passed since the animation began.

00:14:00.360 --> 00:14:01.756
And then we're going to pass that into some

00:14:01.839 --> 00:14:04.237
functions that are going to calculate the new x and y

00:14:04.320 --> 00:14:06.597
position of the box, and then set the box left and

00:14:06.680 --> 00:14:09.440
top to those new positions.

00:14:09.720 --> 00:14:13.920
If you do this, what you get is this.

00:14:14.600 --> 00:14:16.519
The box just appears at the right-hand side of the

00:14:16.959 --> 00:14:17.439
screen.

00:14:17.959 --> 00:14:19.240
Doesn't animate at all.

00:14:19.839 --> 00:14:21.797
The reason for that is that we've basically done

00:14:21.880 --> 00:14:22.200
this.

00:14:22.680 --> 00:14:25.597
We've created this massive long task that's going to

00:14:25.680 --> 00:14:28.277
keep looping through that loop over and over again

00:14:28.360 --> 00:14:30.637
until it's calculated that the box is at the end of

00:14:30.720 --> 00:14:33.800
the screen, and then it's going to render.

00:14:34.320 --> 00:14:35.996
And because we haven't let it render at any of the

00:14:36.079 --> 00:14:39.840
points in between, we just see the box at the end.

00:14:40.600 --> 00:14:45.237
So what we can do instead is use a recursive

00:14:45.320 --> 00:14:46.996
function and use 𝚜𝚎𝚝𝚃𝚒𝚖𝚎𝚘𝚞𝚝.

00:14:47.079 --> 00:14:48.717
So we're just doing the same thing here, calculating

00:14:48.800 --> 00:14:51.440
the time, getting the box x and y position.

00:14:51.800 --> 00:14:53.357
And then if the box hasn't reached the edge of the

00:14:53.440 --> 00:14:56.157
screen, we're going to call 𝚜𝚎𝚝𝚃𝚒𝚖𝚎𝚘𝚞𝚝, which

00:14:56.240 --> 00:14:58.637
creates a new task, which will be added to the

00:14:58.720 --> 00:15:04.280
queue, and then that's going to move the box.

00:15:05.040 --> 00:15:05.277
Cool.

00:15:05.360 --> 00:15:09.120
So that looks like this.

00:15:09.240 --> 00:15:11.640
We're going to create a task, which creates a new task,

00:15:11.959 --> 00:15:14.720
which creates a new task, which creates a new task,

00:15:15.079 --> 00:15:17.477
which creates a new task, and then the rendering

00:15:17.560 --> 00:15:18.440
pipeline runs.

00:15:19.040 --> 00:15:21.357
So that's going to happen every 16 milliseconds,

00:15:21.440 --> 00:15:24.116
and our box is going to get animated across the screen,

00:15:24.199 --> 00:15:26.960
and everything is going to be delightful.

00:15:27.160 --> 00:15:28.959
Except for two small things.

00:15:31.680 --> 00:15:34.316
First of all, in our application,

00:15:34.399 --> 00:15:35.556
there's nothing else running.

00:15:35.639 --> 00:15:37.957
So we know that our new animation task is going to be

00:15:38.040 --> 00:15:39.556
the first thing on the queue each time.

00:15:39.639 --> 00:15:40.640
It's going to be okay.

00:15:40.920 --> 00:15:42.797
In the real world, a bunch of other stuff could be

00:15:42.880 --> 00:15:45.876
running, which could mean that the animation task

00:15:45.959 --> 00:15:48.239
isn't going to run in every single frame,

00:15:48.639 --> 00:15:50.039
which is going to look a bit crap.

00:15:50.639 --> 00:15:53.159
The other thing is that we're running those tasks

00:15:53.360 --> 00:15:56.200
over and over again, but we're only really using

00:15:56.360 --> 00:15:58.397
the one that runs immediately before the rendering

00:15:58.480 --> 00:15:59.040
pipeline, right?

00:15:59.480 --> 00:16:02.119
So we're wasting a lot of processing power.

00:16:02.360 --> 00:16:04.676
I mean, this particular example doesn't waste that

00:16:04.759 --> 00:16:07.239
much processing power, but in theory.

00:16:07.759 --> 00:16:09.996
So what we can do instead is instead of calling

00:16:10.079 --> 00:16:12.677
𝚜𝚎𝚝𝚃𝚒𝚖𝚎𝚘𝚞𝚝, we can call 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎.

00:16:13.759 --> 00:16:15.960
Which also creates a new kind of task,

00:16:16.440 --> 00:16:19.439
but it does it in a special way.

00:16:20.199 --> 00:16:22.477
So the 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎 queue is there at

00:16:22.560 --> 00:16:24.320
the bottom in green.

00:16:24.920 --> 00:16:29.436
And now if we run some tasks which creates an

00:16:29.519 --> 00:16:32.996
animation task, what will happen is that task will

00:16:33.079 --> 00:16:35.837
sit in that queue, and it won't run until the

00:16:35.920 --> 00:16:38.879
rendering pipeline is ready to run.

00:16:39.639 --> 00:16:42.000
And then the animation frame task will run,

00:16:42.279 --> 00:16:43.839
and then the rendering pipeline will run.

00:16:43.959 --> 00:16:46.116
So that queue is always going to run just immediately

00:16:46.199 --> 00:16:48.119
before the rendering pipeline.

00:16:48.399 --> 00:16:50.799
The other nice thing is that unlike Promises,

00:16:51.079 --> 00:16:55.159
if we add an animation queue, an animation task,

00:16:58.079 --> 00:17:00.917
if we run an animation task, and we add another

00:17:01.000 --> 00:17:02.919
animation task while that one's running,

00:17:03.079 --> 00:17:04.876
that one won't run until the next turn of

00:17:04.959 --> 00:17:05.716
the event loop.

00:17:05.799 --> 00:17:11.236
So that means that we can create an animation,

00:17:11.319 --> 00:17:13.637
like one frame of an animation, and then set up

00:17:13.720 --> 00:17:16.440
the callback for the next frame, but it won't run

00:17:16.600 --> 00:17:24.440
until the next time the pipeline runs.

00:17:25.120 --> 00:17:29.000
So that results in an animation like this.

00:17:29.120 --> 00:17:31.437
So the top box is running 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎,

00:17:32.080 --> 00:17:33.601
the bottom one is running 𝚜𝚎𝚝𝚃𝚒𝚖𝚎𝚘𝚞𝚝.

00:17:34.080 --> 00:17:36.037
As you can see, they look pretty identical because

00:17:36.120 --> 00:17:37.880
nothing else is running on the screen.

00:17:38.320 --> 00:17:41.760
Importantly though, when we get to the end,

00:17:42.520 --> 00:17:44.997
the top one has run 800 times, and the bottom one

00:17:45.080 --> 00:17:47.240
has run 2,500 times.

00:17:47.640 --> 00:17:51.520
So we've wasted four-fifths of our computing power,

00:17:51.679 --> 00:17:53.836
three-fifths of our computing power just on doing

00:17:53.919 --> 00:17:54.559
nothing.

00:17:59.559 --> 00:18:00.960
Can you use 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎?

00:18:01.120 --> 00:18:01.836
Absolutely yes.

00:18:01.919 --> 00:18:03.960
It is available in all browsers back to IE10.

00:18:05.520 --> 00:18:07.637
It's not supported in Opera Mini, but neither is

00:18:07.720 --> 00:18:10.357
animating things in general, so that shouldn't be

00:18:10.440 --> 00:18:12.640
a problem.

00:18:13.240 --> 00:18:14.920
So what does our event loop look like now?

00:18:15.480 --> 00:18:17.119
It's still an infinite loop.

00:18:18.480 --> 00:18:20.277
For each turn of the loop, we're going to pick

00:18:20.360 --> 00:18:20.999
a queue.

00:18:21.679 --> 00:18:24.237
And then we're going to take the first task off

00:18:24.320 --> 00:18:26.640
that queue, and we're going to run that task.

00:18:27.240 --> 00:18:29.797
Then, as long as there are tasks in the microtask

00:18:29.880 --> 00:18:33.040
queue, we're going to run all of the microtasks.

00:18:33.240 --> 00:18:36.880
Then, if it's time to repaint, we're going to grab

00:18:37.120 --> 00:18:40.080
the tasks that are currently in the animation queue,

00:18:40.600 --> 00:18:42.880
and we're going to run just those tasks.

00:18:43.400 --> 00:18:45.840
And then we'll repaint.

00:18:46.280 --> 00:18:46.596
Cool.

00:18:46.679 --> 00:18:48.479
So is everybody okay with that?

00:18:49.159 --> 00:18:50.797
Good, because that is actually as complicated as

00:18:50.880 --> 00:18:51.480
it gets.

00:18:51.799 --> 00:18:54.680
That's the whole event loop in the browser.

00:18:55.120 --> 00:18:55.317
All right.

00:18:55.400 --> 00:18:56.600
So what did we learn?

00:18:57.120 --> 00:18:59.836
First of all, JavaScript can block rendering.

00:18:59.919 --> 00:19:01.797
So if you have long-running tasks, you need to

00:19:01.880 --> 00:19:04.397
either split them into smaller tasks or move them

00:19:04.480 --> 00:19:06.640
off the main thread so that it doesn't stuff up

00:19:06.880 --> 00:19:09.640
your user experience.

00:19:09.840 --> 00:19:12.716
Promises operate via a special kind of task called

00:19:12.799 --> 00:19:14.200
a microtask.

00:19:14.480 --> 00:19:16.836
And microtasks have even more power to block

00:19:16.919 --> 00:19:20.040
rendering than your standard JavaScript tasks.

00:19:20.640 --> 00:19:24.640
𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝙰𝚗𝚒𝚖𝚊𝚝𝚒𝚘𝚗𝙵𝚛𝚊𝚖𝚎 is a special kind of task

00:19:24.919 --> 00:19:28.080
that only runs with the rendering pipeline.

00:19:28.360 --> 00:19:30.437
And it's really good for creating really nice,

00:19:30.520 --> 00:19:32.956
smooth animations that you're guaranteed to run

00:19:33.039 --> 00:19:33.960
every frame.

00:19:34.600 --> 00:19:36.197
It's also good if you're doing a lot of DOM

00:19:36.280 --> 00:19:37.197
manipulation.

00:19:37.280 --> 00:19:40.479
It allows you to batch that all up just into one

00:19:41.480 --> 00:19:44.117
task just before the rendering runs, which can give

00:19:44.200 --> 00:19:46.836
you some efficiencies.

00:19:46.919 --> 00:19:49.117
The other thing that we hopefully understand now is

00:19:49.200 --> 00:19:55.920
why doing this sometimes fixes things.

00:19:56.440 --> 00:19:57.960
Maybe we don't.

00:19:59.440 --> 00:19:59.596
Cool.

00:19:59.679 --> 00:20:00.076
And that's it.

00:20:00.159 --> 00:20:00.960
That's all I've got.

00:20:01.280 --> 00:20:02.199
Thank you very much.

00:20:02.600 --> 00:20:05.080
You can grab the slides and talk me afterwards.

00:20:10.840 --> 00:20:11.197
Thank you.

00:20:11.280 --> 00:20:15.437
Thank you very much, Erin, for sharing your very

00:20:15.520 --> 00:20:18.280
insightful and your experience with us for the event loop.