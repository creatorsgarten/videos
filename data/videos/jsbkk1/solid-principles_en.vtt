WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:00.240 --> 00:00:02.957
Alright, now our speaker is ready.

00:00:03.040 --> 00:00:05.440
Please give a round of applause to our speaker,

00:00:05.560 --> 00:00:07.316
Chakrit Likitkhajorn

00:00:07.399 --> 00:00:26.560
senior software engineer from Omise

00:00:27.119 --> 00:00:28.240
Hello everyone

00:00:28.840 --> 00:00:32.717
My topic is about applying SOLID principle in JavaScript

00:00:32.800 --> 00:00:34.400
without class and object

00:00:35.440 --> 00:00:39.720
You can call me Chris, this is my nickname

00:00:40.320 --> 00:00:43.277
I try to wrap this up in 25 minutes

00:00:43.360 --> 00:00:45.320
So let's get to it

00:00:46.199 --> 00:00:48.077
Let's talk a little bit about my background

00:00:48.160 --> 00:00:51.600
because it's related to how I view software architecture

00:00:52.239 --> 00:00:55.640
I was a vice president of engineering at Taskworld

00:00:55.800 --> 00:00:58.917
At that time I take care of the whole product team

00:00:59.000 --> 00:01:02.077
and responsible for making sure that the whole product

00:01:02.160 --> 00:01:04.879
can be sellable and awesome

00:01:05.239 --> 00:01:11.200
I lead both engineering and design and the product team

00:01:12.320 --> 00:01:16.000
Now I'm working as a senior software engineer at Omise Payment

00:01:16.240 --> 00:01:22.877
I have written production code in eight different

00:01:22.960 --> 00:01:24.319
programming languages

00:01:27.479 --> 00:01:31.637
The way that I have a chance to work with many different

00:01:31.720 --> 00:01:37.036
departments affects how I view software architecture

00:01:37.119 --> 00:01:38.840
and how I write code a lot

00:01:39.119 --> 00:01:44.396
You will see what it means in my presentation

00:01:44.479 --> 00:01:46.356
So what is actually SOLID?

00:01:46.439 --> 00:01:49.320
I will try to make this short

00:01:49.840 --> 00:01:54.957
SOLID is five design principles introduced by Uncle Bob,

00:01:55.040 --> 00:01:56.356
which is Robert C. Martin

00:01:56.439 --> 00:01:59.160
and is very well known throughout the industry

00:02:01.880 --> 00:02:06.396
The motivation of why I deliver this talk here is that

00:02:06.479 --> 00:02:10.759
a lot of programmers have read about the SOLID design patterns

00:02:10.959 --> 00:02:15.796
but it's usually being demonstrated using programming language

00:02:15.879 --> 00:02:17.957
with class and objects

00:02:18.040 --> 00:02:21.236
But JavaScript we are multi-paradigm

00:02:21.319 --> 00:02:23.557
We can use class or don't use class

00:02:23.640 --> 00:02:26.397
We can write in object-oriented or functional programming

00:02:26.480 --> 00:02:28.920
We can write basically however we want

00:02:30.840 --> 00:02:35.077
Let's explore the alternative way of implementing

00:02:35.160 --> 00:02:39.560
SOLID principle but not using class and objects at all

00:02:39.840 --> 00:02:42.717
By doing that you will see the core content

00:02:42.800 --> 00:02:47.799
of what SOLID principle actually means

00:02:49.200 --> 00:02:53.960
Let's first talk about single responsibility principle

00:02:54.080 --> 00:02:57.637
It basically says that every module, every class,

00:02:57.720 --> 00:03:01.000
or every function should have just a single responsibility

00:03:01.879 --> 00:03:05.997
This is a very hard principle to absorb and to consume

00:03:06.080 --> 00:03:13.399
because it's hard to define what single responsibility means

00:03:13.760 --> 00:03:15.120
Let's take a look at an example

00:03:15.599 --> 00:03:18.917
Let's say that we have a requirement where we need to create

00:03:19.000 --> 00:03:22.760
a HTTP endpoint to register a new user

00:03:23.799 --> 00:03:26.317
The passwords minimum should be four characters

00:03:26.400 --> 00:03:31.156
so user cannot create an account with very short password

00:03:31.239 --> 00:03:37.360
Here's the simplest way to write using Express

00:03:37.480 --> 00:03:39.436
We have a username password

00:03:39.519 --> 00:03:45.959
We check for the length and return 422 and password is too weak

00:03:47.040 --> 00:03:49.317
If it's not then we register the user

00:03:49.400 --> 00:03:52.599
then we return success response

00:03:53.200 --> 00:03:55.597
If we write code like this then what happens is

00:03:55.680 --> 00:03:59.197
there are times where people from different departments

00:03:59.280 --> 00:04:02.876
will come to you and ask what the current password policy is

00:04:02.959 --> 00:04:05.760
and should we strengthen it from security team

00:04:05.920 --> 00:04:07.649
And there's a business team that can come to ask

00:04:07.732 --> 00:04:12.799
if we should gather more information before register any user

00:04:13.159 --> 00:04:16.759
Then let's ask for company name, country, etc

00:04:19.799 --> 00:04:22.560
Whenever you talk to another department,

00:04:22.840 --> 00:04:24.877
you talk to security team and you see that

00:04:24.960 --> 00:04:27.797
in one function you have bunch of related code

00:04:27.880 --> 00:04:30.357
and unrelated code cluttering together

00:04:30.440 --> 00:04:34.396
It's hard now if you come to the meeting with these teams

00:04:34.479 --> 00:04:38.637
It's hard to tell exactly what happened in the meeting room

00:04:38.720 --> 00:04:42.040
by looking at the code

00:04:42.560 --> 00:04:45.797
Now there are two completely separate reasons to change:

00:04:45.880 --> 00:04:50.757
One is we have a new password policy from security team

00:04:50.840 --> 00:04:54.920
or we need all information on register from business team

00:04:55.919 --> 00:04:58.797
So let's separate it out to two sub components

00:04:58.880 --> 00:05:03.280
whether it's class or function

00:05:03.880 --> 00:05:09.877
And surprisingly, what I have ended up with when I try

00:05:09.960 --> 00:05:14.317
to apply this principle is I come to realize that

00:05:14.400 --> 00:05:16.517
the reason to change is source of change,

00:05:16.600 --> 00:05:20.077
or put it simply, is about the people that you

00:05:20.160 --> 00:05:23.399
communicate with.

00:05:23.919 --> 00:05:27.836
And now if you separate to two class or two function,

00:05:27.919 --> 00:05:31.277
then you are to talk with the business team,

00:05:31.360 --> 00:05:34.517
and then you say that okay when I talk to this guy,

00:05:34.600 --> 00:05:37.440
then I need to look at the user registration class.

00:05:37.840 --> 00:05:39.357
And when I talk to security team,

00:05:39.440 --> 00:05:42.877
I just open the code and identify in a password class,

00:05:42.960 --> 00:05:46.160
and now you have the whole context of each team

00:05:46.520 --> 00:05:52.119
inside your single coding file.

00:05:52.639 --> 00:05:56.077
And surprisingly, I found that when I come to that

00:05:56.160 --> 00:05:58.676
realization and do this presentation,

00:05:58.759 --> 00:06:02.517
I ended up seeing that Uncle Bob,

00:06:02.600 --> 00:06:04.517
the originator of SOLID principle,

00:06:04.600 --> 00:06:08.399
also come to the same conclusion that I found.

00:06:08.800 --> 00:06:11.797
He says that the purpose of single responsibility

00:06:11.880 --> 00:06:15.637
is having different C-level executive responsible

00:06:15.720 --> 00:06:16.877
for different things,

00:06:16.960 --> 00:06:20.236
which is interesting and I'm happy that I come to

00:06:20.319 --> 00:06:23.437
the same conclusion as him.

00:06:23.520 --> 00:06:26.157
Okay, so let's see how we can implement this.

00:06:26.240 --> 00:06:29.556
For this principle, I will compare how we can do it

00:06:29.639 --> 00:06:32.159
with class and without class,

00:06:32.360 --> 00:06:35.840
and you can see the different approaches.

00:06:38.039 --> 00:06:41.437
So with class, then you create a user validation class

00:06:41.520 --> 00:06:43.717
that's responsible for the input,

00:06:43.800 --> 00:06:46.277
and you open this class whenever you talk to

00:06:46.360 --> 00:06:49.396
frontend team and frontend team asks about what kind

00:06:49.479 --> 00:06:51.680
of input we are receiving.

00:06:51.800 --> 00:06:54.197
And you have another class which is a password class,

00:06:54.280 --> 00:06:57.157
and you open this class whenever you talk to

00:06:57.240 --> 00:07:01.357
security team and they ask about how we store

00:07:01.440 --> 00:07:06.516
the password and how strong our password is.

00:07:06.599 --> 00:07:10.317
And you have another class called the user data class

00:07:10.400 --> 00:07:15.477
which is responsible for saving data to the database,

00:07:15.560 --> 00:07:18.116
and you can open this class whenever you talk with

00:07:18.199 --> 00:07:20.637
the database administration teams,

00:07:20.720 --> 00:07:23.157
and you can see the whole context of how we use

00:07:23.240 --> 00:07:25.720
the database system.

00:07:26.080 --> 00:07:28.317
And you have the whole flow being composed in

00:07:28.400 --> 00:07:31.757
the controller which is one object responsible for

00:07:31.840 --> 00:07:34.600
composing the whole flow.

00:07:35.120 --> 00:07:39.360
Okay, let's see how we can do this without class.

00:07:39.800 --> 00:07:42.997
It's very simple - you have a bunch of functions

00:07:43.080 --> 00:07:44.396
but the same concept.

00:07:44.479 --> 00:07:47.076
So you have three functions and each function is

00:07:47.159 --> 00:07:50.519
the one that you look at when you talk to each team.

00:07:50.639 --> 00:07:53.877
Now you have password, validate registration,

00:07:53.960 --> 00:07:56.717
and save user, so it's the same concept,

00:07:56.800 --> 00:07:59.676
just instead of using class you separate it

00:07:59.759 --> 00:08:02.520
using functions.

00:08:02.720 --> 00:08:07.917
And to compose it you can use the pattern called

00:08:08.000 --> 00:08:12.556
higher order function which takes a bunch of functions

00:08:12.639 --> 00:08:15.720
and creates another function.

00:08:15.840 --> 00:08:21.240
And you can see that it validates using the validator,

00:08:21.960 --> 00:08:25.676
and after validation passes, execute business logic

00:08:25.759 --> 00:08:28.037
using the controller which is another function

00:08:28.120 --> 00:08:32.797
and it returns to OO.

00:08:32.880 --> 00:08:36.237
And then you just use this composed function called

00:08:36.320 --> 00:08:39.480
create handler and you put it into express.

00:08:39.760 --> 00:08:42.037
It's basically the same separation,

00:08:42.120 --> 00:08:46.400
just a different style of doing things.

00:08:46.760 --> 00:08:51.719
And what I found about not using class is

00:08:51.920 --> 00:08:55.117
it encourages incremental development.

00:08:55.200 --> 00:08:58.876
And what I mean by encourage is that let's say

00:08:58.959 --> 00:09:00.196
you have a small app,

00:09:00.279 --> 00:09:03.639
you put everything inside just one big function.

00:09:03.839 --> 00:09:06.316
And now you're becoming larger,

00:09:06.399 --> 00:09:10.797
you want to separate the concerns to different concerns,

00:09:10.880 --> 00:09:14.917
and you can just move these two lines here,

00:09:15.000 --> 00:09:16.999
you can just move this one line here,

00:09:17.240 --> 00:09:21.677
and then you can just write the higher order function

00:09:21.760 --> 00:09:25.399
and replace it with this higher order function.

00:09:27.880 --> 00:09:32.557
You can basically just move code around and separate

00:09:32.640 --> 00:09:34.160
the concerns just like that.

00:09:34.440 --> 00:09:36.756
Unlike the object oriented approach where you need to

00:09:36.839 --> 00:09:39.917
create class, create a bunch of constructors,

00:09:40.000 --> 00:09:43.357
and after doing that then you can move code,

00:09:43.440 --> 00:09:46.760
which is more tedious.

00:09:47.040 --> 00:09:50.196
So when you're not using class,

00:09:50.279 --> 00:09:53.200
I found that it feels more fluid.

00:09:53.399 --> 00:09:58.996
The code becomes fluid - you can change however you want

00:09:59.079 --> 00:10:00.919
to compose things.

00:10:01.279 --> 00:10:06.040
It's not as rigid as the object oriented approach.

00:10:06.160 --> 00:10:08.677
So at first I really like this approach,

00:10:08.760 --> 00:10:11.280
I try to implement it into my team.

00:10:16.279 --> 00:10:20.280
What really happen when you implement this into the team?

00:10:20.480 --> 00:10:24.756
This is what I found when we use the object-oriented

00:10:24.839 --> 00:10:25.639
approach:

00:10:27.480 --> 00:10:29.597
Since it's harder to change the structure,

00:10:29.680 --> 00:10:33.157
it incentivize the team to use the same structure.

00:10:33.240 --> 00:10:36.077
And as a result, it's easier to standardize

00:10:36.160 --> 00:10:38.759
the practice for the whole team.

00:10:39.279 --> 00:10:44.957
Even if it's hard to structure it in a different way,

00:10:45.040 --> 00:10:47.477
but it encourage the standardization.

00:10:47.560 --> 00:10:50.876
At the opposite, function composition encourage you

00:10:50.959 --> 00:10:54.037
to have a different type of composition.

00:10:54.120 --> 00:10:56.996
You can compose it in a way that is actually very fit

00:10:57.079 --> 00:11:01.600
to the domain business domain that you are solving.

00:11:01.720 --> 00:11:04.957
But in the other hand, it encourage people to do

00:11:05.040 --> 00:11:06.920
bunch of different things in the codebase

00:11:07.320 --> 00:11:09.477
and you lose the standardization.

00:11:09.560 --> 00:11:12.357
So that is a trade-off that I found when I try

00:11:12.440 --> 00:11:14.360
to implement this into the team.

00:11:15.800 --> 00:11:18.399
By knowing this trade-off, then you can see that

00:11:18.839 --> 00:11:20.837
when I try to use function composition,

00:11:20.920 --> 00:11:23.556
I need to make sure that people still conform

00:11:23.639 --> 00:11:25.237
to some standardization.

00:11:25.320 --> 00:11:27.517
And when I use object-oriented approach,

00:11:27.600 --> 00:11:30.799
then I need to make sure that people don't conform

00:11:31.000 --> 00:11:32.837
to the standard practice

00:11:32.920 --> 00:11:37.239
and try to come up with maybe better way to compose

00:11:40.160 --> 00:11:43.840
and make sense of the code.

00:11:44.920 --> 00:11:49.200
Let's jump to the next principle: open-close principle.

00:11:49.320 --> 00:11:52.277
Open-close principle say that the software should be

00:11:52.360 --> 00:11:56.677
open for extension but close for modification.

00:11:56.760 --> 00:11:58.557
Let's jump to the example now.

00:11:58.640 --> 00:12:01.957
Let's say that you start with the user can confirm

00:12:02.040 --> 00:12:04.236
the invoice and you have a function called

00:12:04.320 --> 00:12:05.959
ðšŒðš˜ðš—ðšðš’ðš›ðš–ð™¸ðš—ðšŸðš˜ðš’ðšŒðšŽ, you save it.

00:12:06.279 --> 00:12:08.157
And now after invoice is confirmed,

00:12:08.240 --> 00:12:09.797
you need to send the email to customer

00:12:09.880 --> 00:12:11.439
and you implement it here.

00:12:11.920 --> 00:12:15.677
And after this, you say that after invoice confirmed,

00:12:15.760 --> 00:12:17.397
you need to send push notification.

00:12:17.480 --> 00:12:21.480
So you just send the push notification.

00:12:21.720 --> 00:12:26.436
And what happen is when user complain about

00:12:26.519 --> 00:12:31.077
not getting the email, then it's in just these two lines.

00:12:31.160 --> 00:12:33.116
And when the user complain about not getting

00:12:33.199 --> 00:12:34.077
the push notification,

00:12:34.160 --> 00:12:39.720
then it's another lines inside the single function.

00:12:40.120 --> 00:12:44.797
So generally speaking, you have one function

00:12:44.880 --> 00:12:46.639
that's responsible for many issues.

00:12:47.000 --> 00:12:49.237
And when each team working in parallel,

00:12:49.320 --> 00:12:51.637
it introduce a lot of merge conflict.

00:12:51.720 --> 00:12:56.600
And we really like to solve the merge conflict, right?

00:12:57.120 --> 00:13:04.037
Function will grow bigger and bigger.

00:13:04.120 --> 00:13:07.237
When you try to modify the current behavior of function,

00:13:07.320 --> 00:13:11.597
it's possible that some people rely on the function

00:13:11.680 --> 00:13:13.077
to act in a certain way.

00:13:13.160 --> 00:13:14.597
And when you modify it,

00:13:14.680 --> 00:13:17.800
it can introduce breaking change that you don't know

00:13:18.000 --> 00:13:20.397
because the guys that depend on the behavior

00:13:20.480 --> 00:13:24.359
is someone in the team that very far from you.

00:13:24.959 --> 00:13:27.480
You ended up in the situation like this again

00:13:27.920 --> 00:13:30.237
that you have bunch of related code when you talk

00:13:30.320 --> 00:13:32.237
and work with some requirement

00:13:32.320 --> 00:13:38.319
and bunch of unrelated code when it's clutter together.

00:13:38.519 --> 00:13:39.756
So how to solve it?

00:13:39.839 --> 00:13:43.680
Then you can use observable, event, or stream.

00:13:43.959 --> 00:13:46.357
So you can say that for the confirm invoice,

00:13:46.440 --> 00:13:48.597
you just say that after save,

00:13:48.680 --> 00:13:52.440
then after saving it, I put it into invoice stream.

00:13:52.800 --> 00:13:55.123
And then you have ðšœðšŽðš—ðšð™¸ðš—ðšŸðš˜ðš’ðšŒðšŽð™´ðš–ðšŠðš’ðš•

00:13:56.079 --> 00:13:57.560
and you have ðšœðšŽðš—ðšð™¿ðšžðšœðš‘ð™½ðš˜ðšðš’ðšðš’ðšŒðšŠðšðš’ðš˜ðš—

00:13:58.120 --> 00:14:00.996
and you push this function inside the stream,

00:14:01.079 --> 00:14:04.120
listen from it to listen for the event.

00:14:04.560 --> 00:14:08.917
And now the confirm invoice will be maintain

00:14:09.000 --> 00:14:11.880
and look the same always.

00:14:12.240 --> 00:14:16.436
So you never modify the behavior of confirm invoice,

00:14:16.519 --> 00:14:21.037
but you just make it extendable and you extend it.

00:14:21.120 --> 00:14:26.000
And that's the open-close principle.

00:14:26.120 --> 00:14:30.037
The benefit of using stream is that you can scale

00:14:30.120 --> 00:14:34.637
to become like you have email sender as another process.

00:14:34.720 --> 00:14:37.477
You put the stream into Kafka or RabbitMQ

00:14:37.560 --> 00:14:40.360
or whatever queue system that you have.

00:14:40.560 --> 00:14:43.917
And you can scale the system that way,

00:14:44.000 --> 00:14:46.360
but you can start small just using Rx

00:14:46.560 --> 00:14:49.760
or observable stream.

00:14:50.360 --> 00:14:54.440
Let's talk about Liskov substitution principle.

00:14:55.040 --> 00:14:58.480
It basically say that the derived class

00:14:58.639 --> 00:15:01.320
must be substitutable for the base classes.

00:15:01.480 --> 00:15:03.957
It's hard to absorb just this sentence,

00:15:04.040 --> 00:15:06.120
so let's take a look at the example now.

00:15:07.079 --> 00:15:09.518
Let's say that we have the ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš›

00:15:09.920 --> 00:15:11.600
for the production and ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš›

00:15:11.920 --> 00:15:15.357
for the local machine doing different things.

00:15:15.440 --> 00:15:18.200
In production, you need to send the error to Sentry.

00:15:19.000 --> 00:15:21.517
You have some plugins that actually insert

00:15:21.600 --> 00:15:23.639
custom metadata to the error.

00:15:24.040 --> 00:15:26.357
And so the ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš› to the production

00:15:26.440 --> 00:15:28.960
will just also report that metadata.

00:15:29.319 --> 00:15:32.876
But for the report when you work in your local machine,

00:15:32.959 --> 00:15:35.358
you don't want to send every error to Sentry.

00:15:35.959 --> 00:15:37.719
So you just do the ðšŒðš˜ðš—ðšœðš˜ðš•ðšŽ.ðšŽðš›ðš›ðš˜ðš›.

00:15:39.720 --> 00:15:42.280
But what happened here is that the ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš›

00:15:42.519 --> 00:15:45.597
in production can explode when custom metadata

00:15:45.680 --> 00:15:47.079
is undefined.

00:15:47.199 --> 00:15:50.357
Which means that ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš› in production

00:15:50.440 --> 00:15:53.679
cannot substitute the ðš›ðšŽðš™ðš˜ðš›ðšð™´ðš›ðš›ðš˜ðš› locally.

00:15:53.800 --> 00:15:56.120
It cannot totally substitute it.

00:15:56.399 --> 00:16:05.799
And what happened is the user of the report error

00:16:06.240 --> 00:16:09.676
need to know and need to handle some little secret

00:16:09.759 --> 00:16:13.717
that if it's in production but for some reason

00:16:13.800 --> 00:16:16.277
we doing things wrong we don't have custom metadata

00:16:16.360 --> 00:16:19.556
then we need to insert it because one of the report

00:16:19.639 --> 00:16:26.556
error implementation just cannot handle when

00:16:26.639 --> 00:16:29.120
the custom metadata is undefined.

00:16:30.160 --> 00:16:33.519
So that's kind of break the Liskov substitution

00:16:34.360 --> 00:16:35.240
principle.

00:16:36.120 --> 00:16:41.597
And please don't do it this way because the problem

00:16:41.680 --> 00:16:44.196
of doing this way is the implementer of do something

00:16:44.279 --> 00:16:47.160
need to know a little secret about the report error

00:16:47.399 --> 00:16:53.157
which might be the guy that do the report error

00:16:53.240 --> 00:16:55.556
function and the guy that do the do something

00:16:55.639 --> 00:16:57.397
function might be in a different team

00:16:57.480 --> 00:17:00.116
so we don't want the knowledge to be clutter

00:17:00.199 --> 00:17:01.080
all around.

00:17:01.319 --> 00:17:06.116
And what you should do here is to make it totally

00:17:06.199 --> 00:17:08.956
substitutable so you should just handle

00:17:09.039 --> 00:17:12.797
the custom metadata error here and make sure that

00:17:12.880 --> 00:17:16.356
report error in production can be total substitute

00:17:16.439 --> 00:17:21.679
to the report error locally.

00:17:21.959 --> 00:17:25.119
So basically what it means is function should be

00:17:25.400 --> 00:17:26.317
replaceable.

00:17:26.400 --> 00:17:29.237
This example is not so common because we don't use

00:17:29.320 --> 00:17:31.956
this pattern a lot but it's more common when you

00:17:32.039 --> 00:17:35.357
have bunch of React components that you need to

00:17:35.440 --> 00:17:39.197
render based on if they are admin then render this

00:17:39.280 --> 00:17:42.956
component if user is just a user then render

00:17:43.039 --> 00:17:45.557
another component and you need to make sure that

00:17:45.640 --> 00:17:49.476
in every cases possible this admin page and this

00:17:49.559 --> 00:17:51.997
user page should be substitutable and there's

00:17:52.080 --> 00:17:55.397
nothing that it can everything that work with user

00:17:55.480 --> 00:17:57.637
page should work with admin page and everything

00:17:57.720 --> 00:18:02.359
that work on admin page should work in user page too.

00:18:03.039 --> 00:18:06.120
Okay so let's talk about interface segregation

00:18:07.159 --> 00:18:08.039
principle.

00:18:08.159 --> 00:18:11.877
It says that the client should not be forced on or

00:18:11.960 --> 00:18:14.120
depend on method that they may not use.

00:18:14.520 --> 00:18:19.476
Okay so let's take a look of how the example now.

00:18:19.559 --> 00:18:22.157
So let's say that you start with the delete invoice

00:18:22.240 --> 00:18:25.197
you don't want to actually delete it so you just

00:18:25.280 --> 00:18:27.880
set is delete to be true.

00:18:28.400 --> 00:18:32.076
And now after that then you need to implement

00:18:32.159 --> 00:18:36.280
the recover the deleted data so you implement it

00:18:36.760 --> 00:18:39.197
recover invoice and now you see that the code is

00:18:39.280 --> 00:18:42.117
duplicate so you just say that okay let's remove

00:18:42.200 --> 00:18:45.476
the duplication and make it like this and let's

00:18:45.559 --> 00:18:49.479
update the status and now duplication is being

00:18:50.159 --> 00:18:50.879
removed.

00:18:51.159 --> 00:18:55.037
And then it's come now you don't conform to

00:18:55.120 --> 00:18:58.716
the GDPR because GDPR say that data can be removed

00:18:58.799 --> 00:19:01.037
and user can be forgotten now you need to do

00:19:01.120 --> 00:19:03.199
a hard delete.

00:19:03.559 --> 00:19:06.877
And if you still try to conform to this you might

00:19:06.960 --> 00:19:11.637
ended up that okay let's put another parameter here

00:19:11.720 --> 00:19:13.956
which is a hard delete and if it's hard delete

00:19:14.039 --> 00:19:16.277
then you just remove the whole things and if not

00:19:16.360 --> 00:19:18.757
then you just change the boolean here change

00:19:18.840 --> 00:19:20.120
the is delete here.

00:19:20.559 --> 00:19:25.520
And when you implement it like this it become

00:19:26.039 --> 00:19:30.277
for the delete implementer this parameter hard

00:19:30.360 --> 00:19:33.879
delete make total sense for him but for the recover

00:19:34.000 --> 00:19:37.917
implementer it's okay why I need this hard delete

00:19:38.000 --> 00:19:40.637
parameter it's not make sense for me at all

00:19:40.720 --> 00:19:44.000
it's such a nonsense.

00:19:44.200 --> 00:19:49.277
And now if on recover we need to implement something

00:19:49.360 --> 00:19:52.237
such as if one month pass we need to reassign

00:19:52.320 --> 00:19:54.517
the invoice number then now you need to have

00:19:54.600 --> 00:19:57.557
the recover logic inside this change delete status

00:19:57.640 --> 00:19:58.440
function.

00:19:59.400 --> 00:20:05.197
And you ended up in this again that when you want

00:20:05.280 --> 00:20:07.557
to know how we recover things you need to look

00:20:07.640 --> 00:20:10.997
a bunch of related code and when you want to know

00:20:11.080 --> 00:20:14.357
how we delete invoice there's also related code

00:20:14.440 --> 00:20:18.280
and unrelated code clutter all together again.

00:20:18.720 --> 00:20:22.760
And the solution is simply in this case is simply

00:20:23.320 --> 00:20:27.476
re-duplicate the code and just make separate case

00:20:27.559 --> 00:20:28.383
for delete invoice and recover invoice.

00:20:28.467 --> 00:20:38.557
The more and the takeaway here for this principle is

00:20:38.640 --> 00:20:42.157
function parameter should make sense for the majority

00:20:42.240 --> 00:20:43.799
of customers.

00:20:43.919 --> 00:20:47.479
Otherwise, let's consider having separate function.

00:20:47.679 --> 00:20:52.519
And I saw that this principle is violated because

00:20:52.799 --> 00:20:56.533
as I show in my example earlier, when you try to

00:20:56.616 --> 00:21:02.917
reduce the duplication, but then new requirement come

00:21:03.000 --> 00:21:08.439
and you try to conform to the current structure

00:21:08.559 --> 00:21:12.716
and don't look back and see that, okay,

00:21:12.799 --> 00:21:15.196
is it still make sense to do it this way?

00:21:15.279 --> 00:21:16.560
Should we reduplicate the code?

00:21:16.840 --> 00:21:21.240
Then you are likely to violate this principle.

00:21:21.360 --> 00:21:24.757
So I would say that code duplication should not be

00:21:24.840 --> 00:21:28.277
viewed as a dogma and sometimes it's better to have

00:21:28.360 --> 00:21:33.877
some duplication, but have a very separate domain

00:21:33.960 --> 00:21:35.637
where we can look at and see that, okay,

00:21:35.720 --> 00:21:38.956
delete and recover, we do totally different things

00:21:39.039 --> 00:21:42.719
here and it makes sense.

00:21:43.159 --> 00:21:43.517
Okay.

00:21:43.600 --> 00:21:49.400
So the last principle, Dependency Inversion Principle.

00:21:49.520 --> 00:21:52.637
So it basically says that the high level module

00:21:52.720 --> 00:21:55.440
should not depend on low level modules.

00:21:56.919 --> 00:22:00.557
And the example here is that you have case where

00:22:00.640 --> 00:22:03.277
you need to upload user avatar, which is a high

00:22:03.360 --> 00:22:04.797
level requirement.

00:22:04.880 --> 00:22:09.690
And you need to use S3, Amazon S3, as object storage,

00:22:09.773 --> 00:22:12.757
which is infrastructure level requirement.

00:22:12.840 --> 00:22:13.716
And okay.

00:22:13.799 --> 00:22:15.397
So you can start simple, right?

00:22:15.480 --> 00:22:17.716
And you have a class user, you implement the

00:22:17.799 --> 00:22:18.760
upload avatar.

00:22:19.679 --> 00:22:22.517
And in this principle, I will compare how you do it

00:22:22.600 --> 00:22:24.880
in class and do it without class.

00:22:25.159 --> 00:22:28.797
And with class, then you just have S3 and upload file

00:22:28.880 --> 00:22:33.000
and without class, then you just do the same things.

00:22:33.360 --> 00:22:36.397
But now the next requirement come and you need to be

00:22:36.480 --> 00:22:40.639
able to store in the Google Cloud Storage as well.

00:22:41.159 --> 00:22:45.917
And the naive implementation is you just have if like

00:22:46.000 --> 00:22:49.877
if the config is S3, then we use S3 and if not,

00:22:49.960 --> 00:22:51.599
then we just use Google Cloud.

00:22:51.760 --> 00:22:54.560
And it's the same for class and function.

00:22:58.919 --> 00:23:03.836
The problem about this naive implementation is now

00:23:03.919 --> 00:23:07.196
the upload function implementer need to know about

00:23:07.279 --> 00:23:13.679
the deep infrastructure, whether we use S3 and

00:23:14.480 --> 00:23:15.879
Google Cloud Storage.

00:23:16.039 --> 00:23:25.157
So it's kind of things that now you have to know

00:23:25.240 --> 00:23:31.277
more things in order to contribute to the project.

00:23:31.360 --> 00:23:33.076
And that's not good.

00:23:33.159 --> 00:23:36.399
And we can solve this by using technique called

00:23:36.679 --> 00:23:37.877
dependency injection.

00:23:37.960 --> 00:23:39.797
So you have class for S3 storage.

00:23:39.880 --> 00:23:43.119
In the class world, you have class called S3 storage,

00:23:43.440 --> 00:23:45.637
Google Cloud Storage, and you inject here.

00:23:45.720 --> 00:23:48.196
And in the function world, it's totally the same

00:23:48.279 --> 00:23:51.476
concept, but instead of injecting class,

00:23:51.559 --> 00:23:54.880
you inject the functions instead.

00:23:55.400 --> 00:23:58.797
So you inject the upload S3 function and inject

00:23:58.880 --> 00:24:02.200
the upload Google Cloud function.

00:24:02.400 --> 00:24:06.596
And the benefit of this is when people come to ask

00:24:06.679 --> 00:24:09.920
you how upload works and can we change it,

00:24:10.279 --> 00:24:13.076
then you can just look at the whole flow without

00:24:13.159 --> 00:24:15.917
noticing that inside the upload function,

00:24:16.000 --> 00:24:18.279
it's actually we have two storage.

00:24:18.480 --> 00:24:21.637
And it's easy to explain to the business who don't

00:24:21.720 --> 00:24:24.877
know much about our internal infrastructure

00:24:24.960 --> 00:24:27.320
that this is how the whole flow work.

00:24:27.440 --> 00:24:29.917
Just looking at the code, you can totally explain

00:24:30.000 --> 00:24:33.716
without need to write a complicated documentation.

00:24:33.799 --> 00:24:36.640
You can just go to meeting, open the laptop,

00:24:36.840 --> 00:24:38.956
look at the code, and explain it in the meeting

00:24:39.039 --> 00:24:40.277
room immediately.

00:24:40.360 --> 00:24:42.677
And if they ask, okay, how can I change it?

00:24:42.760 --> 00:24:46.600
I can answer immediately in the meeting room.

00:24:47.120 --> 00:24:50.677
And this is why we all love polymorphism.

00:24:50.760 --> 00:24:53.757
And I think this is a very important thing

00:24:53.840 --> 00:24:55.520
that polymorphism gives us.

00:24:55.720 --> 00:24:59.880
It allows us to express the different flow from

00:25:00.039 --> 00:25:02.316
different perspectives.

00:25:02.399 --> 00:25:05.917
You can express the flow of the high level flow

00:25:06.000 --> 00:25:14.600
and completely set aside the low level detail.

00:25:16.760 --> 00:25:20.117
And now you can communicate and write a class or

00:25:20.200 --> 00:25:23.157
function that can be used when you communicate

00:25:23.240 --> 00:25:26.997
with any type of stakeholders, which is for me,

00:25:27.080 --> 00:25:30.156
as I work with multiple stakeholders since the start,

00:25:30.239 --> 00:25:35.480
then I find this style of coding really useful.

00:25:35.840 --> 00:25:38.997
But that's a trade off because when you use class

00:25:39.080 --> 00:25:42.397
and object, then you can only inject the whole

00:25:42.480 --> 00:25:46.836
objects and object can have so many methods.

00:25:46.919 --> 00:25:49.997
And you can end up that you just want just one

00:25:50.080 --> 00:25:52.757
method, but you need to inject the whole things,

00:25:52.840 --> 00:25:56.480
the whole objects that have 10 different methods

00:25:57.080 --> 00:25:59.517
into the class that you want.

00:25:59.600 --> 00:26:01.997
So let's consider if you use this approach,

00:26:02.080 --> 00:26:04.716
then please consider if the object become too big

00:26:04.799 --> 00:26:07.037
and break it down to different function.

00:26:07.120 --> 00:26:10.037
In the function, it's opposite because you can

00:26:10.120 --> 00:26:12.237
inject just one function at a time.

00:26:12.320 --> 00:26:16.557
So in the past, I ended up that have one function

00:26:16.640 --> 00:26:19.397
that need to inject like seven or eight functions

00:26:19.480 --> 00:26:20.879
in order to make it work.

00:26:21.039 --> 00:26:24.440
And it's become really hard to keep track of where

00:26:25.520 --> 00:26:28.159
these seven and eight functions coming from.

00:26:28.640 --> 00:26:32.476
So in the opposite way, when you use function inject

00:26:32.559 --> 00:26:35.437
function as dependencies, then you might consider

00:26:35.520 --> 00:26:37.836
grouping the function in the way that make sense

00:26:37.919 --> 00:26:42.879
in the business domain context.

00:26:43.279 --> 00:26:44.677
And that's it.

00:26:44.760 --> 00:26:48.196
I just went through five principles.

00:26:48.279 --> 00:26:53.596
But my takeaway here is that I kind of intentionally

00:26:53.679 --> 00:26:55.917
structure the talk in the way that, okay,

00:26:56.000 --> 00:26:58.956
if I write code in this way, then what happened?

00:26:59.039 --> 00:27:00.797
And if I write code in another way,

00:27:00.880 --> 00:27:02.679
then what happened?

00:27:03.799 --> 00:27:06.437
And after that, I talk about which way is more

00:27:06.520 --> 00:27:07.880
desirable and why.

00:27:08.120 --> 00:27:11.117
And for me, the desirable as a coder who need to

00:27:11.200 --> 00:27:14.719
talk to a lot of stakeholders, I want to be able to

00:27:15.080 --> 00:27:17.637
just look at the code and talk everything in the

00:27:17.720 --> 00:27:18.316
meeting room.

00:27:18.399 --> 00:27:21.357
I don't want to have to write a lot of complex

00:27:21.440 --> 00:27:24.836
document and write a lot of presentation,

00:27:24.919 --> 00:27:25.437
a lot of diagram.

00:27:25.520 --> 00:27:28.596
I just want to look at the code and can communicate

00:27:28.679 --> 00:27:31.277
with every type of stakeholders in the meeting.

00:27:31.360 --> 00:27:33.440
And this is desirable for me.

00:27:34.120 --> 00:27:38.677
And I never use the word "violate" or "wrong" because

00:27:38.760 --> 00:27:42.959
I want to say that I don't think that's about

00:27:43.080 --> 00:27:45.757
the architecture is about what is right or wrong.

00:27:45.840 --> 00:27:48.436
I don't like it when people say that, okay,

00:27:48.519 --> 00:27:51.277
this programmer violates some kind of principle.

00:27:51.360 --> 00:27:53.797
So you are very bad and you should feel bad

00:27:53.880 --> 00:27:55.359
about yourself.

00:27:55.559 --> 00:27:57.237
I think it's not a healthy way to look at

00:27:57.320 --> 00:27:58.596
software architecture.

00:27:58.679 --> 00:28:02.277
So that's why I intentionally structure my

00:28:02.360 --> 00:28:03.520
presentation this way.

00:28:04.000 --> 00:28:07.476
And at the end, I believe the architecture is about

00:28:07.559 --> 00:28:10.917
managing knowledge and communication channel within

00:28:11.000 --> 00:28:14.596
the team or within the team to the outside

00:28:14.679 --> 00:28:15.596
stakeholders.

00:28:15.679 --> 00:28:19.037
It's all about how you manage and how you intend to

00:28:19.120 --> 00:28:22.117
communicate within team and to the outside of

00:28:22.200 --> 00:28:22.716
the team.

00:28:22.799 --> 00:28:24.836
And that's all my talk.

00:28:24.919 --> 00:28:25.799
Thank you.

00:28:26.399 --> 00:28:28.037
Thank you, Mr. Chakrit.

00:28:28.120 --> 00:28:32.080
Thank you so much, Mr. Chakrit, from Omise Thailand na ka.