WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:00.000 --> 00:00:05.320
อ่า เอาล่ะค่ะ ถัดไปเนี่ยจะเป็นหัวข้อจากทางฝั่งของ

00:00:05.879 --> 00:00:07.356
partner ของเรานะคะ

00:00:07.439 --> 00:00:11.436
เป็นสปอนเซอร์ที่น่ารักท่านแรกนะคะ มาจาก KBTG นะคะ

00:00:11.519 --> 00:00:14.600
วันนี้เนี่ยจะมีหัวข้อพิเศษมาพูดในเรื่อง

00:00:15.000 --> 00:00:19.036
Understanding React Practice by Learning Functional

00:00:19.119 --> 00:00:21.400
Programming in JavaScript นะคะ

00:00:21.760 --> 00:00:25.480
ก็ผู้ที่เป็น speaker ของเราในรอบนี้นะคะ

00:00:25.640 --> 00:00:27.917
ก็คือคุณ Nattapon Rattajak ค่ะ

00:00:28.000 --> 00:00:30.557
เป็น full stack JavaScript developer จาก

00:00:30.640 --> 00:00:32.717
กสิกร Business Technology Group

00:00:32.800 --> 00:00:35.640
หรือว่าเราเรียกกันสั้นๆ ว่า KBTG นะคะ

00:00:36.399 --> 00:00:40.956
So for this special session is from our one of our

00:00:41.039 --> 00:00:42.920
beloved sponsor KBTG.

00:00:43.440 --> 00:00:46.956
He is going to talk about Understanding React Practice

00:00:47.039 --> 00:00:49.877
by Learning Functional Programming in JavaScript

00:00:49.960 --> 00:00:54.156
by Mr. Nattapon Rattajak, full stack JavaScript developer

00:00:54.239 --> 00:00:57.320
from Kasikorn Business Technology Group or KBTG.

00:00:57.840 --> 00:00:59.197
เอาล่ะค่ะ ตอนนี้พร้อมแล้ว

00:00:59.280 --> 00:01:12.679
ขอเสียงปรบมือต้อนรับคุณณัฐพลด้านบนเวทีค่ะ

00:01:13.439 --> 00:01:18.079
ครับ ชื่อ Nattapon Rattajak ครับ

00:01:19.360 --> 00:01:22.439
เป็น full stack developer อยู่ที่ KBTG นะครับ

00:01:22.720 --> 00:01:27.479
ก็วันนี้รู้สึกยินดีมากๆ ที่ได้มาพูดในงานวันนี้นะครับ

00:01:28.640 --> 00:01:30.560
สำหรับวันนี้ผมจะมาพูดในหัวข้อ

00:01:31.000 --> 00:01:34.040
การทำความเข้าใจ React Practice

00:01:34.240 --> 00:01:36.157
โดยการเรียนรู้ functional programming

00:01:36.240 --> 00:01:39.119
ในภาษา JavaScript นะครับ

00:01:41.119 --> 00:01:42.519
ที่ KBTG เนี่ย

00:01:42.640 --> 00:01:46.477
เราใช้ React ในการทำ front-end application

00:01:46.560 --> 00:01:47.640
ค่อนข้างมากนะครับ

00:01:50.680 --> 00:01:52.237
JavaScript developer เนี่ย

00:01:52.320 --> 00:01:56.277
มักจะต้องเจอกับคำศัพท์เกี่ยวกับ functional programming

00:01:56.360 --> 00:01:57.076
บ่อยๆ นะครับ

00:01:57.159 --> 00:02:00.840
เช่น pure function, mutation, side effect

00:02:01.159 --> 00:02:03.757
แล้วก็ library หลายๆ ตัวที่เราใช้เนี่ย

00:02:03.840 --> 00:02:07.437
มักจะมีการเอาแนวความคิดของ functional programming

00:02:07.520 --> 00:02:08.717
มาใช้กันอย่างแพร่หลายนะครับ

00:02:08.800 --> 00:02:10.839
library ที่สำคัญๆ ที่เราใช้

00:02:11.239 --> 00:02:16.000
เช่น Redux, Lodash หรือว่าพวก RxJS นะครับ

00:02:17.319 --> 00:02:18.837
เป็นสิ่งที่หลีกเลี่ยงไม่ได้นะครับ

00:02:18.920 --> 00:02:21.077
ว่า JavaScript ต้องทำความเข้าใจเกี่ยวกับ

00:02:21.160 --> 00:02:23.680
functional programming นะครับ

00:02:25.239 --> 00:02:27.040
functional programming คืออะไร

00:02:27.720 --> 00:02:30.637
functional programming เป็น programming paradigm นะครับ

00:02:30.720 --> 00:02:32.117
programming paradigm ก็คือ

00:02:32.200 --> 00:02:35.839
กระบวนการแนวความคิดในการทำ software construction นะครับ

00:02:36.160 --> 00:02:39.477
ข้อดีของ functional programming เนี่ย

00:02:39.560 --> 00:02:42.999
ก็คือ โค้ดจะมีความสั้นกระชับ

00:02:43.519 --> 00:02:45.997
เข้าใจง่าย แล้วก็คาดเดาผลลัพธ์ได้

00:02:46.080 --> 00:02:48.919
แล้วก็ทำให้ทำ test ได้ง่ายนะครับ

00:02:50.640 --> 00:02:53.960
ผมจะมาพูดใน 3 หัวข้อนะครับ

00:02:54.360 --> 00:02:58.637
หัวข้อแรกเป็น JavaScript feature ที่สำคัญๆ

00:02:58.720 --> 00:03:02.796
แล้วมันทำให้เกิดการเขียนโค้ดแบบ functional programming

00:03:02.879 --> 00:03:03.197
นะครับ

00:03:03.280 --> 00:03:06.357
แล้วก็หัวข้อที่ 2 เป็น key concept ของ

00:03:06.440 --> 00:03:07.917
functional programming

00:03:08.000 --> 00:03:10.680
แล้วก็หัวข้อที่ 3 เป็นการประยุกต์ใช้

00:03:11.599 --> 00:03:13.397
functional programming เข้ากับการเขียน

00:03:13.480 --> 00:03:15.839
React application นะครับ

00:03:16.920 --> 00:03:23.117
หัวข้อแรก JavaScript feature ที่ทำให้เกิด

00:03:23.200 --> 00:03:25.277
การเขียนโค้ดแบบ functional programming นะครับ

00:03:25.360 --> 00:03:29.076
มี feature ที่สำคัญๆ 3 ตัวนะครับ

00:03:29.159 --> 00:03:30.640
มาดูตัวแรกกันเลย

00:03:31.400 --> 00:03:35.399
feature แรก first-class function

00:03:35.599 --> 00:03:38.877
first-class function เป็นคุณสมบัติของการทำให้

00:03:38.960 --> 00:03:42.397
function เนี่ย มันทำตัวเป็น data value นะครับ

00:03:42.480 --> 00:03:45.197
แล้วก็เราจะสามารถให้ function เนี่ย

00:03:45.280 --> 00:03:48.358
มัน pass ไปเป็น argument ของ function อื่นก็ได้

00:03:48.480 --> 00:03:50.716
แล้วก็เราจะให้ function เนี่ย

00:03:50.799 --> 00:03:53.277
มัน assign ไปเป็น variable ก็ได้

00:03:53.360 --> 00:03:55.996
หรือว่าเราจะ return function ออกมาจาก

00:03:56.079 --> 00:03:58.520
function อื่นก็ได้นะครับ

00:03:59.200 --> 00:04:04.119
แล้วก็ feature ที่ 2 anonymous function

00:04:04.319 --> 00:04:09.557
anonymous function เป็นความสามารถในการประกาศ function

00:04:09.640 --> 00:04:11.240
โดยไม่ต้องระบุชื่อนะครับ

00:04:12.519 --> 00:04:15.320
ลองดูจากโค้ดตัวอย่างนะครับ

00:04:16.600 --> 00:04:21.399
function add1 = x => x + 1 นะครับ

00:04:21.520 --> 00:04:25.600
เป็น function expression ในภาษา JavaScript ที่

00:04:26.960 --> 00:04:29.720
เราประกาศ function โดยไม่ต้องใส่ชื่อนะครับ

00:04:30.039 --> 00:04:33.320
anonymous function เนี่ย มันช่วยให้เกิด

00:04:33.680 --> 00:04:37.477
feature ใหม่ที่เราเรียกมันว่า higher-order function

00:04:37.560 --> 00:04:37.676
นะครับ

00:04:37.759 --> 00:04:41.437
higher-order function มันก็คือ function ที่มีการรับ

00:04:41.520 --> 00:04:44.307
function เข้าไปแล้วก็ return หรือไม่ return

00:04:44.390 --> 00:04:48.079
function ใหม่ออกมาก็ได้นะครับ

00:04:48.759 --> 00:04:51.800
feature ถัดไปเป็น closure

00:04:52.080 --> 00:04:57.400
closure เป็น combination ของ function ที่รวมตัวกันนะครับ

00:04:57.720 --> 00:05:02.920
เมื่อมีการประกาศ function เอาไว้ด้านใน function อื่น

00:05:03.160 --> 00:05:06.637
function ด้านในจะสามารถเข้าถึง argument ของ

00:05:06.720 --> 00:05:07.960
function ด้านนอกได้

00:05:09.800 --> 00:05:12.517
ตัว argument ของ function ด้านนอกเนี่ยครับ

00:05:12.600 --> 00:05:14.917
เราจะเรียกมันว่า fixed argument ของ

00:05:15.000 --> 00:05:16.920
function ด้านในนะครับ

00:05:17.880 --> 00:05:23.717
หัวข้อที่ 2 concept ของ functional programming

00:05:23.800 --> 00:05:26.280
จาก 3 feature ที่เราได้พูดถึงนะครับ

00:05:26.479 --> 00:05:29.597
มันนำมาสู่แนวคิดการเขียน functional programming

00:05:29.680 --> 00:05:30.877
ในภาษา JavaScript เนี่ย

00:05:30.960 --> 00:05:35.120
มีหลักการที่สำคัญๆ 5 หลักการนะครับ

00:05:36.639 --> 00:05:39.917
แนวคิดแรกเป็น pure function

00:05:40.000 --> 00:05:43.637
pure function เป็นแนวความคิดที่ว่าด้วย

00:05:43.720 --> 00:05:46.956
การทำให้ function เนี่ย มีความ purity นะครับ

00:05:47.039 --> 00:05:51.917
เมื่อ function รับข้อมูลเข้าไปเนี่ย

00:05:52.000 --> 00:05:56.477
function จะ return output เดิมๆ เสมอนะครับ

00:05:56.560 --> 00:06:00.077
แล้วก็ function จะต้องไม่ทำ side effect กับตัว

00:06:00.160 --> 00:06:01.920
context ด้านนอกตัวมันเองนะครับ

00:06:02.800 --> 00:06:04.200
ลองดูจากโค้ดตัวอย่าง

00:06:04.680 --> 00:06:09.757
function add2 นะครับ รับค่าเข้าไปเอาไปบวก 2

00:06:09.840 --> 00:06:13.037
เมื่อเรามีการเรียก function add2 หลายๆ ครั้ง

00:06:13.120 --> 00:06:15.320
จะเห็นว่ามัน return 3 เสมอ

00:06:16.400 --> 00:06:20.439
การเขียนโค้ดแบบนี้เราจะคาดเดาผลลัพธ์ของ function ได้

00:06:20.560 --> 00:06:25.236
แล้วก็การที่ function เนี่ย มัน return ผลลัพธ์เดิมๆ เนี่ย

00:06:25.319 --> 00:06:27.440
มันทำให้เกิดการ test ได้ง่ายขึ้นนะครับ

00:06:29.720 --> 00:06:32.757
แล้วก็แนวคิดที่ 2 function composition

00:06:32.840 --> 00:06:38.197
function composition เป็นการรวมฟังก์ชันหลายๆ ตัวเข้าด้วยกันนะครับ

00:06:38.280 --> 00:06:41.639
เพื่อ produce หรือว่าทำ computation ข้อมูลนะครับ

00:06:42.840 --> 00:06:44.160
ลองดูจากโค้ดตัวอย่าง

00:06:44.360 --> 00:06:48.120
เราจะมีฟังก์ชัน f รับค่าเข้าไปบวก 2

00:06:48.840 --> 00:06:50.599
แล้วก็ฟังก์ชัน g รับค่าเข้าไปบวก 1

00:06:51.520 --> 00:06:52.917
แล้วก็ในบรรทัดนี้นะครับ

00:06:53.000 --> 00:06:56.680
เรา compose f เข้ากับ gx แล้วก็ได้ค่า 3 ออกมา

00:06:57.400 --> 00:07:01.357
ตรงนี้ syntax ตรงนี้เราจะเรียกมันว่า function composition นะครับ

00:07:01.440 --> 00:07:05.560
หรือว่าเป็น declarative style นะครับ

00:07:07.560 --> 00:07:10.920
concept ที่ 3 avoid shared state

00:07:11.360 --> 00:07:15.597
shared state ก็คือการที่ฟังก์ชันหลายๆ ตัวเนี่ยครับ

00:07:15.680 --> 00:07:19.280
มีการเข้าถึง data ที่อยู่ด้านนอกนะครับ

00:07:19.879 --> 00:07:21.519
ลองดูจากโค้ดตัวอย่าง

00:07:23.639 --> 00:07:26.796
y2 เข้าถึง y1 กับ y2 นะครับ

00:07:26.879 --> 00:07:29.600
เข้าถึงค่า y.value นะครับ

00:07:29.879 --> 00:07:33.480
จะเห็นว่าทั้งสองฟังก์ชันเนี่ยใช้ y.value ร่วมกัน

00:07:34.160 --> 00:07:38.639
แล้วก็การเขียนโค้ดแบบเนี้ยครับ

00:07:39.319 --> 00:07:44.556
ลำดับของ function call เนี่ยจะส่งผลต่อผลลัพธ์ของระบบนะครับ

00:07:44.639 --> 00:07:46.200
ลองดูโค้ดตัวอย่าง

00:07:47.280 --> 00:07:51.520
เราเรียก y2 แล้วค่อยเรียก y1 นะครับ ผลลัพธ์จะได้ 5

00:07:52.599 --> 00:07:57.520
ในทางกลับกัน เราเรียก y1 แล้วค่อยเรียก y2 ผลลัพธ์จะได้ 6

00:07:58.280 --> 00:08:01.396
จะเห็นว่าลำดับการทำงานของฟังก์ชันเนี่ย

00:08:01.479 --> 00:08:04.560
ส่งผลต่อความแปรปรวนของผลลัพธ์ในระบบนะครับ

00:08:04.720 --> 00:08:08.600
ซึ่งตรงนี้จะต้องหลีกเลี่ยง

00:08:09.120 --> 00:08:12.560
แนวคิดที่ 4 avoid mutate state นะครับ

00:08:13.199 --> 00:08:15.440
mutate state คืออะไร

00:08:16.120 --> 00:08:19.676
mutate state คือการเข้าไปแก้ค่า object ตรงๆ นะครับ

00:08:19.759 --> 00:08:24.236
จะเห็นว่า JavaScript เนี่ยมี syntax const อยู่นะครับ

00:08:24.319 --> 00:08:29.519
แต่ว่า const เนี่ยไม่ได้สื่อความถึงว่ามันแก้ไขค่าไม่ได้นะครับ

00:08:29.759 --> 00:08:34.956
จะเห็นว่าตัวแปร a.name เนี่ยจะยังแก้ไขค่าได้เหมือนเดิมนะครับ

00:08:35.039 --> 00:08:39.717
แล้วก็ JavaScript มี feature นึง object.freeze นะครับ

00:08:39.800 --> 00:08:42.240
ที่จะช่วยทำ immutable data

00:08:42.599 --> 00:08:45.756
แต่ว่ามันทำได้แค่ระดับเดียวนะครับ

00:08:45.839 --> 00:08:51.357
จะเห็นว่า a.bar เนี่ยมันแก้ไขค่าไม่ได้ มันจะ error นะครับ

00:08:51.440 --> 00:08:54.599
แต่ a.foo.name เนี่ยยังแก้ได้เหมือนเดิม

00:08:55.279 --> 00:09:01.440
ซึ่งการใช้ object ธรรมดาแบบเนี้ยครับ เป็นสิ่งที่เราจะหลีกเลี่ยงนะครับ

00:09:02.120 --> 00:09:07.520
แล้วก็ concept ที่ 5 avoid side effect นะครับ

00:09:08.200 --> 00:09:11.000
side effect ก็คือการที่ฟังก์ชันเนี่ย

00:09:11.440 --> 00:09:14.717
มีการเข้าถึง context ด้านนอกตัวมันเองนะครับ

00:09:14.800 --> 00:09:21.397
ดูจากโค้ดตัวอย่าง y1 เข้าถึง y.value ที่อยู่ด้านนอกนะครับ

00:09:21.480 --> 00:09:23.357
ก็การทำ side effect เนี่ยจะเห็นว่า

00:09:23.440 --> 00:09:25.720
เมื่อมีการเรียกฟังก์ชัน y1 หลายๆ ครั้ง

00:09:26.160 --> 00:09:28.920
ผลลัพธ์ที่ได้จะไม่เหมือนเดิมนะครับ

00:09:29.399 --> 00:09:32.876
ตรงเนี้ยจะทำให้เราคาดเดาผลลัพธ์ของฟังก์ชันไม่ได้

00:09:32.959 --> 00:09:36.680
แล้วก็จะทำ test ได้ยากนะครับ

00:09:37.360 --> 00:09:38.960
โอเค ถัดมา

00:09:39.800 --> 00:09:44.077
เราจะประยุกต์ใช้แนวความคิดทั้ง 5 แนวความคิดของ

00:09:44.160 --> 00:09:47.477
functional programming เข้ากับการเขียน React application

00:09:47.560 --> 00:09:48.440
ได้ยังไงนะครับ

00:09:48.839 --> 00:09:51.440
ลองดูตัวอย่างแรกกันนะครับ

00:09:52.920 --> 00:09:58.680
ตัวอย่างแรกผมจะวาด header กับ logo ขึ้นมานะครับ

00:10:00.399 --> 00:10:03.117
ถ้าเราจะเอาแนวคิดแบบ functional programming มาใช้เนี่ย

00:10:03.200 --> 00:10:07.597
อันดับแรกเราจะทำ component header ให้มันเป็น pure component

00:10:07.680 --> 00:10:08.279
ก่อนนะครับ

00:10:08.760 --> 00:10:13.876
เสร็จแล้วเราก็ทำ with logo ขึ้นมาให้มันเป็น pure component

00:10:13.959 --> 00:10:14.400
เหมือนกัน

00:10:14.640 --> 00:10:20.920
เสร็จแล้วเราก็เอา with logo composition กับตัว header component

00:10:21.040 --> 00:10:25.760
ก็จะได้ผลลัพธ์เป็น with logo ที่สามารถเอาไป plugin

00:10:25.880 --> 00:10:27.957
กับ component อื่นๆ ได้นะครับ

00:10:28.040 --> 00:10:31.837
ก็ concept การเขียนโค้ดแบบนี้เราจะเรียกมันว่า

00:10:31.920 --> 00:10:34.440
function composition นะครับ

00:10:40.959 --> 00:10:45.277
โอเค ตัวอย่างถัดไปครับ avoid shared state นะครับ

00:10:45.360 --> 00:10:50.040
จะเห็นว่าเรามี component สองตัวนะครับ A กับ component B

00:10:50.560 --> 00:10:56.677
component A เนี่ย มีการเข้าถึง data.value จากด้านนอกนะครับ

00:10:56.760 --> 00:11:00.800
แล้วก็ component B เนี่ย เข้าถึง data.value ตัวเดียวกันเลย

00:11:01.279 --> 00:11:10.037
แล้วก็จะเห็นว่า component A เนี่ย มีการแก้ไขค่า data.value

00:11:10.120 --> 00:11:10.879
แล้วก็เอามาวาด

00:11:11.360 --> 00:11:14.756
ซึ่งการแก้ไขค่าตรงนี้ถือว่าเป็นการ mutation ค่าถูกไหมครับ

00:11:14.839 --> 00:11:19.876
แล้วก็ทำให้ component B เนี่ย มีการ render ที่ผิดพลาดนะครับ

00:11:19.959 --> 00:11:24.879
ก็ตรงนี้เป็นสิ่งที่เราจะหลีกเลี่ยง

00:11:25.399 --> 00:11:31.677
โอเค ตัวอย่างถัดไป ใน application จริงๆ เนี่ย

00:11:31.760 --> 00:11:34.517
เราหลีกเลี่ยงการทำ side effect ไม่ได้นะครับ

00:11:34.600 --> 00:11:38.756
เพราะว่าปกติแล้วเนี่ย application จะต้องมีการ interact

00:11:38.839 --> 00:11:40.000
กับ server

00:11:40.360 --> 00:11:43.196
มีการเรียก network มี user interaction

00:11:43.279 --> 00:11:45.200
แล้วก็มีพวก event listener ต่างๆ

00:11:45.639 --> 00:11:50.320
ดังนั้นเราจะจัดการกับ side effect action ตรงนี้ยังไงนะครับ

00:11:52.360 --> 00:11:56.637
จะเห็นว่าเราจะมี สมมุติว่า service QR payment ตรงนี้นะครับ

00:11:56.720 --> 00:12:00.839
เป็น React component ที่ทำตัวเป็น pure component นะครับ

00:12:00.959 --> 00:12:05.597
เสร็จแล้วเราจะมีการ composition ค่าจากตัว side effect

00:12:05.680 --> 00:12:06.237
ทั้งหลายนะครับ

00:12:06.320 --> 00:12:11.677
ไม่ว่าจะเป็นข้อมูลจากตัว global state แล้วก็ action ต่างๆ

00:12:11.760 --> 00:12:15.760
ในการทำ interaction กับตัว network นะครับ

00:12:16.000 --> 00:12:18.119
จะเห็นว่าเรา compose มันเข้ามา

00:12:18.959 --> 00:12:22.400
ซึ่งการเขียนโค้ดแบบนี้มันทำให้ตัว component กับตัว

00:12:22.600 --> 00:12:26.116
side effect action มีการแยกออกจากกันอย่างชัดเจนนะครับ

00:12:26.199 --> 00:12:27.957
แล้วก็มีการแก้ไขได้ง่าย

00:12:28.040 --> 00:12:33.800
แล้วก็ตัว component เนี่ยก็ยังทำ test ได้ง่ายด้วยนะครับ

00:12:34.480 --> 00:12:41.999
ตัวอย่างต่อไป เราหลีกเลี่ยงไม่ได้ในการที่จะไม่แก้ไข

00:12:42.279 --> 00:12:43.556
global state เลยนะครับ

00:12:43.639 --> 00:12:46.759
ดังนั้น การจะแก้ไข global state เนี่ยเราจะใช้

00:12:48.120 --> 00:12:50.717
immutable data structure library นะครับ

00:12:50.800 --> 00:12:55.837
เช่น immutable.js หรือว่า immer ในการช่วยให้เราแก้ไขค่า

00:12:55.920 --> 00:12:57.800
ได้ง่ายขึ้นนะครับ

00:13:01.079 --> 00:13:07.160
โอเค ก็สุดท้ายนะครับ ผมอยากจะฝากทิ้งท้ายเอาไว้นะครับว่า

00:13:08.480 --> 00:13:10.637
หลักการเกี่ยวกับ functional programming เนี่ย

00:13:10.720 --> 00:13:12.440
มีทั้งหมด 3 หลักการนะครับ

00:13:13.079 --> 00:13:16.479
pure function over shared state and side effect

00:13:16.839 --> 00:13:20.597
function composition over imperative flow control

00:13:20.680 --> 00:13:24.839
แล้วก็ immutability over mutable data นะครับ

00:13:25.519 --> 00:13:32.037
สุดท้าย KBTG จะจัดงาน meetup ร่วมกับสมาคม

00:13:32.120 --> 00:13:33.519
โปรแกรมเมอร์ไทยนะครับ

00:13:33.959 --> 00:13:36.600
ในวันพฤหัสบดีที่ 27 กุมภาพันธ์นะครับ

00:13:38.000 --> 00:13:39.800
ที่สยาม Innovation District

00:13:40.440 --> 00:13:44.876
สำหรับคนที่สนใจนะครับ สแกน QR code มาดูรายละเอียด

00:13:44.959 --> 00:13:45.719
ได้เลยนะครับ

00:13:45.839 --> 00:13:51.196
ในงานจะมี speaker จาก KBTG แล้วก็ speaker รับเชิญนะครับ

00:13:51.279 --> 00:13:53.756
มาพูดเกี่ยวกับเทคนิคการทำงานเกี่ยวกับ ReactJS

00:13:53.839 --> 00:13:55.719
แล้วก็ frontend application นะครับ

00:13:56.399 --> 00:14:01.357
ก็สำหรับวันนี้ ผมก็จะมีหัวข้อพูดเพียงเท่านี้ครับ

00:14:01.440 --> 00:14:02.400
ก็ขอบคุณมากครับผม

00:14:03.440 --> 00:14:07.357
ขอบคุณค่ะ ขอบคุณคุณณัฐพลนะคะ จาก KBTG นะคะ

00:14:07.440 --> 00:14:09.116
สปอนเซอร์ที่น่ารักของเราค่ะ

00:14:09.199 --> 00:14:10.876
เดี๋ยวเราพักเบรกประมาณ 10 นาที

00:14:10.959 --> 00:14:12.517
เข้าห้องน้ำพักผ่อนตามอัธยาศัย

00:14:12.600 --> 00:14:14.477
เดี๋ยวกลับมาเจอกันในหัวข้อถัดไปค่ะ

00:14:14.560 --> 00:14:15.199
ขอบคุณค่ะ

00:14:15.519 --> 00:14:17.840
Let's take a break for 10 minutes. Thank you.