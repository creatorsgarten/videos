WEBVTT

00:00:00.100 --> 00:00:01.200
พี่ปุ๋ยพร้อมมั้ยครับ

00:00:01.200 --> 00:00:03.000
โอเคพร้อมแล้วครับผม

00:00:03.000 --> 00:00:03.800
ขอเรียนเชิญเลยครับผม

00:00:03.800 --> 00:00:06.100
ขอส่งไมค์ให้กับพี่ปุ๋ยเลยนะครับ

00:00:06.100 --> 00:00:08.300
โอเคนะครับ เดี๋ยวจับเวลาแป๊บนึงนะครับ

00:00:08.300 --> 00:00:11.800
ครับผม สวัสดีทุกท่านนะครับ ก็ชื่อสมเกียรตินะครับ

00:00:11.800 --> 00:00:16.300
ก็วันนี้นะครับเรามาพูดเรื่อง testing นะ JavaScript testing

00:00:16.300 --> 00:00:19.900
เนาะก็ 0-7 อะไรก็ไม่รู้ ก็คือ everyday นั่นเองนะครับ

00:00:19.900 --> 00:00:24.600
ก็มาดูกันเนาะ เขียน blog อะ จบละนะครับ

00:00:24.600 --> 00:00:28.800
เริ่มที่คำถามเนาะ พอดีเพิ่งมีคำถามที่สมาคมโปรแกรมเมอร์

00:00:28.800 --> 00:00:33.000
นี่ใช่ไหม คำถามนี้ ตอบไงดีครับ

00:00:33.000 --> 00:00:36.100
อันนี้ใครตอบอะไรบ้างครับ

00:00:36.100 --> 00:00:40.300
ที่บริษัททำกันมั้ยครับ มีคำถามนี้มั้ย

00:00:40.300 --> 00:00:43.100
เป็นคำถามอะไรเค้าเรียกว่าอะไรนะ ไก่กับไข่ใช่มั้ย

00:00:43.100 --> 00:00:46.400
ไม่รู้จะตอบอะไรดีนะครับ

00:00:46.400 --> 00:00:48.700
ผมว่าแต่ละที่ แต่ละ business เนาะ

00:00:48.700 --> 00:00:52.200
มีคำตอบที่อาจจะเหมือนหรือแตกต่างกันก็ว่าไปนะครับ

00:00:52.200 --> 00:00:56.200
แต่ผมว่าเห็นก่อนว่านี่คือคำถามที่ในองค์กรจะถามนะครับ

00:00:56.200 --> 00:00:57.900
แต่ถ้ามีปัญหา เค้าจะไม่ถามละ

00:00:57.900 --> 00:01:01.300
เค้าจะถามว่า ทำไมมี bug ใช่ไหม ถูกไหมนะครับ

00:01:01.300 --> 00:01:04.400
ก็ลองดูเนาะ นะครับ เราจะทำอย่างไรนะครับ

00:01:04.400 --> 00:01:07.000
ประเด็นคือ ผมจะถามเสมอคือ

00:01:07.000 --> 00:01:09.200
ระหว่าง quality กับ quantity เราเลือกอะไรครับ

00:01:09.200 --> 00:01:10.500
ปัจจุบันที่บริษัทเรา

00:01:10.500 --> 00:01:12.600
quality คือคุณภาพนะครับ

00:01:12.600 --> 00:01:15.500
quantity คือทำให้เสร็จมากที่สุดเท่าที่ทำได้

00:01:15.500 --> 00:01:20.700
เค้าเรียกว่าอะไรครับ มีเวลาสร้างเนาะ แต่ไม่มีเวลาทำให้ดี ใช่ไหม

00:01:20.700 --> 00:01:23.500
เพราะอะไรครับ เราจะสร้างให้เสร็จเพื่อตรงเวลาใช่ไหม นะครับ

00:01:23.500 --> 00:01:26.800
เสร็จแล้วก็เราจะมีเวลามาแก้ bug ใช่ไหม

00:01:26.800 --> 00:01:28.100
แต่ไม่มีเวลาทำให้ดี นะครับ

00:01:28.100 --> 00:01:32.600
มันดูขัดแย้งใช่ไหม เค้าเรียกว่า ขว้างงูไม่พ้นคอ เนาะ อันนี้

00:01:32.600 --> 00:01:36.600
นะครับ ก็ลองดูนะครับ ดังนั้น หลายๆ คนจะเป็นคนกลุ่มนี้ไหม

00:01:36.600 --> 00:01:40.500
ใคร We Love Bug บ้างครับ ใครชอบครับ ใครรัก

00:01:40.500 --> 00:01:41.900
ใครไม่เคยเจอ bug บ้าง ยกมือ

00:01:41.900 --> 00:01:44.500
แสดงว่าทุกคนเจอใช่ไหม ถูกไหม

00:01:44.500 --> 00:01:46.700
ดังนั้นเราอยู่กับมันใช่ไหม นะครับ

00:01:46.700 --> 00:01:49.700
ประเด็นคือ เราจะใช้ชีวิตกับมันอย่างไรบ้างนะครับ

00:01:49.700 --> 00:01:53.200
นี่คือเป็นสิ่งนึงเนาะ นะครับ

00:01:53.200 --> 00:01:55.000
แล้วที่สำคัญคือเรื่อง bug เนาะ นะครับ

00:01:55.000 --> 00:01:57.700
มันมีคำว่า cost of bug เนาะ นะครับ

00:01:57.700 --> 00:02:01.500
คือ bug นะครับ มันมีค่าใช้จ่าย

00:02:01.500 --> 00:02:05.200
คำถามก็คือ bug ปัจจุบันเราเจอที่ไหนเยอะสุดครับ

00:02:05.200 --> 00:02:06.900
เจอที่ dev เนาะ ใช่ไหมครับ

00:02:06.900 --> 00:02:12.500
ส่วน production ไม่ค่อยเจอหรอก แต่พอเจอปุ๊บ บรรลัยใช่ไหม ถูกไหมครับ

00:02:12.500 --> 00:02:15.900
เพราะอะไรครับ ถึงแม้คุณจะมี bug น้อย

00:02:15.900 --> 00:02:19.100
แต่ bug นั้นอาจจะก่อให้เกิดเค้าเรียกว่าค่าใช้จ่ายมหาศาล ถูกไหม

00:02:19.100 --> 00:02:24.600
แล้วก็จะโดนด่าเนาะว่า ทำไมงานขึ้นเร็วใช่ไหม แต่ bug เยอะ

00:02:24.600 --> 00:02:28.000
มีคุ้นๆ มั้ย time to market ใช่ไหม

00:02:28.000 --> 00:02:30.500
แต่พอ time to market ดีปุ๊บ bug ก็เยอะ ใช่ไหม

00:02:30.500 --> 00:02:33.400
อันนี้ก็ต้อง trade off เนาะ

00:02:33.400 --> 00:02:36.900
แต่ในแง่ของการจัดการเนาะ เราอยากได้อะไรครับ คุณภาพดีเนาะ

00:02:36.900 --> 00:02:42.300
เร็ว แล้วก็คุณภาพดี เร็ว แล้วก็ถูก ใช่ไหม นะครับ

00:02:42.300 --> 00:02:46.400
ไปหาได้ที่ไหนครับ มีใครคุ้นๆ มั้ย นะครับ

00:02:46.400 --> 00:02:47.200
ไม่ค่อยเจอ นะครับ

00:02:47.200 --> 00:02:50.100
ดังนั้นเราก็ต้องเลือกนะครับ

00:02:50.100 --> 00:02:53.300
ใครเพิ่งขึ้นโปรเจคเมื่อคืนบ้างครับ

00:02:53.300 --> 00:02:56.000
เพิ่งขึ้นใช่ไหมนะ เยี่ยมมั้ย นะครับ

00:02:56.000 --> 00:03:00.700
ขั้นตอนแรกก่อนเอาขึ้น production ต้องทำอะไรครับ

00:03:00.700 --> 00:03:05.700
ไหว้พระนะครับเนาะ หน้าตึก ใช่ไหมครับ นะครับ ตอนทำไม่ถาม

00:03:05.700 --> 00:03:09.300
ตอนทำไม่ขอใช่ไหม แต่จะขึ้น ขอจังใช่ไหม ว่าอะไรครับ

00:03:09.300 --> 00:03:13.400
ระบบ deploy แล้วไม่มีปัญหาเนาะ จากที่ผ่านมาทุกครั้งเป็นไงครับ

00:03:13.400 --> 00:03:17.200
ประวัติดีมาก มีปัญหาทุกรอบ ใช่ไหม ดังนั้น

00:03:17.200 --> 00:03:20.100
ลองดูนะครับว่าเราเรียนรู้หรือเปล่า

00:03:20.100 --> 00:03:25.800
ประเด็นคือ กลับมาที่ของเราเนาะ ผมกำลังพูดถึงก็คือเรื่องของคุณภาพ

00:03:25.800 --> 00:03:28.800
หนึ่งในคุณภาพคือเรื่องของอะไรครับ เรื่องของ testing เนาะ

00:03:28.800 --> 00:03:31.200
ของเราเป็นอะไรครับ JavaScript นะครับ

00:03:31.200 --> 00:03:33.700
เราจะพูดถึงเรื่องของ JavaScript testing นะครับว่า

00:03:33.700 --> 00:03:39.800
ในแง่ของการเทส ที่เซคชั่นก่อนหน้าพูดถึงเรื่องของพวก pyramid testing เนาะ

00:03:39.800 --> 00:03:45.500
ใครยังทำแบบรูปนี้บ้าง ยกมือครับ manual เยอะๆ automate น้อยๆ

00:03:45.500 --> 00:03:48.800
ใครทำอยู่บ้างครับ ไม่ทำเนาะ ที่นี่ไม่น่าทำนะครับเนาะ

00:03:48.800 --> 00:03:52.800
ใครจะบ้ามานั่งกดๆๆ ทุกวันใช่ไหม คงไม่มีใครบ้าขนาดนั้น

00:03:52.800 --> 00:04:00.000
เราก็ต้องเริ่มเปลี่ยนใช่ไหม ว่าทำแบบนี้ไม่ค่อยสนุกเนาะ

00:04:00.000 --> 00:04:05.800
ในองค์กรใหญ่ๆ ชอบรูปนี้ อะไรหวานๆ จะไม่ค่อยดีใน software development เนาะ

00:04:05.800 --> 00:04:09.800
ลองดูนะครับ อันนี้ pyramid เนาะ ไม่ค่อยมีใครทำ

00:04:09.800 --> 00:04:13.400
นี่เราชอบทำแบบนี้ใช่ไหม นะครับ เรามี manual test

00:04:13.400 --> 00:04:17.399
เรามีนักพัฒนา ใช่ไหมครับ เรามีอะไรครับ automation

00:04:17.399 --> 00:04:22.300
ดังนั้นมี 3 ทีมเลยใช่ไหม ทดสอบเคสเดียวกันนี่แหละ 3 ทีม

00:04:22.300 --> 00:04:26.400
จะได้ไม่ฮั้วกันนะครับเนาะ แล้วพอผ่าน 3 ทีมปุ๊บ

00:04:26.400 --> 00:04:31.600
ทุกอย่างผ่านหมด ยกเว้น production ใช่ไหม
แล้วค่าใช้จ่ายคูณ 3 เป็นหรือเปล่า ไม่แน่ใจ

00:04:31.600 --> 00:04:34.800
หลังๆ มา ผมชอบรูปนี้เนาะ

00:04:34.800 --> 00:04:37.000
นี่คุ้นๆ มั้ย

00:04:37.000 --> 00:04:39.900
ผมเรียกว่าแปลเป็นไทยคือ ทดสอบจนได้ถ้วย ใช่ไหม

00:04:39.900 --> 00:04:45.700
ประเด็นคือเค้ากำลังโฟกัสที่อะไรครับ integration กับ end-to-end ให้มากเนาะ

00:04:45.700 --> 00:04:49.000
เพราะว่าระบบงานของเราเนาะ ใช่ไหมครับ

00:04:49.000 --> 00:04:55.400
ที่นี่ใครเขียน unit test บ้าง ยกมือหน่อย การันตีไหม ว่ารวมแล้วจะ work

00:04:55.400 --> 00:04:57.200
นะครับ coverage 100% ใช่ไหม ที่ไหนมีบ้างครับ

00:04:57.200 --> 00:04:59.400
coverage เราต้อง 100% ใช่ไหม

00:04:59.400 --> 00:05:02.300
ก็ 100% นะ แต่เขียนไม่ครบใช่ไหม

00:05:02.300 --> 00:05:04.600
เขียนโค้ดไม่ครบ requirement ถูกไหม

00:05:04.600 --> 00:05:08.100
เออเนอะ แต่เทส แต่ coverage 100% ก็มี bug ใช่ไหม

00:05:08.100 --> 00:05:09.300
ถูกไหม เออเนอะ

00:05:09.300 --> 00:05:11.700
ดังนั้น ตรงนี้แหละนะครับ คุณเขียน unit ปุ๊บ

00:05:11.700 --> 00:05:13.100
มันคือเร็วใช่ไหม

00:05:13.100 --> 00:05:16.700
แต่เราไม่การันตีว่ามันจะเวิร์กหรือเปล่า ดังนั้น

00:05:16.700 --> 00:05:19.200
ในการ deliver ซอฟต์แวร์

00:05:19.200 --> 00:05:23.000
หรือว่าทดสอบซอฟต์แวร์ จำเป็นจะต้องมีการเทสที่หลากหลาย level

00:05:23.000 --> 00:05:26.700
แต่ละจำนวนก็แล้วแต่เรา ถูกไหมครับ เออ นี่คือมุมมองเนอะ

00:05:26.700 --> 00:05:29.500
ประเด็นคือ เรากำลังการเทสนะครับเนอะ

00:05:29.500 --> 00:05:30.900
ผมไปฟังที่นึงมาเนอะ

00:05:30.900 --> 00:05:34.900
เค้าบอกว่าการเทสคืออะไรครับ level ของความเชื่อมั่น

00:05:34.900 --> 00:05:38.100
ง่ายๆ เลย ทุกคนส่วนใหญ่เป็นนักพัฒนาเนอะ

00:05:38.100 --> 00:05:44.000
ความเชื่อมั่นของเราต่อบริษัทดีไหมครับ

00:05:44.000 --> 00:05:45.600
วันดีคืนดีนะ ยกตัวอย่างเนอะ

00:05:45.600 --> 00:05:47.000
เรากำลังแก้โค้ดบรรทัดเดียวใช่ไหม

00:05:47.000 --> 00:05:52.200
องค์กรเราเสียไหม ทุกครั้งที่ deploy จะเกิดอะไรขึ้นบ้าง

00:05:52.200 --> 00:05:56.300
คำตอบคือ เดี๋ยวก็รู้ใช่ไหม deploy ไปก่อน เดี๋ยวก็รู้

00:05:56.300 --> 00:05:58.200
ใครรู้คนแรกครับ คนใช้งาน

00:05:58.200 --> 00:06:00.400
ทีมพัฒนารู้เป็นคนสุดท้าย

00:06:00.400 --> 00:06:02.900
ไม่น่าใช่เนอะ อันนี้เป็นเรื่องตลกร้ายใช่ไหม

00:06:02.900 --> 00:06:06.700
ดังนั้น เค้าบอกว่าการทดสอบนะครับเนอะ เป็นอะไรครับ

00:06:06.700 --> 00:06:10.000
level ของความเชื่อมั่น ว่าเราเชื่อมั่นหรือเปล่า

00:06:10.000 --> 00:06:13.200
ถ้าใครบอกว่าผ่านมา 5 ปี เราพัฒนาซอฟต์แวร์เนอะ

00:06:13.200 --> 00:06:16.800
ขึ้น production ไม่เคยมี bug เลย ก็ไม่ต้องทดสอบครับ

00:06:16.800 --> 00:06:19.900
เพราะว่าประวัติเราดี ใครเป็นอย่างงี้บ้างครับ ยกมือหน่อย

00:06:19.900 --> 00:06:22.700
ประวัติเราดี เขียนโค้ดมาทั้งชีวิตไม่เคยมี bug เลย

00:06:22.700 --> 00:06:24.100
บน production

00:06:24.100 --> 00:06:24.900
คงไม่มีใช่ไหม

00:06:24.900 --> 00:06:28.400
ดังนั้น ตรงนี้แหละเราต้องสร้างถูกไหมครับเนอะ

00:06:28.400 --> 00:06:32.300
ประเด็นคือการสร้างความเชื่อมั่นมันเหมือนก้นหอยครับ

00:06:32.300 --> 00:06:36.800
มันค่อยๆ ไปเรื่อยๆ ใช่ไหม แต่วันดีคืนดีเนอะ

00:06:36.800 --> 00:06:38.600
เราพลาดครั้งเดียว

00:06:38.600 --> 00:06:42.200
เค้าจะจำครั้งที่เราพลาดเนี่ยครับ เราทำดีมาทั้งปีใช่ไหม

00:06:42.200 --> 00:06:45.800
ยกตัวอย่างเนอะ เพิ่งผ่านมา ใครเพิ่งได้โบนัสนะ ใช่ไหม เออเนอะ

00:06:45.800 --> 00:06:51.600
ทั้งปีทำดีมาตลอดใช่ไหม ตอนประเมิน เดือนอะไร ปลายปีใช่ไหม

00:06:51.600 --> 00:06:55.000
ธันวาคมใช่ไหม พฤศจิกายนตุลาคม ผิดครั้งเดียวตรงนั้นแหละ

00:06:55.000 --> 00:06:58.600
หัวหน้าจำเราตรงนั้นนะ ถูกไหม มีใครเป็นไหม

00:06:58.600 --> 00:07:03.400
อันนี้คือเรื่องของความเชื่อมั่น ดังนั้น สิ่งที่เกิดขึ้นนะก็คือ

00:07:03.400 --> 00:07:06.500
เค้าพยายามเนอะ จะเปลี่ยนนะก็คือ การทดสอบ

00:07:06.500 --> 00:07:11.300
ให้มีความเชื่อมั่นมากขึ้น ประเด็นคือ การทดสอบของเราเป็นอย่างไร

00:07:11.300 --> 00:07:15.200
หลายๆ ครั้งการทดสอบคือ phase นั่นหมายความว่าอะไรครับ

00:07:15.200 --> 00:07:18.200
ถ้านักพัฒนาบอกว่าเสร็จ ค่อยทดสอบ ถูกไหม

00:07:18.200 --> 00:07:21.300
ใครทดสอบ นักพัฒนาบอกว่าทดสอบเนอะ ในนี้นักพัฒนาใช่ไหม

00:07:21.300 --> 00:07:26.700
ทดสอบโค้ดตัวเองไหม ว่าเวิร์ก ทดสอบไหมครับ ทดสอบโค้ดตัวเองเนอะ

00:07:26.700 --> 00:07:31.100
ยกตัวอย่าง ตอนนี้เรามี feature ประมาณ 10 feature เนอะ

00:07:31.100 --> 00:07:33.100
แล้วเวิร์กบน production ไม่เคยมี bug เลยนะ

00:07:33.100 --> 00:07:36.200
เรากำลังเพิ่มอีก 5 feature เป็น 15 feature เนอะ

00:07:36.200 --> 00:07:40.100
คำถามคือ 5 feature ของเราเสร็จเมื่อไหร่ครับ

00:07:40.100 --> 00:07:43.300
คำว่าบอกว่า 5 feature นี้เสร็จคืออะไร

00:07:43.300 --> 00:07:46.800
1 คือ deadline ใช่ไหม ถูกไหม จะถึงแล้ว

00:07:46.800 --> 00:07:49.600
ต้องส่งใช่ไหม เสร็จใช่ไหมครับ

00:07:49.600 --> 00:07:54.600
2 คือเราทดสอบ 5 feature ไหมว่า work

00:07:54.600 --> 00:07:59.600
ทดสอบใช่ไหม เหลืออีก 4 feature ที่ work ทดสอบไหม

00:07:59.600 --> 00:08:03.200
คำตอบคือแล้วแต่ใช่ไหม เพราะอะไรครับ

00:08:03.200 --> 00:08:06.500
เราไม่มีเวลา ใครเป็นอย่างนี้ เนี่ยคือปัญหาที่เกิดขึ้น

00:08:06.500 --> 00:08:08.000
เรื่องของความเชื่อมั่น

00:08:08.000 --> 00:08:11.600
ดังนั้นครับ เราเลยต้องเปลี่ยนวิธีคิดใหม่ว่า

00:08:11.600 --> 00:08:14.900
การทดสอบมันจะเกิดขึ้นอยู่ตลอดเวลาถูกไหมครับ

00:08:14.900 --> 00:08:18.200
แล้วจะต้องทำอะไรครับ ต้องทำการทดสอบตั้งแต่ต้น

00:08:18.200 --> 00:08:21.900
ยันถึงปัจจุบัน ให้บ่อยที่สุดเท่าที่ทำได้

00:08:21.900 --> 00:08:25.300
นี่คือไอเดีย ดังนั้นการทดสอบมันเลยเป็นอะไรครับ

00:08:25.300 --> 00:08:27.400
เป็นเรื่องของ activity หรืออะไรครับ

00:08:27.400 --> 00:08:30.600
กิจกรรมหรือสิ่งที่เกิดขึ้นอยู่ตลอดเวลาครับ

00:08:30.600 --> 00:08:32.799
ตรงนี้เป็นมุมมอง เพื่อให้ได้อะไรครับ

00:08:32.799 --> 00:08:36.000
เพื่อให้ได้เรื่องของ feedback ที่รวดเร็วขึ้นครับ

00:08:36.000 --> 00:08:39.000
เพราะว่าแต่ละที่ feedback ไม่เหมือนกัน

00:08:39.000 --> 00:08:43.500
บางที่บอกว่า 1 เดือน พัฒนาไปแล้ว 1 เดือนค่อยดูว่า work ไม่ work

00:08:43.500 --> 00:08:47.900
ก็ถือว่าเร็วแล้ว บางที่ไม่ถึงวัน บางที่ขอเป็นรายชั่วโมง

00:08:47.900 --> 00:08:52.100
บางที่เป็นรายนาทีครับ อันนี้คืออยู่ที่ตกลงร่วมกันครับ

00:08:52.100 --> 00:08:56.300
ดังนั้น เรื่องของ feedback loop จึงสำคัญมากๆ ครับ

00:08:56.300 --> 00:08:59.200
แล้วอย่างที่บอกก็คือ เรื่องของการทดสอบที่ดีครับ

00:08:59.200 --> 00:09:01.000
1 คือเร็ว

00:09:01.000 --> 00:09:06.100
2 คือ อันนี้ยากมากครับ เราจะทดสอบแต่ละระบบอย่างไรครับ

00:09:06.100 --> 00:09:09.700
ให้เป็นอิสระแก่กัน เค้าเรียกว่า isolate หรือว่า independent

00:09:09.700 --> 00:09:10.600
คือเป็นอิสระ

00:09:10.600 --> 00:09:16.400
3 คือ การทดสอบครับ หลายๆ ครั้ง repeat ไม่ค่อยได้ครับ ใช่ไหม

00:09:16.400 --> 00:09:19.500
รันตอนเช้าผ่านใช่ไหม ตอนสาย อุ๊ย ทำไมไม่ผ่าน

00:09:19.500 --> 00:09:22.100
ตอนบ่ายผ่านซะงั้น ตอนเย็นไม่ผ่านอีกครับ

00:09:22.100 --> 00:09:26.200
แล้วรันบนเครื่องเราโอเค เครื่องเพื่อนไม่โอเคครับ

00:09:26.200 --> 00:09:31.500
มีเหมือนไม่มีใช่ไหม ไอ้ตรงนี้ก็เรื่องของ repeat ทำได้ไหมครับ

00:09:31.500 --> 00:09:35.600
แล้วอีกเรื่องนึงคือเรื่องของอะไรครับ แต่ละ case ครับ

00:09:35.600 --> 00:09:39.300
เราทำการ verify ครอบคลุมรึเปล่าครับ

00:09:39.300 --> 00:09:43.800
ไอ้ตรงนี้เป็นมุมมองที่เกิดขึ้น ที่เราจะต้องวิเคราะห์

00:09:43.800 --> 00:09:45.600
หรือว่าเลือกที่จะทำครับ

00:09:45.600 --> 00:09:49.300
เพราะเป็นอย่างนี้แล้ว เทสที่ดีเป็นยังไงครับ

00:09:49.300 --> 00:09:53.800
สิ่งที่อยากให้ดูต่อคือ แล้วคุณเทสตอนไหนครับ

00:09:53.800 --> 00:09:56.000
ไม่รู้นะ คุณจะเขียนโค้ดแบบไหน

00:09:56.000 --> 00:10:01.800
มันจะมีคำว่า test first แล้วก็ test last

00:10:01.800 --> 00:10:03.900
นะครับ 2 คำนี้ไม่รู้แปลเป็นไทยว่าอะไรเนาะ

00:10:03.900 --> 00:10:06.200
แต่ผมแปลแบบนี้

00:10:06.200 --> 00:10:09.300
นั่นหมายความว่าอะไรครับ

00:10:09.300 --> 00:10:10.900
คุณคิดเนาะ คุณทำก่อนเนาะ

00:10:10.900 --> 00:10:14.500
คือเขียน code ก่อน แล้วค่อยคิดว่าจะ test ยังไง

00:10:14.500 --> 00:10:18.800
กับคิดก่อนว่าจะ test ยังไง แล้วค่อยเขียน code

00:10:18.800 --> 00:10:22.100
ปกติเราทำแบบไหนครับ หรือเขียนให้เสร็จก่อนใช่ไหม

00:10:22.100 --> 00:10:24.300
แล้วค่อยมาดูว่า โอเค เสร็จแล้ว

00:10:24.300 --> 00:10:26.100
ค่อยคิดว่าจะทดสอบอย่างไร

00:10:26.100 --> 00:10:28.900
เราจะพบว่าอะไรครับ มันยากเนาะ พอยากปุ๊บ

00:10:28.900 --> 00:10:31.400
อะไรที่ยากเราจะบอกว่า เดี๋ยวก่อนใช่ไหม

00:10:31.400 --> 00:10:33.700
เดี๋ยวก่อนปุ๊บก็เพิ่ม feature ไปเรื่อย เดี๋ยวๆ

00:10:33.700 --> 00:10:36.300
สุดท้ายคืออะไรครับ โอเค ผ่านไป 1 เดือนหรือ 2 เดือน

00:10:36.300 --> 00:10:39.100
ค่อยให้ทดสอบละกัน แล้วมาคิดกันว่าอะไรครับ

00:10:39.100 --> 00:10:42.800
จะทดสอบกันอย่างไร นะครับ ก็ชิบหายแน่นอนใช่ไหม เออเนาะ

00:10:42.800 --> 00:10:45.600
ยิ่งอะไรครับ code เมื่อเวลาเนาะ

00:10:45.600 --> 00:10:47.600
เมื่อ code เกิดขึ้นมาแล้วอะไรครับ

00:10:47.600 --> 00:10:50.800
เราปล่อยไว้นาน ปล่อยไว้นานๆ แล้วค่อยมาทดสอบ

00:10:50.800 --> 00:10:52.900
มันจะทดสอบยาก

00:10:52.900 --> 00:10:57.000
นะครับเนาะ แต่อะไรครับ เขาบอกว่าคน IT เนาะ

00:10:57.000 --> 00:10:58.900
ชอบอะไร มักจะไม่ทำ

00:10:58.900 --> 00:11:01.700
ถูกไหม นะครับ เกลียดอะไร มักจะทำ

00:11:01.700 --> 00:11:04.300
ไปดูได้ครับที่บริษัทเรานะเนาะ

00:11:04.300 --> 00:11:05.900
เราเกลียดอะไรครับ เราเกลียด bug ใช่ไหม

00:11:05.900 --> 00:11:08.500
แต่เราสร้างทุกวัน

00:11:08.500 --> 00:11:11.200
ถูกป่ะ เราอยากจะ deploy ทั้งวันใช่ป่ะ ตอนไหนก็ได้

00:11:11.200 --> 00:11:12.400
แต่ลองดูนะครับ

00:11:12.400 --> 00:11:15.300
เราส่วนใหญ่หลายๆ ที่ชอบ deploy ตอนไหน

00:11:15.300 --> 00:11:17.600
หลังเที่ยงคืนใช่ป่ะ

00:11:17.600 --> 00:11:21.100
แล้วก็อะไรครับ ก่อน 6:00 น. ทำไมอ่ะ

00:11:21.100 --> 00:11:22.200
ไม่มีใครใช้

00:11:22.200 --> 00:11:26.100
เราไงใช้อยู่ เราไม่ใช่คนใช้หรอก ถูกป่ะ นะครับ

00:11:26.100 --> 00:11:29.400
ดังนั้น นี่คือมุมมองเนาะที่ผมอยากให้เห็นว่า

00:11:29.400 --> 00:11:32.800
คุณจะ test first หรือ test last มันคืออยู่กระบวนการคิด

00:11:32.800 --> 00:11:33.500
ถูกป่ะ

00:11:33.500 --> 00:11:36.500
นี่คือไอเดียที่ผมให้เห็นเนาะ

00:11:36.500 --> 00:11:40.700
ดังนั้น เวลาที่เราจะเริ่มกระบวนการพัฒนาเนี่ย

00:11:40.700 --> 00:11:44.700
สิ่งที่เกิดขึ้นคือเราต้องรู้ก่อนว่าเราทำอะไร

00:11:44.700 --> 00:11:48.300
คำว่าทำอะไรคือต้องเขียนออกมาให้ชัดว่าอะไรครับ

00:11:48.300 --> 00:11:51.000
สุดท้ายแล้วจะต้องเกิดอะไรขึ้นบ้าง

00:11:51.000 --> 00:11:55.900
จากนั้นคุณค่อยลงมือทำ

00:11:55.900 --> 00:11:59.500
นี่คือมุมมองที่ผมอยากให้เห็นก่อน

00:11:59.500 --> 00:12:03.600
เพราะเป็นแบบนี้ ในแง่ของการพัฒนา software เนี่ย

00:12:03.600 --> 00:12:06.300
ที่บอกว่าเราเขียน 1 เดือนแล้วค่อยมาทดสอบเนี่ย

00:12:06.300 --> 00:12:09.500
น่าจะต้องเริ่มเปลี่ยนวิธีการใหม่เนาะ

00:12:09.500 --> 00:12:14.400
หนึ่งในวิธีการนั้นที่ผมชอบใช้คือ iterative and incremental

00:12:14.400 --> 00:12:16.300
ผมไม่รู้นะใครจะใช้อะไร แต่ผมบอกว่า

00:12:16.300 --> 00:12:19.600
ผมโฟกัสที่การส่งมอบ feature

00:12:19.600 --> 00:12:24.400
ไม่ว่าคุณจะเขียน unit test กี่เคส เป็นหมื่นเคส แสนเคส

00:12:24.400 --> 00:12:25.800
นั่นคือเรื่องของคุณถูกป่ะ

00:12:25.800 --> 00:12:30.500
แต่สุดท้าย feature คุณต้อง meet ตาม requirement ถูกป่ะ

00:12:30.500 --> 00:12:38.100
ดังนั้น สิ่งที่เกิดขึ้น เราควรจะต้องค่อยๆ สร้างถูกป่ะ

00:12:38.100 --> 00:12:40.900
แต่ละ feature ไม่ว่าเล็กหรือใหญ่เนาะ

00:12:40.900 --> 00:12:44.100
บางคนเรียกว่า story บางคนเรียกว่า flow ก็ว่าไป

00:12:44.100 --> 00:12:47.500
feature เสร็จ คำว่าเสร็จคืออะไรครับ

00:12:47.500 --> 00:12:49.000
1. เขียน code เสร็จถูกป่ะ

00:12:49.000 --> 00:12:51.200
2. ทดสอบเสร็จ

00:12:51.200 --> 00:12:56.600
ถึงจะบอกว่าเสร็จ เค้าเรียกว่าอะไรครับ done และ done
ส่วนใหญ่จะเป็น done และ undone

00:12:56.600 --> 00:12:58.800
ถูกป่ะ คืออะไรครับ เขียน code เสร็จ

00:12:58.800 --> 00:13:00.600
ที่ไหนมี board ทำงานบ้างครับ

00:13:00.600 --> 00:13:05.900
มี coding แล้วก็ ready to test, prepare to test, waiting to test

00:13:05.900 --> 00:13:09.000
แล้วก็ tested ใช่ป่ะ

00:13:09.000 --> 00:13:14.500
คุ้นๆ มั้ย แสดงว่างานที่เราเขียนแล้ว งานที่เราทำไม่เคยเสร็จเลยครับ

00:13:14.500 --> 00:13:20.100
เพราะอะไรครับ waiting to test ทำไมคนทำไม่ test อ่ะ

00:13:20.100 --> 00:13:21.700
ถูกป่ะ แล้วเราบอกว่าเสร็จได้ไง

00:13:21.700 --> 00:13:25.300
แสดงว่าเรากำลังโกหกกันใช่ป่ะ หรืออะไรฮะ

00:13:25.300 --> 00:13:27.700
ถ้าแน่จริงหา bug ให้เจอ เดี๋ยวแก้ให้ใช่ป่ะ

00:13:27.700 --> 00:13:29.500
ใครเป็นบ้างฮะ

00:13:29.500 --> 00:13:32.100
ถ้าแน่จริงใช่ป่ะ เราสายซ่อนใช่ป่ะ นะฮะ

00:13:32.100 --> 00:13:33.700
ซ่อนเก่งนะ เออเนาะ

00:13:33.700 --> 00:13:36.400
แต่ถ้าเจอปุ๊บ อ๋อ น่าจะมีปัญหานิดหน่อย

00:13:36.400 --> 00:13:38.200
อธิบายไม่ได้ด้วยนะฮะ เออเนาะ

00:13:38.200 --> 00:13:41.100
คนอะไร debug ไม่เป็นแต่โค้ดที่เราเขียนเองนะฮะ เออเนาะ

00:13:41.100 --> 00:13:43.800
ใครเป็นบ้างฮะ โค้ดชุดนี้ใครเขียน เรา

00:13:43.800 --> 00:13:46.600
แต่เราไม่รู้ว่ามันทำงานอย่างไร ถูกป่ะ เออเนาะ

00:13:46.600 --> 00:13:51.100
ดังนั้นไอ้ตรงนี้ครับเนาะ พอ feature เพิ่มขึ้นเรื่อยๆ ด้วย นะครับ

00:13:51.100 --> 00:13:55.900
เราจะค่อยๆ ทำไป เค้าเรียกว่า feature base เนาะ

00:13:55.900 --> 00:13:57.600
feature by feature

00:13:57.600 --> 00:14:00.000
เดินไปข้างหน้าทีละก้าว นะครับ

00:14:00.000 --> 00:14:03.100
เราจะไปข้างหน้าโดยที่ไม่ย้อนกลับถูกป่ะ

00:14:03.100 --> 00:14:05.500
ไม่ห่วงหน้าพะวงหลังนะครับ นะ

00:14:05.500 --> 00:14:08.000
นี่คือหลักการที่ผมให้เห็นเนาะว่า

00:14:08.000 --> 00:14:09.800
เราจะทำแบบนี้นะครับเนาะ

00:14:09.800 --> 00:14:13.400
แต่ประเด็นคือ การทำแบบนี้ไม่ได้บอกว่า

00:14:13.400 --> 00:14:15.700
ต้องเป็น manual หรือ automation นะครับ

00:14:15.700 --> 00:14:19.800
ประเด็นคือคุณทำแบบนี้ซ้ำๆ ได้หรือเปล่า

00:14:19.800 --> 00:14:22.400
นะครับ ถ้าทำซ้ำไม่ได้ นี่คือสิ่งที่

00:14:22.400 --> 00:14:26.300
คุณจะต้องเริ่มทำ ยกตัวอย่าง

00:14:26.300 --> 00:14:31.400
ผมให้เห็นสไลด์ชุดนี้ ตัวนี้ dev กับ test

00:14:31.400 --> 00:14:33.100
ทุกที่ส่วนใหญ่จะมี dev

00:14:33.100 --> 00:14:37.300
ใช่ไหม แล้วก็มี tester QA ถูกไหม หรือใครก็ตาม

00:14:37.300 --> 00:14:40.900
ประเด็นคือ 2 คน เค้าเรียก 2 กลุ่มนี้

00:14:40.900 --> 00:14:43.600
จะมี effort เท่าเดิมเสมอ

00:14:43.600 --> 00:14:48.100
ใช่ไหม ถ้าโปรเจคไม่ทันทำไง อยู่ดึกหน่อยนะน้อง ใช่ไหม

00:14:48.100 --> 00:14:50.700
เสาร์อาทิตย์เข้าได้ไหม อะไรประมาณนี้

00:14:50.700 --> 00:14:53.800
เดี๋ยวสักพักเดี๋ยวพี่หาคนเพิ่มให้ อะไรประมาณนี้ ใช่ไหม

00:14:53.800 --> 00:14:58.600
อันนี้คือมุมมองที่เกิดขึ้น แต่ประเด็นคือ effort เท่าเดิม

00:14:58.600 --> 00:15:03.500
สิ่งที่เปลี่ยนแปลงคือ feature ที่โตขึ้น คำถามก็คือ

00:15:03.500 --> 00:15:07.800
feature ที่โตขึ้น เราทดสอบครบไหม ส่วนใหญ่ไม่ครบ

00:15:07.800 --> 00:15:11.500
เค้าเรียกว่า unstable คือ feature ที่ไม่เสถียรเลย

00:15:11.500 --> 00:15:16.500
ทำงานได้บ้างไม่ได้บ้างก็ว่าไป พอเวลาผ่านไปเรื่อยๆ เกิดอะไรขึ้น

00:15:16.500 --> 00:15:21.400
ไฟไหม้ถูกไหม เพราะอะไร เรา late มันไปเรื่อยๆ นะครับ

00:15:21.400 --> 00:15:26.100
ดังนั้น สิ่งที่ตามมาคือ ถ้าเราบอกว่าค่อย incremental ไปเรื่อยๆ

00:15:26.100 --> 00:15:30.300
การทดสอบน่าจะเริ่มเข้ามา automation นี่คือมุมมองผมให้เห็น

00:15:30.300 --> 00:15:35.400
นี่คือธรรมชาติ นะครับ แต่หลายๆ ที่ ชอบฝืนธรรมชาติไหม ถูกไหม

00:15:35.400 --> 00:15:40.000
ก็ต้องลองดู เพราะเป็นแบบนี้ นะครับ เราก็จะเอา automation

00:15:40.000 --> 00:15:45.800
เข้ามาใช้เรื่อยๆ แต่ automation คุณจะทำเลเวลไหน

00:15:45.800 --> 00:15:49.600
อันนี้คือกลับไปที่ความเชื่อมั่นอีกแล้ว

00:15:49.600 --> 00:15:52.600
ว่า test เลเวลไหนที่คุณจะทำ

00:15:52.600 --> 00:15:57.000
โดยที่ การ test นะครับ ไม่ว่าจะเลเวลไหนก็ตาม นะครับ

00:15:57.000 --> 00:16:02.000
ทุกครั้งนะครับ เราเป็นนักพัฒนา ทุกครั้งที่คุณ add หรือ commit

00:16:02.000 --> 00:16:08.300
หรือว่า push คำถามคือ commit ของคุณ คุณผ่านการ verify ไหม

00:16:08.300 --> 00:16:13.400
หรือเอาง่ายๆ คือบนเครื่อง git add นะครับ git add แล้วไม่ใส่ commit

00:16:13.400 --> 00:16:16.600
ใครไม่ใส่ commit บ้าง commit message คงต้องใส่

00:16:16.600 --> 00:16:19.900
1 commit คงไม่มี 100 change ใช่ไหม คงไม่มี ใช่ไหม

00:16:19.900 --> 00:16:23.300
มีใครเป็นบ้าง 1 commit มี 100 ไฟล์

00:16:23.300 --> 00:16:24.900
คงไม่มีเนาะ แล้วมีคำว่าอะไรครับ

00:16:24.900 --> 00:16:26.800
commit นั้นชื่อว่า update เพราะอะไรครับ

00:16:26.800 --> 00:16:29.200
เป็นค่า default ของเครื่องมือใช่ไหม

00:16:29.200 --> 00:16:31.700
คุ้นๆ มั้ย อันนี้คงไม่มีเนาะ

00:16:31.700 --> 00:16:34.000
ดังนั้น พอเราทำ test ปุ๊บเนี่ย

00:16:34.000 --> 00:16:35.900
สิ่งที่เกิดขึ้นคือมันต้องเกิดอะไรครับ

00:16:35.900 --> 00:16:37.600
เค้าเรียกว่า continuous testing

00:16:37.600 --> 00:16:40.800
ทั้งบนเครื่องเราหรือเราจะมีพวก CI/CD เนาะ

00:16:40.800 --> 00:16:45.800
ที่ทำให้เราเห็นอยู่ตลอดเวลานะครับ นี่คือหลักการ

00:16:45.800 --> 00:16:49.200
กลับมานะครับ นี่คือ testing เนาะ กลับมาที่ JavaScript

00:16:49.200 --> 00:16:53.200
ประเด็นคือ อ้าว แล้ว JavaScript มีอะไรบ้างเนาะ

00:16:53.200 --> 00:16:56.900
เมื่อกี้มีเขียนอะไรนะ โอ้โห test เยอะเลยใช่ไหมครับ ก่อนนี้นะครับ

00:16:56.900 --> 00:16:59.600
มาดูว่าที่ผมทำมีอะไรบ้างนะครับ

00:16:59.600 --> 00:17:02.100
ใน JavaScript มันโหดร้ายป่าเถื่อนมากนะครับ

00:17:02.100 --> 00:17:04.300
เพราะว่าอะไรครับ library มันเยอะนะครับ

00:17:04.300 --> 00:17:07.300
คำถามคือเลือกอะไร เอาที่สบายใจนะครับ

00:17:07.300 --> 00:17:09.200
ผมก็เลือกให้ไม่ได้นะครับ

00:17:09.200 --> 00:17:13.400
มันอยู่ที่รสนิยมถูกไหม แต่นี่คือสิ่งที่ผมใช้เนาะ

00:17:13.400 --> 00:17:15.700
อันนี้ผมเอามาจาก guideline จากที่นี่นะครับ

00:17:15.700 --> 00:17:17.099
อันนี้ยังขาดภาษาไทยเนาะ ใช่ไหม

00:17:17.099 --> 00:17:20.900
ใครเคยเข้ามั้ยครับอันนี้ เคยเนาะ ใช่ไหม

00:17:20.900 --> 00:17:22.800
เข้าไปปุ๊บก็ปิดใช่ไหมนะครับ

00:17:22.800 --> 00:17:24.599
แอดบุ๊คมาร์คไว้ซักหน่อย แล้วก็ปิดไป

00:17:24.599 --> 00:17:26.800
แล้วก็ดูว่า คือเหี้ยอะไรวะ ใช่ไหม

00:17:26.800 --> 00:17:28.300
ประมาณนั้นนะครับ

00:17:28.300 --> 00:17:30.700
แต่ผมให้เห็นว่า อันที่นี่นะครับ

00:17:30.700 --> 00:17:33.800
ผมก็ reference เนาะ แล้วเอามาใช้คือ

00:17:33.800 --> 00:17:36.300
ในตัวอะไรครับ ของ JavaScript เนี่ย

00:17:36.300 --> 00:17:38.500
มันมีทั้ง frontend และ backend เนาะ

00:17:38.500 --> 00:17:41.900
มันมีบาง library ใช้ได้ทั้ง front และ back

00:17:41.900 --> 00:17:43.500
บาง library ใช้ได้แค่ front

00:17:43.500 --> 00:17:45.700
บาง library ใช้ได้แค่ back นะครับ

00:17:45.700 --> 00:17:48.300
มาดูว่าสิ่งที่ผมใช้เนาะ มีอะไรบ้าง

00:17:48.300 --> 00:17:52.500
ยกตัวอย่างเนาะ front กับ back คุยกันประมาณนี้

00:17:52.500 --> 00:17:55.900
back จะโหดร้ายเนาะ front ก็จะกลางๆ หน่อยใช่ไหม

00:17:55.900 --> 00:17:58.900
จะแยกกันลักษณะนี้นะครับ

00:17:58.900 --> 00:18:03.700
พอเป็นอย่างงี้ปุ๊บ คำถามก็คือ เราเทสไงวะ ใช่ไหมนะ

00:18:03.700 --> 00:18:05.800
อันนี้เอาแบบ minimal เนาะ นี่คือ happy meal เนาะ

00:18:05.800 --> 00:18:10.400
ชีวิตจริงนรกกว่านี้ใช่ไหม ประเด็นคือมีแค่นี้

00:18:10.400 --> 00:18:11.500
ทดสอบไงครับ

00:18:11.500 --> 00:18:15.600
คนจริงก็นี่เลย ง่ายตายใช่ไหม

00:18:15.600 --> 00:18:17.500
มี frontend กับ backend ใช่ไหม

00:18:17.500 --> 00:18:22.300
ก็ deploy ทั้งคู่ไง แล้วก็ทดสอบไง ใช่ไหมนะ

00:18:22.300 --> 00:18:25.600
คำถามคือมึงแยก front กับ back ทำโล่อะไรใช่ไหม
อยู่คนละ repo อีกใช่ไหม

00:18:25.600 --> 00:18:28.000
หรือว่า mono repo นะ หรือ poly repo

00:18:28.000 --> 00:18:30.300
เดี๋ยวนี้ ใช่ไหม

00:18:30.300 --> 00:18:32.400
เดี๋ยวนี้มี microservice แม่งแยกเลยครับ

00:18:32.400 --> 00:18:34.200
มี 100 service แยก 100 repo ใช่ไหม

00:18:34.200 --> 00:18:38.200
นะครับ แล้วรวมกันยังไง แล้วแต่เวรแต่กรรมใช่ไหม ก็ว่ากันไป

00:18:38.200 --> 00:18:44.400
ประเด็นคือ อันนี้คือง่ายที่สุด ประเด็นคือ ทดสอบแบบนี้ดีไหม ดีที่สุดครับ

00:18:44.400 --> 00:18:48.700
เพราะอะไรครับ เลเวลของความเชื่อมั่นสูงมาก ถูกไหม

00:18:48.700 --> 00:18:52.400
แต่ความสนุกคือ คุณต้องทำอะไรบ้างถูกไหม

00:18:52.400 --> 00:18:58.600
ต้อง setup external system ใช่ไหม setup database, deploy backend, deploy frontend

00:18:58.600 --> 00:19:02.300
ทดสอบซ้ำได้ไหม ขอเวลาสักอาทิตย์

00:19:02.300 --> 00:19:06.500
รีเซ็ต data หน่อย แล้วก็ทดสอบใหม่ ใช่ไหม มันทำอะไรครับ

00:19:06.500 --> 00:19:13.000
การทดสอบ นะครับ ไอ้ที่ 1 2 3 4 5 นี่คืออะไรครับ โปรเซสปกติ

00:19:13.000 --> 00:19:16.700
แล้วเราก็ทดสอบ อาจจะเป็น manual หรืออะไร เอาเครื่องมือมาใช้ถูกไหม

00:19:16.700 --> 00:19:20.200
เครื่องมือก็อะไร นี่เลยใช่ไหม 3 ทหารเสือใช่ไหม

00:19:20.200 --> 00:19:23.700
สาย frontend นะ ที่บอกว่าอะไรครับ

00:19:23.700 --> 00:19:26.800
เค้าเรียกว่า frontend developer ต้องมีอะไรครับ 2 หน้าจอใช่ไหม

00:19:26.800 --> 00:19:28.800
หน้าจอนึงเอาไว้อะไรครับ เปิด test ใช่ไหม

00:19:28.800 --> 00:19:33.500
หน้าจอนึงเขียนโค้ด เซฟปุ๊บ test ออโต้ใช่ไหม ไม่ใช่นะครับ

00:19:33.500 --> 00:19:37.600
อีกหน้าจอยังเอาไว้ดูผลแค่นั้นเอง แค่ feature ที่เรากำลังพัฒนา

00:19:37.600 --> 00:19:40.400
แล้ว feature อื่นล่ะ ปล่อยมันไป

00:19:40.400 --> 00:19:45.200
อันนี้คือสิ่งที่เกิดขึ้น ดังนั้น เพราะเป็นแบบนี้

00:19:45.200 --> 00:19:50.700
คำถามคือ ความเชื่อมั่นสูงครับ นะครับ ความเร็วล่ะ

00:19:50.700 --> 00:19:54.500
ต้องคุยกัน ที่ผมใส่สีเขียวผมก็ไม่รู้ เพราะแต่ละคนไม่เหมือนกัน

00:19:54.500 --> 00:19:57.700
isolate คือเป็นอิสระไหม คำตอบคือไม่ใช่แน่นอนใช่ไหม

00:19:57.700 --> 00:20:00.900
เพราะอะไรครับ คุณต้อง setup ทุก element นะครับ

00:20:00.900 --> 00:20:05.300
repeat ได้ไหม อันนี้ก็เป็นเรื่องเป็นราว

00:20:05.300 --> 00:20:10.500
ว่าถ้าเราทำ end-to-end test repeat เราต้องทำตั้งแต่เนิ่นๆ นะครับ

00:20:10.500 --> 00:20:14.700
แต่ถ้าคุณมาทำช่วงท้าย น่าจะมีประเด็น นะครับ

00:20:14.700 --> 00:20:17.700
อันนี้คือไอเดียถูกไหม นะครับ

00:20:17.700 --> 00:20:24.400
แล้วประเด็นคือ การ test ทุกเลเวลนะครับ มันจะมีสิ่งนี้ คือ flaky test ใช่ไหม

00:20:24.400 --> 00:20:29.000
นะครับ คืออะไรครับ ไม่ได้เปลี่ยนอะไรเลย แต่รัน test ซ้ำ

00:20:29.000 --> 00:20:31.300
ผ่านบ้าง ไม่ผ่านบ้าง ใช่ไหม

00:20:31.300 --> 00:20:35.300
พอไม่ผ่านปุ๊บนะครับ มันมี feature นึง ignore ใช่ไหม

00:20:35.300 --> 00:20:41.700
ignore ไปเรื่อยๆ จากมี 1,000 เคส ignore ไป ignore มา เหลือ 100 เคส นะครับ

00:20:41.700 --> 00:20:44.800
เพื่อให้อะไรครับ เพื่อให้ test ผ่านก็ว่าไป

00:20:44.800 --> 00:20:50.600
ซึ่งตรงนี้แหละครับ จะเป็นปัญหา ของ dependency ของการทดสอบระบบเรา

00:20:50.600 --> 00:20:54.000
ที่มีประเด็นนะครับ ดังนั้น

00:20:54.000 --> 00:20:56.700
ถ้าเราทำ end-to-end test แล้วมีปัญหาเหล่านี้นะครับ

00:20:56.700 --> 00:20:58.600
เราก็ต้องปรับปรุง

00:20:58.600 --> 00:21:02.100
หรือมีทางอื่นมั้ย ลองดูนะ ไม่ใช่บอก end-to-end ไม่ดี

00:21:02.100 --> 00:21:04.400
end-to-end ดีที่สุดนะครับ

00:21:04.400 --> 00:21:08.000
แต่เราทำซ้ำได้มั้ย มีความน่าเชื่อถือรึเปล่า

00:21:08.000 --> 00:21:11.400
ดังนั้นผมต้องการอะไร ความน่าเชื่อถือ

00:21:11.400 --> 00:21:14.300
แล้วก็อะไร feedback นะครับ

00:21:14.300 --> 00:21:19.500
ที่เร็ว ดังนั้นทำไงดี แยกมั้ยนะครับ

00:21:19.500 --> 00:21:21.800
แยก 2 ส่วนออกจากกันใช่ป่ะ

00:21:21.800 --> 00:21:25.600
ทำอะไร ทำให้เราสามารถทดสอบอะไร front-end และ back-end

00:21:25.600 --> 00:21:27.500
โดยที่ไม่ต้องเกี่ยวข้องกัน

00:21:27.500 --> 00:21:31.200
คืออะไร ก่อนที่คุณจะมา integrate กัน

00:21:31.200 --> 00:21:33.000
แยกกันให้รอดก่อนมั้ย ถูกป่ะ

00:21:33.000 --> 00:21:37.200
เพราะอะไร ถ้าต่างฝ่ายต่างอะไร แยกกันแล้วทดสอบแล้ว work

00:21:37.200 --> 00:21:39.700
เอามารวมกันอาจจะ work ถูกป่ะ

00:21:39.700 --> 00:21:42.700
แต่ถ้าเราไม่เคยทดสอบ 2 ฝั่ง

00:21:42.700 --> 00:21:47.200
เอามารวมกันเลย ความไม่ work สูงมากๆ นะครับ

00:21:47.200 --> 00:21:49.100
ดังนั้น isolate คือแยกกัน

00:21:49.100 --> 00:21:52.500
ทำไงดี กลายเป็นอะไร front-end กับ back-end

00:21:52.500 --> 00:21:56.900
หลายๆ คนอาจจะถามว่าแล้วเราแยก front กับ back ทำไมวะ ใช่ป่ะ

00:21:56.900 --> 00:22:00.400
แล้วมันจะเกิดคำถาม ทำไมเราต้องแยกด้วย ทำไมไม่รวม ใช่ป่ะ

00:22:00.400 --> 00:22:04.600
ดังนั้น front-end test กับ back-end test isolate กันทำยังไง ถูกป่ะ

00:22:04.600 --> 00:22:08.800
front-end คุณออกไปอะไร back-end ใช่ป่ะ ผ่าน API

00:22:08.800 --> 00:22:14.600
ผ่าน REST gRPC tRPC อะไรก็ว่าไป ถูกป่ะ whatever นะครับ

00:22:14.600 --> 00:22:18.700
คุณต้องจำลองมั้ย ถูกป่ะ จำลองยังไง นี่ ชีวิตมาแล้ว

00:22:18.700 --> 00:22:24.700
เครื่องมือสาย front-end ใช่ป่ะนะครับ ไม่ว่าคุณจะใช้อะไร

00:22:24.700 --> 00:22:26.900
Cypress Playwright ใช่ป่ะ Selenium ด้านหลัง

00:22:26.900 --> 00:22:30.300
คุณสามารถ mock แหลกลานได้ใช่ป่ะนะครับ

00:22:30.300 --> 00:22:32.000
ด้วยเครื่องมือต่างๆ เหล่านี้

00:22:32.000 --> 00:22:38.500
หน้าตาเป็นยังไง ผมให้ดู นี่คือตัวอย่างของ Playwright นะครับ ในนี้มีใครใช้ Playwright บ้าง

00:22:38.500 --> 00:22:42.200
ผมเพิ่งอะไร migrate จาก Cypress

00:22:42.200 --> 00:22:46.400
มา Playwright ประมาณ 4 โปรเจคแล้วนะครับ ถามว่าทำไม migrate

00:22:46.400 --> 00:22:49.900
อยาก migrate แค่นั้นเอง ไม่มีอะไร แล้วมันแค่เร็วขึ้นแค่นั้นเอง

00:22:49.900 --> 00:22:51.800
นะครับ back ได้มั้ย

00:22:51.800 --> 00:22:52.800
ก็ไม่ค่อยมีประเด็นนะครับ

00:22:52.800 --> 00:22:55.900
อันนี้คือ ผมลองอะไร test ด้วย Playwright

00:22:55.900 --> 00:23:01.200
เสร็จแล้วอันนี้คือเปิดด้วยอะไร Chromium นะครับ จากนั้นก็อะไร

00:23:01.200 --> 00:23:05.700
นะครับ อันนี้ผมก็ mock API ของตัว front

00:23:05.700 --> 00:23:08.100
ด้วย Playwright ลองดูนะครับ

00:23:08.100 --> 00:23:13.800
จากนั้นก็เขียน test case นะครับ ซึ่งตรงนี้ผม hard code

00:23:13.800 --> 00:23:16.700
ก็แยกออกมา อันนี้คือเป็นการ refactor

00:23:16.700 --> 00:23:18.200
ปกติอยู่แล้วถูกป่ะ

00:23:18.200 --> 00:23:21.300
ว่ามันรวมๆ เราคนจริงเราคงไม่ hard code ใช่ป่ะ

00:23:21.300 --> 00:23:25.800
เราคนจริงก็แยกออกมาว่าจะแยกแบบไหนก็ว่ากันไปนะครับ

00:23:25.800 --> 00:23:30.100
พอเป็นแค่นี้ เราสามารถที่จะทดสอบฝั่ง front end

00:23:30.100 --> 00:23:33.700
โดยการเปิด browser แล้วเมื่อไหร่ก็ตามยิงไปหลังบ้านจำลอง

00:23:33.700 --> 00:23:38.300
ใช่ป่ะ เพื่อให้มั่นใจว่า behavior ของฝั่ง front end โอเคนะครับ

00:23:38.300 --> 00:23:42.900
จากนั้นทำไงดี ฝั่ง front end น่ะมันจะมี snapshot ใช่ป่ะ

00:23:42.900 --> 00:23:47.200
Playwright ก็ snap เลยใช่ป่ะ แล้วเอารูปมาเอามา compare

00:23:47.200 --> 00:23:49.900
แล้วเซตพวก threshold พวก difference ต่างๆ ได้ว่า

00:23:49.900 --> 00:23:53.200
จะให้มันต่างกันกี่เปอร์เซ็นต์ก็ว่าไป แล้วสามารถ snap

00:23:53.200 --> 00:23:55.900
ได้ทั้งหน้าหรือว่า per component ก็ได้นะครับ

00:23:55.900 --> 00:24:00.500
อันนี้คือฝั่งของ front end test โดยที่ยิงจริงมั้ย ไม่ยิงจริง

00:24:00.500 --> 00:24:03.700
แต่เราแก้โค้ดฝั่ง front end มั้ย ไม่ได้แก้นะครับ

00:24:03.700 --> 00:24:07.200
นี่คือหลักการที่เกิดขึ้น ซึ่งตรงนี้มันทำให้เร็วขึ้นมั้ย

00:24:07.200 --> 00:24:10.000
isolate แล้วถูกป่ะ repeat ได้นะครับ

00:24:10.000 --> 00:24:13.900
แต่แน่นอนว่าความเชื่อมั่นดรอปลง เห็นป่ะนะครับ

00:24:13.900 --> 00:24:17.200
อันนี้คือมีเป็น trade off นะที่ผมอยากให้เห็นนะครับ

00:24:17.200 --> 00:24:21.900
หรือ back end ก็เช่นกันใช่ป่ะ คุณก็ต้องจำลองว่า

00:24:21.900 --> 00:24:24.300
back end เช่นเราเป็น REST API ถูกป่ะ

00:24:24.300 --> 00:24:27.300
REST API เราต้องยิงด้วยอะไร นี่เนาะ Postman เนาะ

00:24:27.300 --> 00:24:30.500
ยาสามัญประจำบ้านใช่ป่ะ หลายๆ คนใช้นะครับ

00:24:30.500 --> 00:24:34.300
มี SuperTest Cypress ก็มี Playwright ก็มาถูกป่ะ

00:24:34.300 --> 00:24:36.700
จะจำลองหลังบ้านนะครับ มีพวกอะไรบ้าง

00:24:36.700 --> 00:24:40.900
พวก node mock HTTP mock อะไรอย่างเงี้ย

00:24:40.900 --> 00:24:43.200
บางคนใช้ Docker เลย ถูกไหมครับ

00:24:43.200 --> 00:24:45.200
หรือว่า test container ก็ว่าไปนะครับ

00:24:45.200 --> 00:24:49.000
นี่คือฝั่งของ backend ที่เราสามารถทำได้

00:24:49.000 --> 00:24:54.900
ตัวอย่างคือผมใช้ Supertest ยิง start Express ขึ้นมาตู้มนะครับ

00:24:54.900 --> 00:25:02.200
จากนั้นก็อยากให้มันยิงออกไปไหน mock มันเลย mock ใช่ไหม

00:25:02.200 --> 00:25:04.600
เห็นไหม mock ยิงไปที่นี่ใช่ไหม ไม่ให้ออก

00:25:04.600 --> 00:25:06.200
return ค่านี้กลับเลย

00:25:06.200 --> 00:25:11.000
อยากให้ช้าใช่ไหม อยากให้ fail mock มันเลยนะครับ

00:25:11.000 --> 00:25:13.200
เราต้องแก้โค้ดไหม ไม่ต้องแก้โค้ด

00:25:13.200 --> 00:25:15.100
เพราะเรารู้อยู่แล้วว่ามันออกไปที่ไหนถูกไหม

00:25:15.100 --> 00:25:18.600
ให้มัน return กลับเลยนะ บางคนไปใช้ JSON ไฟล์

00:25:18.600 --> 00:25:22.900
จากเรียก HTTP client ใช่ไหม ไปเรียกจาก Axios

00:25:22.900 --> 00:25:24.000
เปลี่ยนเป็นอ่านไฟล์

00:25:24.000 --> 00:25:27.800
มันเหมือนกันไหมพฤติกรรม HTTP กับ read ไฟล์ ไม่เหมือนกันถูกไหม

00:25:27.800 --> 00:25:31.500
ดังนั้นเราทำแบบนี้ได้ แล้วก็เขียน test

00:25:31.500 --> 00:25:35.300
สังเกตนะ นี่คือ front กับ backend test ถูกไหม

00:25:35.300 --> 00:25:39.800
ซึ่งแต่ละส่วนเป็นอิสระแก่กัน

00:25:39.800 --> 00:25:43.900
พอเป็นอิสระแก่กันปุ๊บ คำถามคือความเชื่อมั่นเป็นอย่างไร โอเคไหมนะ

00:25:43.900 --> 00:25:46.900
แน่นอนคือความเชื่อมั่นที่ผมบอก มันดรอปลงถูกไหม

00:25:46.900 --> 00:25:50.800
แล้วหนักกว่านั้น คำถามตามมาคือคุณแยก front กับ backend ใช่ไหม

00:25:50.800 --> 00:25:55.400
เคยเจออันนี้ไหม แยก front กับ backend แล้ว สิ่งที่ตามมาคือ

00:25:55.400 --> 00:26:00.300
เมื่อกี้ mock เยอะใช่ไหม mock bubble mock เยอะชิบหาย ถูกไหม

00:26:00.300 --> 00:26:04.100
กลับไปที่ architecture คุณเลย มันจะแยกกันอะไรกันเยอะขนาดนั้น ถูกไหม

00:26:04.100 --> 00:26:08.800
อย่าคิดทำแล้วค่อยมาหา กลับไปที่ root cause นะ

00:26:08.800 --> 00:26:12.800
หนักกว่านั้น นี่เลย เรามี front กับ backend ใช่ไหม

00:26:12.800 --> 00:26:15.700
วันดีคืนดี backend เปลี่ยน front รู้ไหม?

00:26:15.700 --> 00:26:18.100
ใครเป็นบ้าง ในทีมยังพอทน

00:26:18.100 --> 00:26:21.000
ต่างทีมหรือต่างบริษัท

00:26:21.000 --> 00:26:25.200
มันแก้แล้วเอาขึ้น production เพิ่งมาบอกว่า อ้อกูแก้ ถูกไหม

00:26:25.200 --> 00:26:28.500
แล้วเรากำลังขึ้นโปรดักชั่นทุกอย่างผ่าน UAT มาเรียบร้อย

00:26:28.500 --> 00:26:31.900
ใครเป็นบ้างครับ ทุกอย่างมาเจอรวมกันเนาะ นะครับ

00:26:31.900 --> 00:26:34.900
สิ่งที่เกิดขึ้นคือมันเกิดอะไรครับ breaking ถูกป่ะ นะครับ

00:26:34.900 --> 00:26:38.400
ตอนที่เราขึ้น เรารู้มั้ย รู้ตอนไหน ถูกป่ะ เออ นะ

00:26:38.400 --> 00:26:42.000
ดังนั้น สิ่งที่ผมไม่เห็นเนาะ อีกตัวนึง test ของอะไรครับ

00:26:42.000 --> 00:26:45.900
ฝั่งของ JavaScript ที่ผมใช้นะครับ ผมใช้ contract test

00:26:45.900 --> 00:26:50.200
แปลเป็นไทยคือ สัญญาว่าจะ test นะครับ เออเนาะ นะ

00:26:50.200 --> 00:26:53.000
อันนี้แปลเป็นไทยนะ ไม่ใช่หรอก ผมมั่วนะครับ

00:26:53.000 --> 00:26:56.400
ดังนั้น ฝั่ง front-end กับ back-end หรือใดๆ ก็ตามเนาะ

00:26:56.400 --> 00:26:59.800
จับมือกันแล้วใช่ป่ะ ปกติเราจับมือกันด้วยอะไรนะ

00:26:59.800 --> 00:27:01.600
API spec ใช่ป่ะ ถูกป่ะ

00:27:01.600 --> 00:27:06.300
ใครมีบ้างครับ ใช้อะไร Swagger OpenAPI ใช่ ใครใช้บ้างครับ

00:27:06.300 --> 00:27:10.800
หลายๆ คนใช้เนาะ แต่เจนเอาใช่ป่ะ เจนเอาคือไม่ใช้ เพราะอะไรครับ

00:27:10.800 --> 00:27:15.200
เค้าอยากให้มี ก็เจนมันมา ใช่ป่ะ เพราะถ้าไม่มี ส่งไม่ได้ ใช่ป่ะ

00:27:15.200 --> 00:27:17.800
ใครเป็นอย่างงั้นบ้างครับ ยกมือหน่อย อ่า โอเค นะครับ

00:27:17.800 --> 00:27:19.400
เพราะฉะนั้นเหมือนไม่มีแล้วกัน นะ เพราะอะไรครับ

00:27:19.400 --> 00:27:22.400
เพิ่มโค้ดมาทัดเดียวก็ได้แล้วอะ ใช่ป่ะ เออเนาะ

00:27:22.400 --> 00:27:27.400
ดังนั้น ตรงนี้ครับ จาก API spec เราจับมือร่วมกันนะครับเนาะ

00:27:27.400 --> 00:27:30.700
ดังนั้น พอจับมือกันปุ๊บนะครับ สิ่งที่ใช้เนาะ ผมใช้ Pact เนาะ

00:27:30.700 --> 00:27:34.900
จับมือกัน จะเป็นแบบนี้เนาะ จับมือด้วย API spec นะ

00:27:34.900 --> 00:27:39.100
พอ สิ่งที่ผมทำคืออะไรนะครับเนาะ ตัว Pact นี่ นะครับเนาะ

00:27:39.100 --> 00:27:43.000
จาก API spec เนาะ ที่ผมเขียนแบบนี้ สามารถแปลงออกมานะครับ

00:27:43.000 --> 00:27:46.800
ในรูปแบบของ contract ได้ ประเด็นคือ contract คืออะไรครับ

00:27:46.800 --> 00:27:48.100
ระหว่าง front-end กับ back-end เนาะ

00:27:48.100 --> 00:27:50.400
เค้าเรียกว่า consumer กับ provider

00:27:50.400 --> 00:27:55.700
นะครับเนาะ จะต้องอะไรครับ จะต้องจับมือกัน แล้วแปลง spec ตัวนี้

00:27:55.700 --> 00:27:59.600
นะครับ มาเป็นตรงกลางนะครับเนาะ จะต้องอะไรครับ generate

00:27:59.600 --> 00:28:01.900
ออกมาเป็น contract เนาะ เป็นอะไรครับ เหมือนสัญญาเนาะ

00:28:01.900 --> 00:28:03.900
ระหว่าง 2 ส่วนนะครับเนาะ

00:28:03.900 --> 00:28:06.200
การเขียนนะครับ อันนี้คือผมให้ดูตัวอย่างเนาะ นะครับว่า

00:28:06.200 --> 00:28:10.600
กำหนด consumer กับ provider นะครับเนาะ ว่า เฮ้ย provider ชื่ออะไร

00:28:10.600 --> 00:28:14.400
consumer ชื่ออะไร คือคนเรียกกับคนถูกเรียก จากนั้น

00:28:14.400 --> 00:28:21.000
เอา spec เมื่อกี้ครับ มาสร้างเป็นอะไรครับ มาสร้างเป็น contract

00:28:21.000 --> 00:28:23.200
ด้วย Pact นะครับ แต่ละภาษาไม่เหมือนกัน

00:28:23.200 --> 00:28:24.600
แต่ละ framework ไม่เหมือนกันเนาะ

00:28:24.600 --> 00:28:29.700
แต่ อันนี้คือเหมือน spec เลยเมื่อกี้ นะครับ จากนั้น นะครับ

00:28:29.700 --> 00:28:34.100
generate อะไรครับ contract ออกมา อันนี้คือคำสั่งเนาะ

00:28:34.100 --> 00:28:36.100
ในการ generate contract แล้วก็ test ฝั่งของ consumer

00:28:36.100 --> 00:28:39.800
จะได้ contract หน้าตาประมาณนี้

00:28:39.800 --> 00:28:42.800
นะครับ เป็นไฟล์ของ contract นะครับ ดังนั้น

00:28:42.800 --> 00:28:44.800
ทุกครั้งที่เราไปเรียกใครก็ตาม

00:28:44.800 --> 00:28:48.600
จะมีการจับมือร่วมกัน สร้าง contract คือสัญญาขึ้นมา

00:28:48.600 --> 00:28:51.600
ทั้ง success case และ fail case

00:28:51.600 --> 00:28:54.800
ซึ่งสัญญานี้จะไม่อยู่ที่ใดที่หนึ่งนะครับ

00:28:54.800 --> 00:29:01.100
จะเอามาไว้ตรงกลาง ผมเรียกว่า broker
Pact จะมี broker ให้

00:29:01.100 --> 00:29:04.800
จะเก็บทุกสัญญา โอเคไหมครับ จากนั้น

00:29:04.800 --> 00:29:07.000
พอเก็บทุกสัญญาปุ๊บ

00:29:07.000 --> 00:29:11.400
แน่นอนคือวันดีคืนดี backend เปลี่ยนใช่ไหม backend เปลี่ยนปุ๊บ

00:29:11.400 --> 00:29:13.900
รู้ไหมว่าสิ่งที่เปลี่ยนกระทบใครบ้าง

00:29:13.900 --> 00:29:16.900
นะครับ ถ้าไม่รู้ มาดึง contract จาก Pact

00:29:16.900 --> 00:29:20.500
ที่มีคนใช้ โอเคไหมครับ ดึงไปปุ๊บ ทุกสัญญา

00:29:20.500 --> 00:29:23.700
เอามา verify

00:29:23.700 --> 00:29:28.200
verify ทุก contract เราจะเห็นว่า contract ไหนผ่านไม่ผ่าน

00:29:28.200 --> 00:29:30.500
แล้วที่สำคัญคือเอา contract มารวมกันใช่ไหม

00:29:30.500 --> 00:29:34.100
มันมี consumer กับ provider

00:29:34.100 --> 00:29:38.700
ใช่ไหมครับ เอามา generate เป็น dependency graph ว่าใครเรียกใคร

00:29:38.700 --> 00:29:45.000
ตอนนี้ของเรา ใครเรียกใครรู้ไหม หรือต้องไปดูใครบอก เดี๋ยวเราไปขอดู log ก่อน

00:29:45.000 --> 00:29:48.200
ว่าใครเรียกเราบ้าง ใช่ไหม มีไหม คงไม่มีนะ

00:29:48.200 --> 00:29:53.000
ใช่ไหม tail -f grep อะไรสักอย่าง คงไม่มีใครทำนะ ใช่ไหม

00:29:53.000 --> 00:29:56.800
ดังนั้น เราจะเห็นแบบนี้คือ dependency graph ใช่ไหม นะครับ

00:29:56.800 --> 00:30:00.700
จากนั้นก็ verify ถูกไหมครับ เราก็จะรู้ว่า contract ไหน

00:30:00.700 --> 00:30:07.300
ที่มีการเปลี่ยนแปลง กระทบใครบ้าง นี่คือ side effect นะ

00:30:07.300 --> 00:30:12.200
ซึ่งพอผมมี test 3 เลเวลแบบนี้ ลองดูนะครับ confidence

00:30:12.200 --> 00:30:18.400
ความเชื่อมั่นเราดีขึ้นไหม ลองดูนะครับ ความเชื่อมั่นดีขึ้นไหม

00:30:18.400 --> 00:30:23.300
แต่ละส่วนแยกเป็นอิสระจากกัน แต่ยังคุยกันถูกไหม

00:30:23.300 --> 00:30:28.200
แต่อยู่ที่ว่าจะคุยกันแบบจริงๆ หรือเปล่า หรือเราจะมีตัวกลาง

00:30:28.200 --> 00:30:32.800
ที่ทั้ง 2 ฝั่งเชื่อมั่น นะครับ อันนี้คือมุมมองที่เกิดขึ้น

00:30:32.800 --> 00:30:37.300
และสุดท้ายมันคือเรื่องของ repeat คือทำซ้ำ นะครับ

00:30:37.300 --> 00:30:43.500
ดังนั้น นี่คือการ test ณ ฝั่งไม่ใช่ developer test เลยนะครับ

00:30:43.500 --> 00:30:48.300
การ test เหล่านี้เป็น business test ล้วนๆ ครับ เพราะว่า business test

00:30:48.300 --> 00:30:53.300
มันคือการบอกว่าแต่ละ feature แต่ละ function ส่งมอบได้ไหมถูกไหม

00:30:53.300 --> 00:30:57.600
meet requirement หรือเปล่า แต่นักพัฒนาไม่ได้หยุดอยู่แค่นี้

00:30:57.600 --> 00:31:01.800
นักพัฒนาบอกว่าเราต้อง add value เข้าไปใช่ไหม นะครับ

00:31:01.800 --> 00:31:05.000
เพราะเราเป็น professional ถูกไหม
เราจะทำแบบกระดาษแค่นี้ได้ไง

00:31:05.000 --> 00:31:06.500
ดูน้อยเกินไป

00:31:06.500 --> 00:31:10.300
เราต้องโค้ดทุกบรรทัด นะครับ โค้ดทุกบรรทัด

00:31:10.300 --> 00:31:12.600
ทุกอย่างของเรา เราต้องเชื่อมั่นถูกไหม

00:31:12.600 --> 00:31:16.400
จะไม่มีโค้ดบรรทัดไหนเลยที่เราไม่ทดสอบ ใช่ไหมครับ

00:31:16.400 --> 00:31:19.600
มีมั้ย มีโค้ดท่านไหนบ้างที่เราก็อปเข้ามาแล้วมันรันได้

00:31:19.600 --> 00:31:20.800
ก็ถือว่าจบ

00:31:20.800 --> 00:31:23.700
หรือมัน generate ให้แล้วรันได้ก็ถือว่าจบแล้ว ใครเป็นบ้างครับ

00:31:23.700 --> 00:31:25.800
ไม่เป็นเนาะ เพราะเราเป็น professional ถูกป่ะ

00:31:25.800 --> 00:31:29.500
ดังนั้น โค้ดทุกบรรทัดของเราต้องอะไรครับ ต้องเด็ดใช่ป่ะ

00:31:29.500 --> 00:31:33.100
ต้องทำงานได้ แล้วใครมาต่อโค้ดจากเราจะไม่ด่าเนาะ

00:31:33.100 --> 00:31:37.500
เหมือนเราไปด่าโค้ดของชาวบ้านใช่ป่ะ ที่เราไปแก้ไขว่า โค้ดใครวะ

00:31:37.500 --> 00:31:41.700
มีใครเป็นบ้างครับ พอไปดู commit ปุ๊บ โค้ดกูนี่หว่า ใช่ป่ะ

00:31:41.700 --> 00:31:47.200
มีมั้ย ไม่น่ามีเนาะ ไม่น่ามีหรอก โค้ดเราเราก็ต้องจำได้สิ ใช่ป่ะครับ

00:31:47.200 --> 00:31:50.700
ดังนั้น เราสามารถเพิ่มอะไรครับ เพิ่ม test เข้าไปเพื่ออะไรครับ

00:31:50.700 --> 00:31:53.700
ช่วยเพิ่มเรื่องของความเชื่อมั่น

00:31:53.700 --> 00:31:57.700
ดังนั้น สุดท้ายเนาะ อยากให้กลับไปสู่เริ่มต้นนะครับ

00:31:57.700 --> 00:32:02.400
ก็คือ คุณต้องรู้ว่าคุณจะ test ไปทำไมก่อนครับ

00:32:02.400 --> 00:32:07.800
กลับไปคำถามแรกเนาะ มันช่วย business มั้ย มันช่วยเรามั้ย ถูกป่ะ

00:32:07.800 --> 00:32:11.800
จากนั้น คุณจะ test อะไร และหลังจากนั้น เมื่อไหร่คุณควรต้อง test

00:32:11.800 --> 00:32:14.000
นะครับเนาะ และ test อย่างไร นะครับ

00:32:14.000 --> 00:32:17.000
นี่คือสิ่งที่อยากให้เห็นแล้วก็อะไรครับ การ test

00:32:17.000 --> 00:32:21.000
ผมปิดด้วยสไลด์นี้นะ คือเราจะต้องเรียนรู้จากความอะไรครับ ผิดพลาด

00:32:21.000 --> 00:32:24.400
มันเลยเกิดคำนี้นะ bug driven development นะครับเนาะ

00:32:24.400 --> 00:32:29.200
ยิ่งเราเจอ bug บ่อย test เราจะอะไรครับ มากขึ้นเรื่อยๆ

00:32:29.200 --> 00:32:32.900
ถ้าใครไม่เจอ bug แสดงว่าอะไรครับ เราจะไม่มี test

00:32:32.900 --> 00:32:36.300
โอเคนะครับ ขอบคุณทุกคนครับผม

00:32:36.300 --> 00:32:41.100
อันนี้ โอ้เลยมา 2 นาที นะครับ โอเคนะครับ ขอบคุณทุกคนครับผม

00:32:41.100 --> 00:32:45.600
ใครมีข้อสอบถาม ระหว่างเค้ายังไม่ขึ้นมาเนาะ สอบถามได้นะ

00:32:45.600 --> 00:32:48.500
โอเค ใครมีคำถามมั้ยครับ

00:32:48.500 --> 00:32:52.700
ใครมีคำถามเกี่ยวกับ strategy BDD บ้างนะครับ BDD ครับ

00:32:52.700 --> 00:32:57.700
Bug driven development นะครับ

00:32:57.700 --> 00:33:01.600
หรือมีพาร์ทไหนที่เกี่ยวกับการ testing ที่อยากจะสอบถามมั้ยครับ

00:33:01.600 --> 00:33:07.600
มีมั้ยเอ่ย ระหว่างเรารอ transition

00:33:07.600 --> 00:33:10.400
ยังไม่มี ไม่มีนะครับ ขอบคุณครับผม

00:33:10.400 --> 00:33:12.000
โอเคครับ ขอบคุณมากเลยครับ ครับผม

00:33:12.000 --> 00:33:15.600
ขอเสียงปรบมือด้วยครับผม ครับ
