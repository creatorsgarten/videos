WEBVTT

00:00:01.900 --> 00:00:08.900
จะเป็นหัวข้อ Next Generation CSS in JavaScript
นะครับ เดี๋ยวขอเสียงปรบมือให้กับพี่จุ้นหน่อยนะครับ

00:00:08.900 --> 00:00:14.300
เวทีอลังการมาก คนเยอะด้วยนะครับ โอเค ก็

00:00:14.300 --> 00:00:21.500
ทุกคนมีใครเคยใช้ CSS-in-JS บ้าง มีไหมฮะ
น่าจะเคยผ่านๆ มาอยู่เนอะ

00:00:21.500 --> 00:00:25.500
โอเค อันนี้ก็จะเป็นเรื่องเกี่ยวกับ step ต่อไปของ

00:00:25.500 --> 00:00:30.000
CSS-in-JS นะครับ เดี๋ยวผมจะเล่าให้ฟังว่า
มันมีปัญหาอะไรบ้าง

00:00:30.000 --> 00:00:35.200
และก็ solution ที่ทางทีมเรา
พยายามมองหานะครับว่า มันจะ

00:00:35.200 --> 00:00:42.000
ทำให้เว็บเราเร็วขึ้นยังไงได้บ้างนะครับ
อย่างแรกเนี่ย เดี๋ยวแนะนำตัวสักเล็กน้อยนะ ผมชื่อ

00:00:42.000 --> 00:00:48.300
ศิริวัฒน์นะครับ เรียกสั้นๆ ว่า เรียกจุ้นก็ได้
ตอนนี้ก็เป็น UI engineer นะครับ อยู่ที่ทีม MUI

00:00:48.300 --> 00:00:53.300
บริษัทชื่อ MUI นะครับ ทางเราก็เป็นบริษัทที่เชี่ยวชาญเรื่อง

00:00:53.300 --> 00:00:57.200
user interface นะครับ แล้วก็เขียน React มาพอสมควร

00:00:57.200 --> 00:01:03.900
แล้วก็โปรเจคที่เรียกว่าเป็นโปรเจคทำให้ทุกคนรู้จัก
บริษัทเรานี้ ก็คือโปรเจคที่ชื่อว่า

00:01:03.900 --> 00:01:09.400
Material UI นะครับ ก็เป็นโปรเจคที่ได้รับทั้งคำชม
และคำด่านะครับ

00:01:09.400 --> 00:01:12.600
โอเค ซึ่งตอนนี้เป็น open source

00:01:12.600 --> 00:01:19.300
React component library ก็เดี๋ยวจะอธิบายให้ฟังถึงตัว

00:01:19.300 --> 00:01:25.800
โปรเจคนิดนึงนะว่า scale มันอยู่ที่ตรงไหนนะครับ
ทำไมสาเหตุที่มีทั้งคนชมแล้วก็มีทั้งคนด่า

00:01:25.800 --> 00:01:30.800
เรื่องความช้าหรือเรื่อง style อะไรพวกนี้
เดี๋ยวเรามาว่ากัน

00:01:30.800 --> 00:01:36.500
stat เล็กๆ น้อยๆ นะครับ เพื่อให้เราเห็นว่า
โปรเจคมันอยู่ที่ level ตรงไหน

00:01:36.500 --> 00:01:43.200
อย่างคนที่เข้ามาใช้งานตัวเว็บ MUI ตอนนี้ก็ประมาณ
1 ล้านคน 1 ล้านคนเลยนะต่อเดือน

00:01:43.200 --> 00:01:49.700
ตรงนี้ก็จะเป็น programmer, developer หรือ designer
ที่เข้ามาดู doc มา research component

00:01:49.700 --> 00:01:55.800
ดู demo อะไรต่างๆ ประมาณ 1 ล้านคน
ก็ถือว่าเป็นตัวเลขที่เยอะพอสมควรนะครับ

00:01:55.800 --> 00:02:02.500
ส่วนยอดดาวน์โหลด ณ ปัจจุบัน สำหรับตัวแพ็กเกจ
Material UI ก็อยู่ที่ประมาณ 3 ล้าน

00:02:02.500 --> 00:02:07.700
ครั้งนะครับต่อสัปดาห์ ซึ่งสามล้านครั้งเนี่ย

00:02:07.700 --> 00:02:13.400
เยอะหรือไม่เยอะนะ เราลองเทียบกับ

00:02:13.400 --> 00:02:19.800
ตัว React DOM ecosystem ดูนะ ประมาณ 16%
ของยอดดาวน์โหลดทั้งหมดของ React DOM

00:02:19.800 --> 00:02:24.700
ซึ่ง React DOM เนี่ยก็คือ React ของ web platform
ถูกไหมครับ เพราะฉะนั้น

00:02:24.700 --> 00:02:31.000
16% นะ ก็ลองนึกภาพดูว่ามันเป็นตัวเลขที่
ค่อนข้างเยอะพอสมควร ก็ยังเป็น

00:02:31.000 --> 00:02:35.600
อยู่ใน library ที่มียอด download อันดับ 1 อยู่
ในโลกของ React

00:02:35.600 --> 00:02:40.700
แล้วเมื่อกี้เห็นได้ยินว่า React ก็ยังชนะอยู่ใช่ไหม
โอเคเพราะนั้น

00:02:40.700 --> 00:02:46.500
ก็ยังต้องใช้ React อยู่ เพราะถ้าเราก็ชนะ

00:02:46.500 --> 00:02:52.800
ตรงนี้ผมจะแบ่งย่อยลงมาให้ดูว่า ในมุมของคนที่ใช้งาน
ในเชิงที่เป็นบริษัท

00:02:52.800 --> 00:02:56.500
หรือว่าอุตสาหกรรมต่างๆ อยู่ในตรงไหนกันบ้าง

00:02:56.500 --> 00:03:02.100
ก็ลูกค้าของเราเนี่ยจริงๆ ก็ หลากหลาย
อุตสาหกรรมมากๆ นะ อุตสาหกรรมเทค

00:03:02.100 --> 00:03:08.400
เกม รีเทลต่างๆ อวกาศก็มีนะครับ

00:03:08.400 --> 00:03:12.800
ไม่ว่าจะเป็น streaming หนังนะครับ

00:03:12.800 --> 00:03:19.600
เทค โทรศัพท์ เกม รีเทล e-commerce
ก็เป็นลูกค้าของเราทั้งสิ้นเลย

00:03:19.600 --> 00:03:26.400
อันนี้ก็เป็นแค่ส่วนหนึ่งนะครับ จริงๆ มีอีกเยอะมากๆ
ที่ผมก็ไม่สามารถจะใส่มาในสไลด์ได้หมด

00:03:26.400 --> 00:03:31.500
ถ้าอยากให้เห็นว่าโปรเจ Material UI เนี่ย
มันมีทั้งคนชอบและคนไม่ชอบ

00:03:31.500 --> 00:03:35.400
แต่ว่าโดย scale ของมันเป็น scale ที่ค่อนข้างใหญ่นะครับ

00:03:35.400 --> 00:03:41.500
เพราะฉะนั้นเวลาที่เราต้องการเขียนนำเสนอ feature ใหม่ๆ
หรือการปรับปรุงโครงสร้างของโปรเจค

00:03:41.500 --> 00:03:48.200
คือเราไม่สามารถทำได้แบบ นึกอยากจะทำก็ปุ๊บ
commit โค้ด push ขึ้นไปอะไรอย่างนี้นะครับ
เพราะว่ามันมีคนอีกเป็น

00:03:48.200 --> 00:03:54.700
เรียกว่าเป็นล้านๆ โปรเจคที่ใช้โปรเจคเราอยู่นะครับ
มันจะ affect วงกว้างมากๆ

00:03:54.700 --> 00:04:00.800
อย่างที่ทุกคนรู้นะว่าตัว Material UI ข้างหลังมันก็คือ
ถ้าเรื่องของสไตล์มันใช้ CSS-in-JS

00:04:00.800 --> 00:04:05.400
ซึ่งตอนนี้หลักๆ ก็คือจะเป็น library ที่ชื่อว่า Emotion
นะครับ ก็คือเรา

00:04:05.400 --> 00:04:11.400
เรียกว่าข้างหลังเป็น Emotion ในการเขียนสไตล์ขึ้นมา แล้วก็

00:04:11.400 --> 00:04:15.800
เราก็เอา design guidelines ของทาง Google มาใช้
แล้วก็ต้องขอย้ำว่า

00:04:15.800 --> 00:04:21.899
เราไม่ได้เกี่ยวอะไรกับทาง Google นะ ไม่ใช่แบบ
บริษัทลูก Google อะไรอย่างนั้น ไม่เกี่ยวกันเลยนะครับ

00:04:21.899 --> 00:04:28.500
เราแค่ทำ component library ได้ดีกว่า Google
แค่นั้นเอง ก็เลยมีคนเอาไปใช้

00:04:28.500 --> 00:04:34.100
โอเคนะครับ ต่อมาเดี๋ยวเรามาเข้าเรื่อง CSS-in-JS
กันนิดนึงนะครับ เมื่อกี้เห็นมีบางคนที่

00:04:34.100 --> 00:04:38.500
อาจจะไม่ได้ยกมือนะ อาจจะยังไม่เก็ต
หรือว่าไม่เคยได้ยินเลยนะครับ เดี๋ยวจะปู

00:04:38.500 --> 00:04:42.400
พื้นฐานให้ฟังเล็กน้อยนะครับ โดยสรุปว่ามันคืออะไร

00:04:42.400 --> 00:04:49.400
โดยชื่อมันก็ตรงตัวอยู่แล้วว่ามันคือการที่เราเขียน CSS
ในรูปของในไฟล์ JavaScript ได้

00:04:49.400 --> 00:04:55.600
หน้าตาเนี่ยส่วนใหญ่ๆ นะครับ คือ library ทุกอันเนี่ย
มันจะมีฟังก์ชันให้เรา

00:04:55.600 --> 00:05:01.900
ที่ส่วนใหญ่ชื่อ CSS เลยนะครับ คือฟังก์ชันเนี้ยเวลาที่เรา

00:05:01.900 --> 00:05:07.000
เรียกนะครับ เราจะสามารถใส่สไตล์ลงไปได้
สไตล์เนี่ยอาจจะเป็นตัว template

00:05:07.000 --> 00:05:11.400
literal string นะครับ หรือจะเป็น object ก็ได้
พอเราใส่เข้าไปปุ๊บนะครับ

00:05:11.400 --> 00:05:18.200
สิ่งที่มันจะ return มาให้เราเนี่ย ก็จะมันจะ
generate class name ขึ้นมาให้
ก็คือ random ขึ้นมา เสร็จแล้วพวก

00:05:18.200 --> 00:05:23.100
random string พวกนี้ก็เอาไปใส่ใน class name
ทีนี้พอเราเลือกใช้ปุ๊บเนี่ย

00:05:23.100 --> 00:05:27.200
library มันจะมีการสร้าง cache ขึ้นมาเป็น object

00:05:27.200 --> 00:05:33.400
ก็ object เปล่าๆ เลย ใส่ cache เข้าไป
แล้วก็สุดท้ายมันจะเอา style พวกนั้นนะครับ

00:05:33.400 --> 00:05:39.300
ที่มันเก็บไว้ไปพ่นออกมานะครับ พ่นออกมาเป็น style tag

00:05:39.300 --> 00:05:46.700
อันนี้คือการทำงานคร่าวๆ อย่างโดยสรุปของตัว
CSS-in-JS ส่วนใหญ่ก็จะเป็นประมาณนี้

00:05:46.700 --> 00:05:51.700
ซึ่งข้อดีของมันก็คือหนึ่งคือเรื่องของ colocation จริงๆ
มันจะมี

00:05:51.700 --> 00:05:55.800
มันจะมีเส้นด้วยนะแต่สงสัยมันมองไม่เห็น

00:05:55.800 --> 00:06:02.700
เรื่องของ colocation เนี่ย ก็คือเราทำทุกอย่าง
ในไฟล์ JavaScript ไฟล์เดียว เพราะฉะนั้นมันจะ

00:06:02.700 --> 00:06:07.900
เรียกว่าเหมาะมาก ถ้าเราจะเอามาสร้างเป็น
component ใช้ในโปรเจค

00:06:07.900 --> 00:06:11.300
แล้วก็จะมีเรื่องของ runtime JavaScript ที่

00:06:11.300 --> 00:06:17.400
เนื่องจากว่ามันอยู่ใน JavaScript นะ เวลาเราจะเขียนพวก
conditions ต่างๆ อะไรพวกนี้ มันก็ทำได้ง่ายถูกไหมครับ
ทำได้สะดวกเลย

00:06:17.400 --> 00:06:23.900
ถ้าเป็นใน CSS เนี่ย เราจะเขียนสไตล์ที่เป็น condition
ยังไง เราก็ต้องไปสลับ class name เอา

00:06:23.900 --> 00:06:28.900
อะไรพวกนี้มันก็จะมีความลำบากดูอ้อมๆ นิดหนึ่ง

00:06:28.900 --> 00:06:35.900
สิ่งที่สำคัญก็คือเรื่องของ scope นะครับ คืออย่างที่บอกว่า
มันเหมาะกับการสร้าง component มากๆ เลย เพราะว่า

00:06:35.900 --> 00:06:43.400
component เนี่ย คือเราต้องการให้มัน reusable ใช่ไหมครับ
แต่ว่าถ้าเราสร้างด้วยอย่าง CSS อะไรอย่างเนี้ย

00:06:43.400 --> 00:06:49.800
class name มันอาจจะ conflict กับคนอื่นได้ ถูกไหม
เพราะ class name ถ้ามันเหมือนกัน
style มันก็จะ override ทับกัน

00:06:49.800 --> 00:06:54.600
ขึ้นอยู่กับ order ของ CSS ตรงนั้นนะครับ

00:06:54.600 --> 00:06:58.600
อันนี้คือข้อดีโดยคร่าวๆ นะ อันนี้จะเป็นกราฟของ

00:06:58.600 --> 00:07:03.000
ของ CSS-in-JS ก็คือตัว Emotion
กับ styled-components นะ
ก็คือเป็นยอดดาวน์โหลด

00:07:03.000 --> 00:07:07.600
ผมเอามาให้ดูว่าประมาณช่วงประมาณ 3-4 ปีที่ผ่านมา

00:07:07.600 --> 00:07:14.600
เราจะเห็นว่ายอดดาวน์โหลดมันก็พุ่งขึ้นเรื่อยๆ นะครับ
มันก็แสดงให้เห็นว่ามีคนเริ่มจะเข้ามาใช้งานเยอะขึ้นๆ

00:07:14.600 --> 00:07:19.500
ก็ในช่วงประมาณ 4-5 ปีที่ผ่านมามันก็ค่อยๆ โตขึ้นนะครับ

00:07:19.500 --> 00:07:24.200
แน่นอนว่าสาเหตุน่าจะเป็นเพราะว่า 4-5 ปีที่แล้ว

00:07:24.200 --> 00:07:28.200
JavaScript มันก็เริ่มบูมขึ้นนะฮะ ทำทุกอย่างด้วย JavaScript นะ

00:07:28.200 --> 00:07:33.300
ก็เลยต้องมี CSS-in-JS ด้วย แล้วก็ไม่ว่าจะเป็นเรื่องของ
design system

00:07:33.300 --> 00:07:40.200
ที่มันเป็นเทรนด์ที่เข้ามา ทุกบริษัทก็ต้องมี design system
ของตัวเอง แล้วก็เรื่องของการสร้าง component

00:07:40.200 --> 00:07:47.200
ก็เป็นเทรนด์ที่แบบมาแรงมากๆ เพราะฉะนั้นคิดว่า
ตัว CSS-in-JS ก็ได้รับความนิยมสูงขึ้นนะครับ

00:07:47.200 --> 00:07:53.500
แน่นอนพอมันมีคนใช้งานเยอะขึ้นสูงขึ้นเรื่อยๆ นะครับ
มันก็จะเริ่มเห็น

00:07:53.500 --> 00:07:59.900
edge case มากขึ้น จนมาถึงประมาณกลางปีที่แล้วที่

00:07:59.900 --> 00:08:05.300
มันเริ่มจะเป็นจุดเปลี่ยนนิดนึง ให้คนก็เริ่มตั้งคำถาม
มากขึ้นนะว่า

00:08:05.300 --> 00:08:10.200
ควรจะใช้ต่อไหม หรือเราควรจะย้ายไปใช้อย่างอื่นดี
ถามว่าจุดไหน

00:08:10.200 --> 00:08:16.900
เป็นจุดที่ Next.js เขาออกตัว stable version ของ
React Server Components มานะครับ

00:08:16.900 --> 00:08:21.200
ก็ทางทีม React เขาก็ออกมาบอกเหมือนเป็น note บอกว่า
เอ้ย ถ้าเกิด

00:08:21.200 --> 00:08:29.000
เป็นโน้ตฝากถึง maintainer ของ CSS-in-JS library ว่า

00:08:29.000 --> 00:08:34.600
React Server Component โดยสรุปคือ
มันยังไม่ compatible กับ CSS-in-JS นะครับ

00:08:34.600 --> 00:08:38.700
เพราะฉะนั้นตอนนั้นทุกคนก็เลยเปิด issue เปิดทุกที่เลย

00:08:38.700 --> 00:08:45.400
เปิดว่า ช่วยทำให้มันเวิร์กหน่อย เปิดที่ Material UI
เปิดที่ Emotion เปิดที่ Next.js เปิดมาหมดเป็น issue เดียวกัน

00:08:45.400 --> 00:08:49.900
ซึ่งสุดท้ายมันลิงก์มาอยู่ที่เดียวนะครับ
ซึ่งตอนนี้ก็ยังแก้ไม่ได้นะครับ

00:08:49.900 --> 00:08:53.700
มันคงเป็นปัญหาเรื่องของ architecture ของตัว

00:08:53.700 --> 00:09:00.700
React Server Component ด้วยที่มัน
ไม่ค่อยเหมาะสมกับตัว CSS-in-JS สักเท่าไหร่

00:09:00.700 --> 00:09:03.300
ก็เรื่องนี้ก็ไม่ได้มีใครผิดนะ

00:09:03.300 --> 00:09:11.200
โอเค ทีนี้มันก็จะมีอันหนึ่งก็คือ ตัวของ State of CSS
ที่มันเป็นเรียกว่า

00:09:11.200 --> 00:09:20.100
ข้อมูลอีกอันหนึ่งนะ- อ่า อินเทอร์เน็ตไม่มี เยี่ยมเลย
แล้วคีย์โน้ตหายไปไหน

00:09:20.100 --> 00:09:26.800
ไม่เป็นไรนะครับ เดี๋ยวทุกคนลองไปเสิร์ช Google ดูกันนะ
State of CSS 2023 ล่าสุดเลยนะครับ

00:09:26.800 --> 00:09:32.900
เราจะสังเกตมันจะมีแท็บหนึ่งที่เป็นแท็บ
CSS-in-JS เลย เราจะเห็นว่า

00:09:32.900 --> 00:09:38.100
ในกราฟเนี่ย ค่าของ retention
มันจะดร็อปลงทุกๆ ปีนะครับ

00:09:38.100 --> 00:09:44.900
หมายถึงว่าในทุกๆ ปีเนี่ย
มีคนใช้ CSS-in-JS น้อยลงเรื่อยๆ
แล้วทุกคนย้ายไปไหน

00:09:44.900 --> 00:09:51.800
คิดว่าตอนนี้ทุกคนก็น่าจะได้ยิน
เรื่องของ Tailwind อะไรพวกนี้ใช่ไหม
อะไรที่มันเป็นเหมือนกับ static CSS

00:09:51.800 --> 00:09:57.900
มากขึ้นนะครับ อย่าไปยุ่งกับฝั่ง JavaScript
อะไรประมาณนี้นะครับ

00:09:57.900 --> 00:10:02.300
ซึ่งผมคิดว่าปีนี้ ปีนี้มันน่าจะคงที่ละ

00:10:02.300 --> 00:10:07.900
น่าจะไม่ค่อยมีคนใช้ CSS-in-JS เพิ่มขึ้นแล้ว
แล้วมันก็จะค่อยๆ ดร็อปลงเรื่อยๆ นะครับ

00:10:07.900 --> 00:10:14.300
ถ้าเรายังหา solution ใหม่ๆ ไม่เจอนะครับ 
คนก็จะย้ายไป เรียกว่าเขียน pure CSS หรือว่าเขียน

00:10:14.300 --> 00:10:17.600
CSS Module อะไรพวกนี้น่าจะเหมาะสมกว่า

00:10:17.600 --> 00:10:23.200
โอเค นี่แหละอย่างทีม MUI เนี่ย เราก็ได้รับรีพอร์ต issue
เรื่องนี้มาพอสมควรนะครับ แล้วเราก็

00:10:23.200 --> 00:10:29.400
เรียกว่าทราบดีมากๆ ถึงปัญหาที่เรามีอยู่ แต่อย่างที่บอก
นะครับเราไม่สามารถที่จะแบบ นึกจะแก้อะไรก็

00:10:29.400 --> 00:10:34.600
push commit อะไรอย่างนี้ไม่ได้นะครับ
เราต้องมีการ research ก่อนนะครับ ซึ่ง

00:10:34.600 --> 00:10:38.900
เราก็ไม่อยากที่จะเหมือนกับเปลี่ยน

00:10:38.900 --> 00:10:42.700
engine ทั้ง engine เลยนะครับ เพราะว่าถ้าเราเปลี่ยน

00:10:42.700 --> 00:10:48.400
การ migrate โค้ดของคนที่ใช้โปรเจคเราอยู่
เรียกว่ามันจะต้องใช้เวลานาน

00:10:48.400 --> 00:10:54.300
ลองเล่นภาพดูว่า มีหนึ่งล้านโปรเจคที่ใช้ Material UI

00:10:54.300 --> 00:11:00.200
แล้วเขาต้องการเวลาหนึ่งวันในการ migrate เพื่อไป engine ใหม่

00:11:00.200 --> 00:11:06.600
แน่นอนว่ามันจะเร็วขึ้นแหละอะไรพวกนี้นะ
แต่ 1 วันเลยนะ 1 ล้าน project ก็คือ

00:11:06.600 --> 00:11:12.000
หนึ่งล้านวัน ของเวลาที่ developer
ต้องเสียไปกับการ migrate โค้ด

00:11:12.000 --> 00:11:17.000
อันนี้เป็นส่วนหนึ่งที่ทางทีมเราเรียนรู้ว่า
การที่จะทำ open source ให้มัน

00:11:17.000 --> 00:11:23.000
สำเร็จนะครับ เรื่องนี้เป็นเรื่องที่สำคัญมาก
ที่เราจะต้องคิดให้ดีว่าจะทำยังไง เพราะฉะนั้นเนี่ย

00:11:23.000 --> 00:11:25.100
เรามีเป้าหมาย

00:11:25.100 --> 00:11:31.600
ในการที่จะแก้ปัญหานี้อยู่ อย่างแรกคือโอเค
มันต้องเร็วขึ้นแน่นอน

00:11:31.600 --> 00:11:35.300
ต้อง compatible กับตัว React Server Component

00:11:35.300 --> 00:11:39.500
แล้วก็มันจะต้องมี runtime JavaScript ที่น้อยที่สุด

00:11:39.500 --> 00:11:45.000
อย่างเมื่อกี้ที่เราเห็นแล้วว่า ตัว CSS-in-JS
คือทุกอย่างเนี่ยมันเป็น

00:11:45.000 --> 00:11:50.400
JavaScript ที่มันต้อง run บน client นะครับ
ตรงนั้นมันจะมี

00:11:50.400 --> 00:11:56.500
bottleneck อยู่นะ ถ้าเกิดว่าเราเขียน style เยอะๆ
อะไรพวกนี้ ก็จะอาจทำให้เว็บช้าได้

00:11:56.500 --> 00:12:00.500
ตอนนั้นสิ่งที่เราต้องการก็คือ เราต้องการให้ runtime
มันน้อยที่สุด

00:12:00.500 --> 00:12:05.700
แล้วก็อย่างที่บอก สิ่งที่สำคัญมากๆ เลยก็คือ
เรื่องของการ migrate โค้ด

00:12:05.700 --> 00:12:12.000
สำหรับฝั่งโปรแกรมเมอร์นะครับ เราจะพยายามหา API
ที่มันใกล้เคียงกับสิ่งที่เขาใช้อยู่

00:12:12.000 --> 00:12:20.400
แล้วก็ให้เขาได้ประโยชน์ของ static CSS ไปด้วยเลย
โดยที่เขาแทบจะไม่ต้อง migrate อะไรก็ตาม

00:12:20.400 --> 00:12:27.000
ซึ่งจริงๆ แล้วเราก็ลอง research แล้วเราก็พบว่า
มันมีคนที่ทำพวกนี้ให้อยู่แล้วนะครับ

00:12:27.000 --> 00:12:32.400
เรียกว่า กลุ่มนี้เป็น Next Generation
ของ CSS-in-JS ทั้งหมดเลยนะครับ

00:12:32.400 --> 00:12:37.500
ก็คือเป็น library ที่จะ build- อย่างเขียน

00:12:37.500 --> 00:12:43.700
CSS ในรูปแบบของ JavaScript ได้
แต่ว่ามันจะเป็นการ build static file

00:12:43.700 --> 00:12:49.600
CSS ออกมาทั้งหมดเลยนะครับ
ยกตัวอย่างเช่น Vanilla Extract นะครับ

00:12:49.600 --> 00:12:56.000
อันนี้ก็มี ค่อนข้างมีชื่อเสียงเหมือนกัน
แล้วก็ Compiled นี่เป็นของ Atlassian

00:12:56.000 --> 00:13:02.600
แล้วก็มี Panda CSS เคยได้ยินไหม
Panda CSS ของทีม-
มีใครเคยใช้ Chakra UI ไหมครับ

00:13:02.600 --> 00:13:06.800
Chakra UI อันนี้ก็คือทีมเดียวกันเลย
ที่เขาพัฒนาตัวนี้ขึ้นมา

00:13:06.800 --> 00:13:13.400
อันนี้เป็น Atomic CSS นะครับ แล้วก็มี Linaria
อันนี้ของทีมที่ชื่อว่า Callstack นะครับ

00:13:13.400 --> 00:13:22.400
Stylex ของ Meta นะครับ ซึ่งออกมาไม่นาน
แล้วก็มี Griffel ของ Microsoft

00:13:22.400 --> 00:13:27.700
Griffel อันนี้ก็พอดีทางทีมเราก็มีโอกาสได้คุยกับคน
ที่เขาสร้าง Griffel เหมือนกัน

00:13:27.700 --> 00:13:34.700
ก็ได้ข้อมูลมาค่อนข้างเยอะนะครับเกี่ยวกับการพัฒนา
library อะไรพวกนี้

00:13:34.700 --> 00:13:41.500
ทีนี้เราพบมาตัวหนึ่งว่าตัวนี้แหละเป็นตัวที่เราน่าจะใช้มา
extend ต่อได้ แล้วก็

00:13:41.500 --> 00:13:48.800
ทำให้ API มันใกล้เคียงกับของเดิมมากที่สุด
ก็คือตัวที่ชื่อว่า Linaria

00:13:48.800 --> 00:13:54.000
มาจากทีม Callstack นะครับ เราเอาตัวนี้มา
ณ ตอนนี้นะครับ เราเอาตัวนี้มา

00:13:54.000 --> 00:13:58.800
แล้วเราก็เอามา extend API build on top
มันขึ้นไปเพิ่ม feature ต่างๆ

00:13:58.800 --> 00:14:03.000
ให้มันเหมาะสมกับโปรเจค Material UI นะครับ
แล้วเราก็ตั้งชื่อมันว่า

00:14:03.000 --> 00:14:07.900
Zero Runtime นะครับ ซึ่งชื่อนี้ก็ยังเป็น-
เรียกว่าอะไร

00:14:07.900 --> 00:14:14.000
ชื่อยังไม่ final นะ แต่ว่าในวันนี้เนี่ย
เรียกว่าเราทำความรู้จักมันด้วยชื่อนี้กันก่อนนะครับ

00:14:14.000 --> 00:14:20.800
ตัว Zero Runtime ตัวนี้ เดี๋ยวเราจะมาดูนะครับว่า
มันจะต่างจากเดิมยังไง

00:14:20.800 --> 00:14:25.700
โดยเราจะใช้ Next.js project เป็นตัวอย่าง

00:14:25.700 --> 00:14:32.100
อันนี้เดี๋ยวจะเป็น Next.js project ที่มีการใช้ Emotion
สร้างเป็นปุ่มขึ้นมา

00:14:32.100 --> 00:14:38.000
และเดี๋ยวเราจะมาลอง migrate ดู ว่าเราจะ migrate
นี้ไปเป็น Zero Runtime ได้ยังไง

00:14:38.000 --> 00:14:41.800
โอเค มีคนแย่งซีนแล้วหนึ่ง

00:14:41.800 --> 00:14:46.800
โอเคครับ อย่างแรกเลย เราจะต้องมาแก้ config file ก่อน

00:14:46.800 --> 00:14:53.800
Next.js เขาจะมีตัว config file ให้เราก็ชื่อว่า
next.config.js นะครับ

00:14:53.800 --> 00:15:01.200
สิ่งที่เราจะต้องทำก็คือ เราจะต้องไป import plugin
ที่ทางทีมเราเนี่ย ทางทีมผมเนี่ยจะ

00:15:01.200 --> 00:15:05.800
สร้างออกมาให้นะครับ ทีนี้เราก็ import แล้วก็เราก็ใช้

00:15:05.800 --> 00:15:09.700
ตัวนี้ไปแปะตรงตัว config file

00:15:09.700 --> 00:15:16.300
แน่นอนตอนนี้เราไม่ต้องสนใจเลยว่ามันทำอะไร
ขอแค่ว่านี่คือสิ่งที่เราจะต้องเพิ่มเข้าไปนะครับ

00:15:16.300 --> 00:15:23.200
เพิ่มตัว config file เข้าไป เรียกว่าให้
Zero Runtime มันรู้จักโปรเจคนะครับ

00:15:23.200 --> 00:15:28.100
ต่อมาเราจะกลับมาดูที่โค้ดที่เราเขียนตอนแรกนะครับ
อันนี้คือโค้ดที่

00:15:28.100 --> 00:15:34.000
เราสร้างตัวปุ่มขึ้นมานะครับ ด้วย Emotion style API

00:15:34.000 --> 00:15:36.500
ตรงนี้ก็ค่อนข้างจะ

00:15:36.500 --> 00:15:41.600
ตรงตัวนะครับ คือเราสร้างปุ่มจากตัว style API แล้วก็ใส่

00:15:41.600 --> 00:15:47.300
ฟังก์ชัน คือฟังก์ชันมันจะให้ theme เรากลับมา
ถ้าเรามีการสร้าง theme แล้วเราก็-

00:15:47.300 --> 00:15:52.200
ตัว background เราสามารถที่จะ
รับค่าจาก property ได้ด้วย

00:15:52.200 --> 00:15:59.200
ก็คือเป็น dynamic style นะ ตัวปุ่มเนี้ย
สีปุ่มก็จะเปลี่ยนตาม prop ที่ชื่อว่า bg นะครับ

00:15:59.200 --> 00:16:05.500
โอเค แล้วอันอื่นเนี่ยก็ตรงตัวนะครับ
มันก็จะใช้ค่าจาก theme
ซึ่งตอนนี้เราไม่จำเป็นต้องรู้ว่า theme คืออะไรบ้าง

00:16:05.500 --> 00:16:12.600
เอาเป็นว่าเดี๋ยว theme มันจะส่งค่าที่เป็นพิกเซล
หรือเป็นค่าตัวเลขอะไรกลับมาให้เราเอง

00:16:12.600 --> 00:16:16.600
เสร็จแล้วเราก็ render ตัวปุ่มนี้นะครับ แล้วก็ใส่ bg เข้าไป

00:16:16.600 --> 00:16:21.400
อย่างตอนแรกสุดเลยเนี่ย bg เราเป็นสีแดงใช่ไหม
เพราะฉะนั้นเราก็จะเห็นปุ่มเรา

00:16:21.400 --> 00:16:25.600
render ออกมาเป็นสีแดงก่อน แล้วพอเราคลิกนะครับ

00:16:25.600 --> 00:16:32.400
พอคลิกตัวปุ่ม ปุ๊บ ตัวฟังก์ชัน random เนี่ย
มันคิดว่ามันจะ return สีใหม่ออกมาให้เรา

00:16:32.400 --> 00:16:38.000
พอเราคลิกปุ๊บ สีปุ่มก็จะเปลี่ยนไปเรื่อยๆ
ตอนที่เราคลิกๆ อันนี้คือ

00:16:38.000 --> 00:16:40.400
คร่าวๆ ของสิ่งที่

00:16:40.400 --> 00:16:47.000
มันเกิดขึ้นอยู่อย่างนี้นะครับ ทีนี้พอเราจะขยับไปใช้
Zero Runtime อย่างแรกคือเราแก้ config file แล้ว

00:16:47.000 --> 00:16:52.100
อย่างที่สองเนี่ย นี่คือสิ่งที่ทางทีมเราดีไซน์ไว้
คือเราดีไซน์ให้ทุกคน

00:16:52.100 --> 00:16:58.100
แค่แก้ import path แค่นั้นพอ
ก็คือแก้ import จากการใช้ Emotion นะ

00:16:58.100 --> 00:17:01.700
ย้ายมาใช้แพ็กเกจที่ชื่อว่า Zero Runtime

00:17:01.700 --> 00:17:08.300
ทุกคนอาจจะสงสัย เอ๊ แล้วมันจะต่างยังไง
มันก็ดูเหมือนเดิมเลยนะครับ เขียนเหมือนเดิมทุกอย่าง
มันจะต่างจากเดิมตอนนี้ครับ

00:17:08.300 --> 00:17:11.099
ตอนนี้ทุกคนรัน yarn build

00:17:11.099 --> 00:17:17.900
อย่างตอนแรกที่เราแก้ config file ใช่ไหม
ตอนนี้ Zero Runtime มันจะเข้าไปอยู่ใน build process

00:17:17.900 --> 00:17:20.800
ของ Next.js นะครับ

00:17:20.800 --> 00:17:27.800
ตัว Next.js เวลามัน build มันก็จะ process ไฟล์ต่างๆ
ที่เรามีการเขียนนะ import ใช่ไหม แต่ละ route
อะไรพวกนี้ครับ

00:17:27.800 --> 00:17:34.600
มันก็จะดึงไฟล์เข้ามา ตัว Zero Runtime เนี่ย
จะเข้าไปอยู่ ไปแทรกอยู่ใน build process

00:17:34.600 --> 00:17:41.000
ตัว Zero Runtime อย่างแรกที่มันจะทำคือ
มันจะ evaluate ไฟล์ว่ามีการ import

00:17:41.000 --> 00:17:46.600
Zero Runtime อยู่หรือเปล่า อย่าง case นี้
โอเค เจอแล้ว มีการ import

00:17:46.600 --> 00:17:50.900
มันจะไล่ดูต่อไปที่ style call นะครับ

00:17:50.900 --> 00:17:58.000
พอเจอปุ๊บ อ๋อ ไฟล์นี้มีการใช้ Zero Runtime
ในการสร้าง component ขึ้นมา

00:17:58.000 --> 00:18:04.800
มันจะทำการอ่านตัว style นะครับ
แล้วก็ extract ออกมา

00:18:04.800 --> 00:18:11.700
อยู่ในไฟล์ CSS ตรงนี้เกิดขึ้นที่ build time นะครับ
ตอนที่เรารัน yarn build มันจะทำงานประมาณนี้นะครับ

00:18:11.700 --> 00:18:13.800
เสร็จ

00:18:13.800 --> 00:18:20.800
อย่างแรกมันจะสร้าง class ก็คือ generate class ขึ้นมา
อันนี้ก็ยังอยู่ใน CSS-in-JS อยู่นะครับ
generate class ขึ้นมา

00:18:20.800 --> 00:18:23.500
แล้วก็อะไรก็ตาม

00:18:23.500 --> 00:18:28.800
ค่าอะไรก็ตามที่เป็นฟังก์ชันนะครับ
เราจะแทนค่าตรงนั้นด้วย

00:18:28.800 --> 00:18:35.200
CSS Variable อย่างที่ทุกคนเห็นอยู่
ซึ่งมัน hash ตัวแปรขึ้นมา

00:18:35.200 --> 00:18:39.700
ตรงนี้คือ CSS Variable นะครับ อยู่ใน CSS

00:18:39.700 --> 00:18:43.700
โอเค แต่ว่าเราจะ generate ค่าตัวแปรขึ้นมา

00:18:43.700 --> 00:18:47.400
แล้วก็แปะลงไปเพื่อให้มันสามารถที่จะ run บน CSS ได้

00:18:47.400 --> 00:18:53.900
แล้วก็ whatever ที่เป็น theme การใช้งานอะไรพวกนี้
เราจะ resolve ออกมาเพื่อให้

00:18:53.900 --> 00:18:58.300
มันเป็น valid CSS

00:18:58.300 --> 00:19:04.800
โอเค สุดท้ายนะครับ เราจะมีการ modify
ตัว JavaScript ไฟล์นี้ด้วย สิ่งที่ทุกคนเขียน

00:19:04.800 --> 00:19:10.900
เนื่องจากว่าเรามีการ generate ตัว CSS ขึ้นมาแล้ว
เรามี class name อะไรโผล่ขึ้นมาแล้ว

00:19:10.900 --> 00:19:17.500
เราจะเอา class name พวกนั้นแปะกลับเข้าไป
แล้วเราก็จะแก้ไฟล์นี้ให้

00:19:17.500 --> 00:19:24.200
ซึ่งข้างหลังเนี่ย ฟังดูอาจจะง่ายนะ แต่ข้างหลังมันจะมี
เรื่องแบบ AST อะไรที่เราต้องแปลง แล้วก็แปลงกลับ

00:19:24.200 --> 00:19:28.400
ก็จะมีความสนุกอยู่เหมือนกันนะครับ

00:19:28.400 --> 00:19:35.200
เราต้องการที่จะ reference ตัว class
กับตัว variable พวกนี้ในไฟล์ CSS
กับไฟล์ JavaScript

00:19:35.200 --> 00:19:39.900
เพราะฉะนั้นเราก็เลยต้องมีการแก้ code นิดหนึ่ง
แปะกลับเข้าไป

00:19:39.900 --> 00:19:44.100
อันนี้คือ build time เสร็จแล้ว build เสร็จแล้ว

00:19:44.100 --> 00:19:50.300
เสร็จแล้วพอมันไปอยู่ใน runtime นะครับ
พอตัวแอปเรา render บนหน้าเว็บไซต์ปุ๊บ

00:19:50.300 --> 00:19:55.900
อ่า ตัวข้างล่างนี้คือ HTML ที่เราจะเห็น
เราจะสังเกตว่าเราก็จะเห็น class ใช่ไหม

00:19:55.900 --> 00:19:57.800
ที่มันมาจาก

00:19:57.800 --> 00:20:04.100
ข้างนู้นนะครับ และ class นี้ก็จะได้ style
ที่มาจากไฟล์ CSS

00:20:04.100 --> 00:20:10.500
มันก็จะไม่มี runtime JavaScript เลย
ถ้าเราไม่นับ React นะครับ

00:20:10.500 --> 00:20:14.200
โอเค ทีนี้มีอันหนึ่งที่อยากจะเน้นคือ

00:20:14.200 --> 00:20:20.800
ตัวที่เป็น inline style นะครับ ที่เป็น dynamic style
ตัว style พวกนี้มันเกิดจาก

00:20:20.800 --> 00:20:26.200
ค่า state ใช่ไหมครับ ทีนี้ถ้า state เปลี่ยน
background ก็จะเปลี่ยน

00:20:26.200 --> 00:20:32.900
แล้ว Zero Runtime มันทำงานได้ยังไง
เวลาที่เราคลิกปุ๊บ เราจะได้ background ใหม่ขึ้นมาใช่ไหม

00:20:32.900 --> 00:20:37.300
แล้ว state ก็จะถูก set component ก็จะถูก re-render ใช่ไหม

00:20:37.300 --> 00:20:43.000
สมมุติว่าเรากดคลิกนะครับ เราได้ background
เป็น yellow เข้าไป

00:20:43.000 --> 00:20:47.800
ตัว React ก็จะทำการอัปเดต inline style

00:20:47.800 --> 00:20:52.700
นึกตามดีๆ นะ อัปเดต inline style นะ
ไม่ได้อัปเดต CSS

00:20:52.700 --> 00:21:01.300
อ่า นี่คือเทคนิคในการใช้งาน
เพื่อให้ไฟล์ CSS ของเราเนี่ย ไม่มีการถูกแก้อีก

00:21:01.300 --> 00:21:05.500
เพราะฉะนั้นมันจะเร็วมาก
ก็คือเหมือนเราเขียนไฟล์ CSS เลย

00:21:05.500 --> 00:21:09.600
แต่ว่าเราเขียนในรูปแบบของ JavaScript เราให้

00:21:09.600 --> 00:21:13.300
ตัว bundler อะไรพวกนี้มันทำการ

00:21:13.300 --> 00:21:17.400
แปลงโค้ดออกมาให้นะครับ อันนี้ก็คือวิธีการทำงาน

00:21:17.400 --> 00:21:21.700
เพราะฉะนั้นถ้าเกิดว่าเราย้อนกลับไปประมาณสัก
3-4-5 ปีที่แล้ว

00:21:21.700 --> 00:21:25.600
เราจะไม่มีทางทำอะไรแบบนี้ได้ เพราะว่า

00:21:25.600 --> 00:21:31.300
ยุคนั้น CSS Variable ยังไม่ได้
fully support เบราว์เซอร์ทั้งหมด

00:21:31.300 --> 00:21:35.900
มันก็เลยเรียกว่าอาจจะยังเป็นแค่ช่วง research
แต่ ณ ปัจจุบันเนี่ย

00:21:35.900 --> 00:21:40.100
เราสามารถทำแบบนี้ได้
เพราะว่า CSS variable มัน fully support

00:21:40.100 --> 00:21:46.900
ทุกเบราว์เซอร์แล้ว แล้วก็ค่อนข้างที่จะเป็น
เปอร์เซ็นต์ที่เยอะมากด้วย น่าจะเกิน 96%

00:21:46.900 --> 00:21:54.100
เพราะฉะนั้นเนี่ย เราเลยพร้อมแล้วที่จะไปทาง
build time รัวๆ นะครับ

00:21:54.100 --> 00:21:59.900
โอเค result ที่เกิดขึ้นมี
2 อันนะที่เห็นได้ชัดเลย หนึ่งก็คือ

00:21:59.900 --> 00:22:06.300
เราไม่มี library CSS-in-JS แปะไปหา user แล้ว

00:22:06.300 --> 00:22:10.200
ถูกไหมครับ เพราะว่าทุกอย่างเนี่ย
มันเกิดขึ้นตอน build time

00:22:10.200 --> 00:22:14.000
ตอน build time เราได้ไฟล์ CSS ออกมา

00:22:14.000 --> 00:22:18.800
แล้วก็ตัว JavaScript เนี่ย
แทบจะเรียกได้ว่า

00:22:18.800 --> 00:22:25.100
React ทั้งยวงเลย
แทบจะไม่เกี่ยวอะไรกับตัว CSS-in-JS เลยนะครับ

00:22:25.100 --> 00:22:27.300
อ่า เพราะงั้นเนี่ย

00:22:27.300 --> 00:22:34.100
ถ้าเราใช้ Emotion อย่างน้อยลดได้อย่างต่ำ
ก็คือ 20 กิโลไบต์แน่นอนที่ส่งไปหา user

00:22:34.100 --> 00:22:40.700
ส่วน runtime ก็ไม่มี runtime เลยนะครับ
runtime เรียกว่าก็คือ React อย่างเดียว

00:22:40.700 --> 00:22:44.400
เพราะว่า style ทั้งหมดมันไปอยู่ในไฟล์ CSS ใช่ไหม

00:22:44.400 --> 00:22:50.800
แล้วอะไรก็ตามที่ ถึงแม้ว่าจะเป็น dynamic style เนี่ย
React จะทำหน้าที่อัปเดตตัว inline style

00:22:50.800 --> 00:22:56.100
แล้วค่าเนี่ยมันก็จะสลับกันตาม
CSS Variable แทน

00:22:56.100 --> 00:23:03.600
ซึ่งตรงนี้เบราว์เซอร์จัดการให้ทั้งหมดเลย
ก็เป็นปกติตามการ parse style ของเบราว์เซอร์

00:23:03.600 --> 00:23:06.200
ซึ่งเร็วมากๆ นะครับ

00:23:06.200 --> 00:23:11.700
อันนี้เป็น เรียกว่า research ที่เราลองทำมาดูนะครับ
ก็คือเราลอง test ตัว

00:23:11.700 --> 00:23:17.200
Total Blocking Time ดูว่าถ้าเกิดว่าเรา render
1,000 ปุ่ม Material UI 1,000 ปุ่มนะครับ

00:23:17.200 --> 00:23:22.100
เราได้ตัว TBT ทั้งหมดอยู่ที่ประมาณ 10 millisec

00:23:22.100 --> 00:23:26.300
ถ้าเราใช้ Emotion ที่เป็น style engine จริงๆ อะ
แต่ว่าถ้าเกิดว่าเรา

00:23:26.300 --> 00:23:31.500
migrate ไปที่ Zero Runtime ปุ๊บเนี่ย
มันก็คือจะกลายเป็นศูนย์เลย
ซึ่งมันก็ค่อนข้างที่จะ make sense นะ

00:23:31.500 --> 00:23:36.600
อย่างตัว input เนี่ย 1,000 input
อันนี้เริ่มมี style เยอะมากขึ้นแล้วก็มี logic

00:23:36.600 --> 00:23:42.100
มากขึ้นนะครับ ตัวนี้อยู่ที่ประมาณ 250 millisec
ซึ่งก็ค่อนข้างเยอะนะครับ

00:23:42.100 --> 00:23:47.800
ถ้านับในเชิงของตัว Total Blocking Time
แต่ว่าถ้าเป็น Zero Runtime ก็จะกลายเป็นศูนย์

00:23:47.800 --> 00:23:54.300
performance ก็จะเขียวขจี 100% เต็ม

00:23:54.300 --> 00:24:01.300
นะครับ โอเค ถึงตรงนี้เนี่ย
ทุกคนน่าจะพอเห็นภาพแล้วว่า
เอ๊ะ ตัว Next Generation ที่

00:24:01.300 --> 00:24:07.000
ในปีนี้หรือปีหน้า เราน่าจะได้ลองกันมากขึ้นครับ

00:24:07.000 --> 00:24:12.600
ก็จะเป็นยังไงนะครับ ทีนี้เราต้องมาดูว่า
แล้ว timeline เราจะได้ใช้เมื่อไหร่

00:24:12.600 --> 00:24:16.300
ตอนนี้ในทางทีมที่เราคุยกัน เราก็แพลนว่า

00:24:16.300 --> 00:24:20.300
ในช่วงประมาณ quarter 2 ของปีนี้นะครับ

00:24:20.300 --> 00:24:23.900
เราจะออก Material UI เวอร์ชันใหม่
ก็คือเป็นเวอร์ชัน 6

00:24:23.900 --> 00:24:29.700
ซึ่งในเวอร์ชัน 6 เราจะ ship ตัว Zero Runtime
เข้าไปใน library เลยนะครับ แปลว่า

00:24:29.700 --> 00:24:36.700
เวอร์ชัน 6 เนี่ย ถ้าเรา migrate ปุ๊บเนี่ย
เราจะสามารถค่อยๆ extract style เป็น CSS
เพียวๆ ได้

00:24:36.700 --> 00:24:43.400
โดยที่เรา migrate ตามความเร็วของเรา
ที่เราต้องการได้

00:24:43.400 --> 00:24:50.000
โอเค อันนี้คือเรื่องราวทั้งหมดนะครับ
ของ Next Generation CSS-in-JS

00:24:50.000 --> 00:24:54.400
ถ้าเกิดว่าใครมีคำถามสงสัยตรงไหน

00:24:54.400 --> 00:25:00.900
หรืออยากถามเกี่ยวกับโปรเจคเกี่ยวกับบริษัท
อะไรอย่างนี้ ก็เรามาคุยกันข้างนอกได้นะครับ
ในช่วง

00:25:00.900 --> 00:25:02.500
network ใช่ไหม

00:25:02.500 --> 00:25:10.000
Please wrap it up, thank you, OK, thank you
จบแล้วครับทุกคน ขอบคุณมากครับ
