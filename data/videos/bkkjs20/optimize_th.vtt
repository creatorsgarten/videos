WEBVTT

00:00:00.500 --> 00:00:03.300
ก็เซชชั่นนี้นะครับ web app optimization นะครับ

00:00:04.100 --> 00:00:06.100
จากประสบการณ์จริงที่ EarnIn นะครับ

00:00:06.300 --> 00:00:08.000
เดี๋ยวผมขอแนะนำตัวก่อนนะครับ

00:00:08.400 --> 00:00:10.700
ผมศิวัส ขาวเหลือง นะครับ หรือว่าเจมส์นะครับ

00:00:10.700 --> 00:00:13.200
เป็นซีเนียร์ซอฟต์แวร์อินจิเนียร์อยู่ที่ EarnIn ครับ

00:00:15.400 --> 00:00:18.800
ครับผมแม็กกี้นะครับ กฤษฎิ์โภคิน งามสมศักดิ์สกุล

00:00:18.800 --> 00:00:20.600
เป็นซีเนียร์ซอฟต์แวร์อินจิเนียร์ที่ EarnIn ครับ

00:00:22.800 --> 00:00:27.700
อันนี้เป็นประสบการณ์จริงบน production นะครับ

00:00:27.700 --> 00:00:29.900
แล้วก็ผมมี disclaimer นิดหน่อย ก็คือ

00:00:30.400 --> 00:00:34.900
optimization เนี่ยมันทำไปสักพักแล้ว

00:00:35.200 --> 00:00:39.700
แล้วบางข้อมูลเนี่ยมันอาจจะ outdated เรื่องผลลัพธ์

00:00:40.200 --> 00:00:44.100
ซึ่งโดยรวมแล้ววิธีการ เทคนิคต่างๆ ที่ใช้เนี่ย

00:00:44.100 --> 00:00:46.200
ผมคิดว่ามันยัง valid แล้วก็สามารถช่วย

00:00:47.200 --> 00:00:48.500
ประสบการณ์ผู้ใช้ได้ดีขึ้นได้อยู่

00:00:48.900 --> 00:00:50.500
ก็แค่เป็น disclaimer ไว้ก่อนนะครับ

00:00:52.200 --> 00:00:56.100
อย่างที่ทุกคนรู้นะครับว่าการ optimize เนี่ย

00:00:57.400 --> 00:01:00.100
มันเป็นรอบๆ ครับ ก็คือเราทำไปเรื่อย

00:01:00.100 --> 00:01:03.900
เรามี feature ใหม่ มีอะไรเพิ่มเข้ามา มี library ใหม่

00:01:04.400 --> 00:01:09.200
เว็บเราก็ช้าลง เราก็ต้อง optimize เป็นรอบๆ ไป

00:01:09.400 --> 00:01:11.400
หรือถ้าดีหน่อยเราก็มี regression test

00:01:11.900 --> 00:01:15.700
แล้วก็เราได้เห็นปัญหาที่เกิดขึ้นเวลาเราเพิ่ม feature ครับ

00:01:15.900 --> 00:01:19.600
ก็อันนี้ก็เป็น cycle เหมือนกันที่เกิดขึ้นที่ผมได้ทำเข้าไปนะครับ

00:01:19.800 --> 00:01:23.700
ก็คือ optimize แล้วปุ๊บ มี feature ใหม่ ก็ค่อย optimize นะครับ

00:01:25.100 --> 00:01:29.800
ซึ่ง agenda วันนี้นะครับ ก็จะมีเท้าความ 9 เดือนที่แล้วนะครับ

00:01:29.800 --> 00:01:35.200
นิดหน่อย ไม่เป็นไร สไลด์เดียว แล้วก็จะมีเรื่องเมตริกซ์

00:01:37.500 --> 00:01:42.000
ของ web vitals นิดหน่อยนะครับ แล้วก็เครื่องมือที่ใช้

00:01:42.500 --> 00:01:46.700
ในการวัดผล optimize solution ต่างๆ แล้วก็ผลลัพธ์

00:01:46.900 --> 00:01:49.600
แล้วก็มี road map ในอนาคตที่ตั้งใจจะทำด้วย

00:01:50.500 --> 00:01:54.000
จุดเริ่มต้นนะครับ 9 เดือนที่แล้ว ผมมี report มา

00:01:54.500 --> 00:01:59.400
จากทีม product ครับว่าคะแนนไม่ดีส่วนหนึ่ง

00:01:59.500 --> 00:02:02.300
แล้วก็เวลาที่เมตริกซ์ที่ได้จาก web vitals เนี่ย

00:02:02.400 --> 00:02:08.200
ก็ไม่ค่อยดีเท่าไหร่ ก็เลยเกิดกระบวนการ optimize นี้ขึ้นนะครับ

00:02:08.700 --> 00:02:15.600
ผมก็เลยลองใช้ Lighthouse วัดนะครับ ก็คะแนนไม่ค่อยดีครับ

00:02:17.000 --> 00:02:20.300
ซึ่งมันมี research จาก Google อยู่นะครับว่า

00:02:21.300 --> 00:02:24.100
ยิ่งเว็บเราช้าเนี่ย คนก็จะ drop ออกไป

00:02:24.800 --> 00:02:29.500
เราก็ต้องแก้ปัญหานี้เพื่อให้คนไม่ drop ออกจาก funnel นะครับ

00:02:30.300 --> 00:02:33.400
เราก็ challenge accepted ครับ ผมพร้อมจะ optimize ละ

00:02:33.600 --> 00:02:35.500
หลังจากที่เพิ่ม feature มามากมาย

00:02:36.700 --> 00:02:38.900
ก็เริ่มต้นที่เมตริกซ์เบื้องต้นก่อนนะครับ

00:02:39.200 --> 00:02:42.300
ซึ่งผมสนใจเมตริกซ์ตัวนึงเป็นหลักนะครับ ซึ่งก็คือ LCP

00:02:42.500 --> 00:02:46.200
LCP เนี่ยเป็น Largest Contentful Paint นะครับ

00:02:46.600 --> 00:02:49.600
เป็นใช้เวลาเท่าไหร่ในการที่จะ render เห็น content

00:02:49.600 --> 00:02:53.900
ที่ใหญ่ที่สุดของหน้านะครับ ซึ่งอาจจะเป็นรูปหรือเป็นข้อความก็ได้

00:02:54.100 --> 00:02:59.000
ซึ่งเค้าก็มีตัวเลขที่ดีอยู่นะครับ ก็คือประมาณดีก็คือน้อยกว่า 2.5 นะครับ

00:03:01.700 --> 00:03:08.400
อันนี้ก็เป็นตัวอย่างตัวเมตริกนะครับ ถ้า FCP เนี่ย จะเห็นแค่

00:03:08.600 --> 00:03:10.300
ข้อความแรกนะครับ ซึ่งมันก็ไม่ได้ meaningful มาก

00:03:10.500 --> 00:03:13.500
สิ่งที่ meaningful ผมมองว่าเป็น LCP นะครับ

00:03:14.300 --> 00:03:15.100
ซึ่งก็คือ Largest Contentful Paint

00:03:15.200 --> 00:03:17.400
ก็คือจะเห็นว่า user เห็น content ทั้งหลายแล้ว

00:03:17.600 --> 00:03:19.800
เหมือนพร้อมเว็บเราพร้อมที่จะใช้งานจริงๆ แล้ว

00:03:21.800 --> 00:03:25.700
แล้วก็พูดถึงเครื่องมือในการวัดผลแล้วก็ตรวจสอบนะครับ

00:03:25.800 --> 00:03:28.800
แล้วก็มี Google Chrome DevTools ครับที่ใช้วัดผล

00:03:29.000 --> 00:03:32.400
เราจะเห็น performance ต่างๆ นะครับ

00:03:33.000 --> 00:03:35.600
แล้วก็มีตัว Lighthouse ที่อยู่ใน Google Chrome DevTools เอง

00:03:36.000 --> 00:03:39.200
ที่บอก score แล้วก็บอกปัญหาต่างๆ ที่เกิดขึ้นจากเว็บเราด้วย

00:03:40.100 --> 00:03:43.300
อันนี้ก็เป็นตัวอย่างหน้าตา Lighthouse นะครับ

00:03:45.900 --> 00:03:51.000
ซึ่งผมมีคำแนะนำนึงครับ ก็คือเวลาเราใช้ Lighthouse วัด score เนี่ย

00:03:51.100 --> 00:03:54.700
เราควรจะใช้ Google Chrome Canary ในการวัดครับ

00:03:54.800 --> 00:03:56.200
เราจะได้ Lighthouse version ล่าสุด

00:03:56.600 --> 00:04:03.000
แล้วก็จะได้คะแนนที่ version ล่าสุดกว่า version stable นะครับ

00:04:04.100 --> 00:04:06.300
แล้วก็มีอีกตัวนะครับ เป็น PageSpeed Insights

00:04:06.700 --> 00:04:10.700
ซึ่งก็ใช้ Lighthouse วัดเหมือนกัน แต่ก็คือ server ตัวที่วัดเนี่ย

00:04:10.700 --> 00:04:14.600
อาจจะไม่ได้อยู่ที่ไทย แต่อยู่ที่อเมริกาในการไป call เว็บเรานะครับ

00:04:14.900 --> 00:04:18.700
ก็อาจจะมี implication ไม่เหมือนกับเว็บที่ไทยเนาะ

00:04:18.900 --> 00:04:21.600
เพราะว่า user จริงมันไม่ได้อยู่ ถ้าเว็บเราเป็นเว็บไทย

00:04:21.900 --> 00:04:23.200
แล้วเค้าใช้ เราใช้ Lighthouse วัดเนี่ย

00:04:23.300 --> 00:04:26.000
อาจจะมี latency ที่มันไม่เหมือนเราเปิดที่ไทย

00:04:27.000 --> 00:04:31.600
แล้วก็มี tool อีกตัวนึงที่ใช้ดูตัว JavaScript ได้นะครับ

00:04:31.600 --> 00:04:35.800
ก็คือ Source Map Explorer ก็สามารถเห็น bundle size ของเรานะครับ

00:04:36.400 --> 00:04:39.500
มัน tool ที่ใกล้เคียงกัน ซึ่งก็คือ Webpack Bundle Analyzer ครับ

00:04:39.800 --> 00:04:42.500
มันดูเรื่อง JavaScript เหมือนกัน

00:04:42.900 --> 00:04:46.700
แต่ถ้าไปดูใน GitHub thread อะไรเงี้ยครับ เค้าบอกว่า

00:04:47.000 --> 00:04:49.300
ตัวเนี้ย จะเป็นตัวที่ Source Map Explorer เนี่ย

00:04:49.700 --> 00:04:53.500
จะเป็นตัวที่แม่นยำมากกว่าตัว Webpack Bundle Analyzer นะครับ

00:04:53.900 --> 00:04:56.300
คือ Webpack Bundle Analyzer เนี่ย เอาไว้ดูคร่าวๆ ได้

00:04:56.400 --> 00:05:00.600
แต่ถ้าเกิดอยากดูเป๊ะๆ เนี่ย อาจจะใช้ตัว Source Map Explorer ดีกว่า

00:05:00.600 --> 00:05:00.600
แล้วก็ไปต่อ

00:05:05.000 --> 00:05:09.600
ครับ วิธีการที่เราจะ improve ตัว FCP หรือ LCP นะครับ

00:05:09.600 --> 00:05:13.300
ส่วนใหญ่ของตัวฝั่ง JavaScript เนี่ย คือวิธีการที่เรา

00:05:13.300 --> 00:05:15.100
ต้องลดขนาดของ bundle size นะครับ

00:05:15.100 --> 00:05:18.300
แล้วเราก็เอาเมตริกพวกนี้มาวัดว่า

00:05:18.300 --> 00:05:20.500
เราสามารถ improve ตัว web performance

00:05:20.500 --> 00:05:24.400
หรือตัว bundle size ในแต่ละโหลด

00:05:24.400 --> 00:05:26.000
ของเราเนี่ย มันลดลงหรือเปล่านะครับ

00:05:26.000 --> 00:05:29.300
โดยวิธี solution นะครับ ที่เราเอาเข้ามาใช้

00:05:29.300 --> 00:05:31.400
อย่างแรกเลยก็คือตัว explicit import

00:05:31.400 --> 00:05:33.500
ตัว explicit import นะครับ คือ

00:05:33.500 --> 00:05:36.100
การที่เราจะพยายามจะ import ไปยัง

00:05:36.100 --> 00:05:38.200
path ที่มันลึกที่สุด เฉพาะ function

00:05:38.200 --> 00:05:42.800
นั้นที่มันใช้ ตัวอย่างของ slide นี้

00:05:42.800 --> 00:05:44.600
นะครับ คือเรามีตัว Headless UI

00:05:44.600 --> 00:05:46.700
ที่เรามาใช้เป็น base component

00:05:46.700 --> 00:05:50.200
เสร็จแล้วตัว Headless UI เนี่ย เราไปดูมาว่า

00:05:50.200 --> 00:05:54.000
ตัวมัน export ตัว index entry ออกมา

00:05:54.000 --> 00:05:57.400
ซึ่งตัว index entry ของมันเนี่ย

00:05:57.400 --> 00:06:00.500
import ทุก component file ข้างใน

00:06:00.500 --> 00:06:03.300
แล้วเวลาเราดึงออกมาใช้แค่ 1 component

00:06:03.300 --> 00:06:05.800
หรือ 2 component มันไปดึงข้างในออกมาหมดเลย

00:06:05.800 --> 00:06:08.900
ทำให้ bundle size ที่เราเอามาใช้กับตัว

00:06:08.900 --> 00:06:11.500
Headless UI React มันมีขนาดค่อนข้างใหญ่

00:06:11.500 --> 00:06:14.400
วิธีที่เราใช้นะครับ ก็คือ explicit import

00:06:14.400 --> 00:06:17.300
ซึ่งในเคสนี้เรา explicit import ไปที่ตัว

00:06:17.300 --> 00:06:19.900
node module หรือ path ของมันตรงๆ เลย

00:06:19.900 --> 00:06:22.800
มันก็จะช่วยให้ลด bundle size ของมัน

00:06:22.800 --> 00:06:27.000
แล้วก็เอาตัว component เฉพาะที่เราต้องการใช้ออกมา

00:06:27.000 --> 00:06:31.700
ตัว library อื่นก็จะมีเหมือนกัน อย่างบาง library

00:06:31.700 --> 00:06:34.800
อย่างเช่น ตัว React-use มันก็จะมีตัว ES module

00:06:34.800 --> 00:06:38.900
ซึ่งสามารถเจาะ path เข้าไปใน specific path

00:06:38.900 --> 00:06:44.200
อย่างเคสของเราก็คือ import ตัว useCopyToClipboard

00:06:44.200 --> 00:06:48.000
แล้วก็ useNetworkState ที่เป็น explicit import เข้ามานะครับ

00:06:48.000 --> 00:06:52.100
อีกเคสหนึ่งที่เรา improve ตรงนี้เข้ามาเหมือนกัน

00:06:52.100 --> 00:06:56.700
คือ iMask เราใช้ตัว iMask ในการ mask พวก text field input

00:06:56.700 --> 00:07:00.500
ไม่ว่าจะเป็น phone number หรือตัว debit card อะไรพวกนี้

00:07:00.500 --> 00:07:05.000
เราก็จะมีการ improve ก็คือ เอา import เข้ามาตรงๆ เหมือนกัน

00:07:05.000 --> 00:07:12.600
มีการใช้ Braze web SDK นะครับ ของเราใช้ web Braze SDK

00:07:12.600 --> 00:07:18.900
ในการ push user notification ในการที่ user subscribe ตัว SMS

00:07:18.900 --> 00:07:22.600
พอเรา improve ตรงนี้เนี่ย เราก็ลด bundle size ไปได้เหมือนกัน

00:07:22.600 --> 00:07:28.000
ก็จะมีนิดนึงนะครับ ในกรณีที่เราเปลี่ยน path

00:07:28.000 --> 00:07:32.100
หรือไม่ได้ import จาก path ที่มันเป็น path ปกติเนี่ย

00:07:32.100 --> 00:07:34.800
มันอาจจะมีปัญหาเรื่อง auto complete

00:07:34.800 --> 00:07:37.400
ซึ่งเราอาจจะต้องมา weight กันว่า

00:07:37.400 --> 00:07:39.200
ระหว่างเรื่องของการทำ performance

00:07:39.200 --> 00:07:42.500
กับเรื่องของการที่เราจะมี DX ที่ดี

00:07:44.700 --> 00:07:46.100
developer experience ที่ดีเนี่ย

00:07:47.000 --> 00:07:48.200
มี trade-off กันยังไง

00:07:48.600 --> 00:07:50.100
อย่างในเคสนี้เราก็ต้องมานั่ง

00:07:50.100 --> 00:07:52.200
เขียนตัว module mapper เพิ่มใน

00:07:52.200 --> 00:07:53.400
unit test ของเรานะครับ

00:07:53.500 --> 00:07:55.700
ก็คือเราต้อง map ตัว react-use

00:07:55.700 --> 00:07:57.100
กับตัว headless-ui

00:07:57.300 --> 00:07:59.800
ที่เป็น explicit import เข้ากับ

00:07:59.800 --> 00:08:01.400
ตัว import ปกตินะครับ

00:08:04.000 --> 00:08:05.200
อันนี้ก็จะเป็นตัวอย่างของ

00:08:05.200 --> 00:08:08.300
ตัว Braze SDK ที่เรา improve ไป

00:08:08.300 --> 00:08:10.600
เมื่อกี้นะครับ เราลด bundle size

00:08:10.600 --> 00:08:11.900
จาก 205 KB

00:08:12.600 --> 00:08:13.900
เหลือ 85 KB

00:08:14.100 --> 00:08:15.700
เพราะเรา import แค่ฟังก์ชัน

00:08:15.700 --> 00:08:17.300
ที่เราใช้เท่านั้น ไม่ได้ import

00:08:17.300 --> 00:08:19.500
จากตัว index entry file ของมัน

00:08:22.000 --> 00:08:23.200
ก็อันนี้เป็น lesson learned

00:08:23.200 --> 00:08:25.100
นะครับ ของเราก็คือ เวลาที่

00:08:25.100 --> 00:08:26.900
เราจะดึง library เข้ามาใช้เนี่ย

00:08:26.900 --> 00:08:29.200
หรือว่าเราจะดู library ไหน

00:08:29.200 --> 00:08:31.700
และเราจะเข้าไปศึกษา library

00:08:31.700 --> 00:08:33.500
นั้นว่า library นั้น

00:08:33.500 --> 00:08:35.200
เขา export index entry js ออกมา

00:08:35.200 --> 00:08:38.100
และข้างในมันน่ะ

00:08:38.100 --> 00:08:40.000
ไป import ตัว component ทุก

00:08:40.000 --> 00:08:42.400
ไฟล์หรือเปล่า หรือเราสามารถ

00:08:42.400 --> 00:08:43.200
มี explicit import ที่เข้าไป

00:08:43.200 --> 00:08:43.900
ใช้ได้เหมือนกันครับ

00:08:46.000 --> 00:08:48.300
อีก use case นึงที่เรา

00:08:48.300 --> 00:08:50.200
มีการ improve นะครับ ก็คือ

00:08:50.200 --> 00:08:51.800
เราแก้ library ต่างๆ ที่เรามาใช้

00:08:51.800 --> 00:08:54.400
ก็จะมีหลายๆ library ด้วยกัน

00:08:54.400 --> 00:08:56.500
ที่เราจำเป็นต้องใช้ อย่างเช่น

00:08:56.500 --> 00:08:58.300
พวก react-hot-toast หรือว่า

00:08:58.300 --> 00:09:01.400
ตัว datadog monitoring ซึ่ง

00:09:01.400 --> 00:09:04.200
ในเคสนี้เราก็เป็น RUM

00:09:04.200 --> 00:09:05.400
หลายๆ ตัวมันก็จะมีตัว

00:09:05.400 --> 00:09:08.000
javascript bundle size ที่

00:09:08.000 --> 00:09:10.000
ค่อนข้างใหญ่ เรา

00:09:10.000 --> 00:09:11.700
ก็จะพยายามดูว่า library

00:09:11.700 --> 00:09:13.500
ต่างๆ พวกเนี่ย มันสามารถ

00:09:13.500 --> 00:09:14.500
ลดขนาดของ bundle size

00:09:14.500 --> 00:09:16.000
ที่เราดึงมาใช้ได้หรือเปล่า

00:09:17.900 --> 00:09:19.600
อันนี้เป็นตัวอย่างของตัว

00:09:19.600 --> 00:09:20.500
react-hot-toast นะครับ

00:09:22.000 --> 00:09:23.700
เบื้องหลังการทำงานของมัน

00:09:23.700 --> 00:09:25.100
ก็คือตัว CSS in JS

00:09:26.000 --> 00:09:29.000
มันเอาตัว CSS เนี่ย ไปแปะไว้

00:09:29.000 --> 00:09:31.200
ใน javascript แล้วก็จังหวะ

00:09:31.200 --> 00:09:32.700
ที่เราโหลดครั้งแรกอ่ะ มันจะ

00:09:32.700 --> 00:09:33.600
ทำให้จังหวะที่เรา parse

00:09:33.600 --> 00:09:35.500
javascript มันนานขึ้น เพราะว่า

00:09:35.500 --> 00:09:36.000
bundle size มันใหญ่ขึ้น

00:09:36.800 --> 00:09:39.100
วิธีที่เราแก้ก็คือ เราใช้

00:09:39.100 --> 00:09:41.500
ตัว headless mode ของตัว

00:09:41.500 --> 00:09:45.100
react-hot-toast นะครับ

00:09:45.100 --> 00:09:47.200
ก็คือ ตัว headless เนี่ย จะ

00:09:47.200 --> 00:09:49.400
ไม่ได้มีการแปะ style ไว้ใน

00:09:49.400 --> 00:09:51.400
first time load แต่เราจะเอา

00:09:51.400 --> 00:09:52.700
style เนี่ย ไปแปะไว้ใน

00:09:52.700 --> 00:09:54.800
runtime แทน ซึ่งเราก็จะมีการ

00:09:54.800 --> 00:09:56.400
เขียน style ที่แปะเข้าไป

00:09:56.400 --> 00:09:58.400
ในโค้ดของเรานะครับ

00:10:01.100 --> 00:10:03.100
แล้วก็ตัว Datadog เนี่ย

00:10:03.900 --> 00:10:06.500
ที่เราดึงมาใช้เพราะว่า

00:10:07.000 --> 00:10:09.000
มันต้องมีการทำ user monitoring

00:10:09.100 --> 00:10:11.200
เราจะต้องมีการเก็บ log ต้องดู

00:10:12.000 --> 00:10:13.700
log ของ user ว่า user คลิก

00:10:13.800 --> 00:10:16.400
แล้วได้ flow ตามที่เราต้องการ

00:10:16.500 --> 00:10:19.400
หรือเปล่า ก็จะมีการ monitoring พวกนี้

00:10:20.000 --> 00:10:22.600
ซึ่งขนาดของ Datadog RUM ก็จะมีขนาด

00:10:22.900 --> 00:10:25.000
ใหญ่ถึง 151.7 KB ในเคสนี้

00:10:26.100 --> 00:10:28.600
แล้วก็มีการเข้าไปดู library ว่า

00:10:29.000 --> 00:10:30.700
ตัว library เนี่ย มันสามารถมี

00:10:30.800 --> 00:10:31.700
ขนาดที่มันเล็กลงได้หรือเปล่า

00:10:32.100 --> 00:10:34.700
อย่างตัวเราไปดู library ที่เป็น

00:10:34.900 --> 00:10:36.400
เพื่อนบ้าน ก็คือ Datadog เหมือนกัน

00:10:36.500 --> 00:10:37.800
ที่เป็น browser RUM slim

00:10:38.300 --> 00:10:40.800
ซึ่งมันเป็น library ที่

00:10:41.200 --> 00:10:43.100
อาจจะมี feature ไม่เท่าของเดิม

00:10:43.200 --> 00:10:45.300
แต่ว่ามี feature เพียงพอเท่าที่เราใช้

00:10:45.300 --> 00:10:47.300
งาน ก็มีขนาดเล็กลงเหมือนกัน

00:10:49.800 --> 00:10:51.900
ครับ และตัวอย่างของอันนี้ก็คือ

00:10:52.300 --> 00:10:54.200
react-hot-toast ที่เราเปลี่ยนจาก

00:10:54.500 --> 00:10:56.200
การใช้ import ปกติ

00:10:56.900 --> 00:10:58.900
ไปเป็นการ import แบบ headless UI

00:10:59.900 --> 00:11:02.200
แล้วก็ตัว style ที่เราต้อง

00:11:02.600 --> 00:11:04.800
เขียนเนี่ย แล้วก็เอามาเขียนใน

00:11:05.000 --> 00:11:05.800
runtime แทนนะครับ

00:11:08.600 --> 00:11:10.500
แล้วก็อีกเทคนิคหนึ่งที่เรา

00:11:11.100 --> 00:11:13.800
ใช้ค่อนข้างเยอะเลย ก็คือการทำ lazy loading

00:11:14.200 --> 00:11:15.500
การทำ lazy loading ใน React เนี่ย

00:11:15.600 --> 00:11:17.000
ก็คือเป็นการบอกว่า

00:11:17.600 --> 00:11:20.700
เราจะโหลด resource เฉพาะที่เราต้อง

00:11:20.800 --> 00:11:22.800
ใช้งานในหน้านั้นๆ หรือว่าใน path

00:11:22.800 --> 00:11:25.600
นั้นๆ นั้นเอง ซึ่งเบื้องหลังของการทำงาน

00:11:26.100 --> 00:11:28.300
มันคือการที่ React ไป lazy แล้วก็

00:11:28.600 --> 00:11:30.000
ตัว webpack หรือตัว bundler

00:11:30.300 --> 00:11:35.400
จะรู้ตัวเองว่า path ที่เราต้องโหลดเนี่ย

00:11:36.100 --> 00:11:38.700
เป็น asynchronous dynamic import

00:11:40.400 --> 00:11:43.300
ซึ่งการทำงานของตัว dynamic import เนี่ย

00:11:44.100 --> 00:11:48.000
มันก็จะ work กับตัว suspense ของ

00:11:48.100 --> 00:11:49.500
React ที่เรา import เข้ามา

00:11:49.600 --> 00:11:52.200
นะครับ ก็ช่วยลด bundle size แล้วก็

00:11:52.300 --> 00:11:55.700
มีการแตก chunk ก็คือเป็นการทำ code splitting

00:11:56.100 --> 00:11:58.300
ยกตัวอย่างเช่น เรามีหน้า 10 หน้า

00:11:59.500 --> 00:12:02.200
เราไม่จำเป็นต้องโหลดทั้ง 10 หน้า

00:12:02.700 --> 00:12:04.700
มาพร้อมกัน ในจังหวะแรก เราสามารถโหลด

00:12:04.700 --> 00:12:06.800
มาเฉพาะแค่หน้าแรกก่อน แล้วเรา

00:12:06.800 --> 00:12:08.200
ค่อยๆ โหลดหน้าที่เหลือเอามา

00:12:08.200 --> 00:12:09.600
เวลาที่ user เล่นทีละ flow นะครับ

00:12:11.200 --> 00:12:13.200
ก็จะมีการ optimize หลายแบบ

00:12:13.600 --> 00:12:16.800
พาร์ทของเมื่อกี้ก็คือเป็น first-party script

00:12:16.800 --> 00:12:18.300
ที่เราสามารถ control ได้

00:12:18.300 --> 00:12:20.700
แล้วก็ยังมีตัว third-party script เหมือนกัน

00:12:20.700 --> 00:12:24.500
อย่างพาร์ทนี้ก็คือเรามีตัว lazy with retry นะครับ

00:12:25.000 --> 00:12:27.200
อันนี้เป็น on top function ของเรา

00:12:28.100 --> 00:12:33.000
เพราะว่าเราเขียนตัว function เพื่อให้มัน retry

00:12:33.000 --> 00:12:35.200
เวลาที่เราโหลด dynamic import เข้ามาอีกที

00:12:36.400 --> 00:12:41.100
อย่างนี้เป็นการทำ dynamic import ใน level route

00:12:41.400 --> 00:12:44.300
ซึ่งเราสามารถ split code เป็นแบบหลาย level ได้

00:12:44.300 --> 00:12:47.400
ไม่ว่าจะเป็นการทำ level routing หรือว่าการทำ level component

00:12:48.000 --> 00:12:52.300
อย่างตัวอย่างของอันนี้ก็คือเราทำ download earn in dialog

00:12:52.600 --> 00:12:57.100
โดยใช้ท่าปกติก็คือ lazy แล้วก็ import ตัวผ่านนั้นเข้ามา

00:12:57.100 --> 00:13:00.600
webpack ก็จะรู้ว่าตัว import ตรงนี้เป็น dynamic import

00:13:00.600 --> 00:13:02.300
แล้วก็เราเอามา work กับ suspense

00:13:02.500 --> 00:13:05.300
เวลาที่ user เปิดตัว dialog ขึ้นมา

00:13:06.000 --> 00:13:08.400
ก็จะมีการโหลดตัว component นี้เข้ามาครับ

00:13:08.800 --> 00:13:11.300
ก็ช่วยให้เราลด bundle size ไปได้เยอะมาก

00:13:13.000 --> 00:13:15.000
นอกจาก first-party script แล้ว

00:13:15.000 --> 00:13:17.400
เรายังมีตัว third-party script อยู่เหมือนกัน

00:13:17.900 --> 00:13:21.400
ตัว third-party script ไม่ว่าจะเป็นเรื่องของการทำ analytics

00:13:21.800 --> 00:13:24.700
การวัด metrics ต่างๆ หรือการทำ A/B testing

00:13:26.000 --> 00:13:29.900
บางแอปอาจจะต้องมี A/B testing ต้องมี feature flag เปิดปิด

00:13:29.900 --> 00:13:34.200
หรือว่าต้องมีการโชว์ date formatting นะครับ

00:13:34.600 --> 00:13:36.600
หรือการทำ animation ก็เหมือนกัน

00:13:38.100 --> 00:13:40.900
ซึ่งวิธีการ control first-party lazy loading

00:13:40.900 --> 00:13:45.200
กับ third-party lazy loading ก็จะต่างกันเหมือนกันครับ

00:13:45.200 --> 00:13:50.200
อย่างตัว third-party lazy load เนี่ย ที่เราเอามาใช้ก็คือเรามี Optimizely

00:13:50.200 --> 00:13:53.100
ในการทำพวก experiment ทำ feature flag

00:13:53.100 --> 00:13:56.500
ตัว segment เราทำ analytics เสร็จแล้วตัว segment เนี่ย

00:13:56.500 --> 00:13:59.500
มันก็จะไปดึง third-party อีกที

00:13:59.700 --> 00:14:03.800
ซึ่งตัว segment ก็จะไปดึงพวก Facebook Pixel ดึง Google Ads

00:14:04.200 --> 00:14:07.000
หรือเราก็จะมีตัว Datadog ที่มีไซส์ค่อนข้างใหญ่

00:14:07.200 --> 00:14:10.300
แล้วมีพวกกันบอทก็คือ Turnstile reCAPTCHA

00:14:10.500 --> 00:14:16.300
มี Google Tag Manager ที่ไปดึง TikTok analytics ไปดึง Hotjar เข้าไปอีก

00:14:16.900 --> 00:14:21.400
ซึ่งวิธีที่เราใช้นะครับเราก็ lazy load ตัว segment

00:14:21.400 --> 00:14:24.100
แล้วก็เพื่อนของมัน

00:14:26.200 --> 00:14:28.000
แล้วก็มีการใส่ flag ในการโหลดของ segment เข้าไป

00:14:29.200 --> 00:14:32.800
อย่างตัว library บางตัวเนี่ย มันจะสามารถมาโหลดทีหลัง

00:14:32.800 --> 00:14:35.300
เขาจะไม่ได้ init ครั้งแรกตอน import

00:14:35.300 --> 00:14:38.600
แต่เขาจะมี function ในการโหลดทีหลังได้

00:14:38.600 --> 00:14:42.000
แล้วก็ใส่พวก lazy ใส่เข้า hooks ของเรา

00:14:42.000 --> 00:14:46.600
หรือว่าใส่พวก function ต่างๆ ที่เราเอามาโหลดเมื่อเราต้องใช้งานนะครับ

00:14:49.100 --> 00:14:51.900
แล้วเราก็จะมีการโหลดพวก recaptcha

00:14:52.500 --> 00:14:55.300
เพื่อให้มันโหลดเร็วขึ้นใน first time โหลดของเราครับ

00:14:57.900 --> 00:15:00.500
แล้วก็มาถึงพระเอกของเรานะครับ

00:15:01.000 --> 00:15:05.000
ตัว Partytown อันนี้ก็จะเป็น library อีกตัวนึงที่ทำจาก builder.io

00:15:05.400 --> 00:15:09.800
ซึ่ง Partytown จะช่วย optimize ตัวเว็บโหลด

00:15:10.200 --> 00:15:13.100
เปลี่ยนจาก main thread ไปใช้ใน web worker แทน

00:15:13.300 --> 00:15:16.900
อันนี้เดี๋ยวจะเป็นเซสชั่นที่พี่เจมส์จะ cover ตรงส่วนนี้ต่อนะครับ

00:15:18.900 --> 00:15:22.100
ครับ Partytown นะครับ เป็น tool ของ builder.io

00:15:22.500 --> 00:15:27.200
ก็ on production แล้ว แล้วก็เจ็บนิดหน่อยด้วยวันนี้

00:15:29.000 --> 00:15:32.800
Partytown นะครับ เป็นสิ่งที่มันทำนะครับ

00:15:33.000 --> 00:15:37.200
ก็คือมันพยายามถ้าเราเอา script third party ของเราเนี่ย

00:15:38.000 --> 00:15:39.300
ไป wrap ด้วย Partytown

00:15:39.400 --> 00:15:43.000
มัน script third party เราอาจจะไปอยู่อีก thread นึง

00:15:43.300 --> 00:15:45.000
ซึ่งก็คือ web worker thread

00:15:45.400 --> 00:15:47.800
ซึ่งจะทำให้ main thread เราฟรีขึ้น

00:15:48.100 --> 00:15:52.600
ให้สามารถ render ตัว first party ของเราหรือโค้ด react ของเรานะครับ

00:15:52.800 --> 00:15:55.300
ที่ทำให้ render หน้าของเราได้เร็วขึ้น

00:15:55.900 --> 00:15:58.600
เพราะว่าถ้าเกิดเราไม่มี Partytown เนี่ย

00:15:59.100 --> 00:16:02.000
ทั้งโค้ด first party เรา และ third party เราจะอยู่ใน thread เดียวกัน

00:16:02.300 --> 00:16:06.200
ทำให้มัน block ตัว parsing JavaScript นะครับ

00:16:06.300 --> 00:16:08.400
เราจะต้องรอ third party run ด้วย

00:16:08.800 --> 00:16:12.000
ทำให้กว่าที่เราจะได้หน้าที่ render ขึ้นมาเนี่ย

00:16:12.100 --> 00:16:14.900
ไม่ว่าจะเป็นตัว FCP หรือ LCP เนี่ย มันช้าลง

00:16:15.300 --> 00:16:19.900
Partytown ก็จะมาแก้ปัญหานี้ก็คือ
แยกส่วนของเราออกจากกันให้ชัดเจนนะครับ

00:16:20.300 --> 00:16:24.100
ซึ่งมันก็มี mechanism บางอย่างที่มันใช้คุยกันระหว่าง thread

00:16:24.600 --> 00:16:27.100
แล้วเดี๋ยวผมเล่าต่อนะครับ

00:16:27.700 --> 00:16:30.300
ก็มันจะมีตัว main thread นะครับ

00:16:30.600 --> 00:16:32.700
ก็เป็น thread หลักที่เราใช้ run ตัวหน้าเว็บของเรา

00:16:33.000 --> 00:16:38.800
แล้วก็มีตัว service worker ที่เอาไว้คุยกัน
ผ่านกันระหว่าง worker thread นะครับ

00:16:39.000 --> 00:16:46.000
ซึ่งตรงนี้เนี่ย ก็ต้องมี service worker เป็นตัวกลางที่คอยคุยนะครับ

00:16:46.000 --> 00:16:50.100
แล้วอันนี้เป็นโค้ดตัวอย่างนะครับ ที่เราใช้ตัว Partytown ครับ

00:16:50.100 --> 00:16:53.200
ก็คือมันจะมี use case third party บางตัวเนี่ย

00:16:53.700 --> 00:16:55.600
ไม่อนุญาต call หรือ cross origin นะครับ

00:16:55.800 --> 00:17:00.300
ซึ่งเราต้องเขียน script เพื่อทำการ proxy ตัว third party

00:17:00.800 --> 00:17:04.700
บางตัวที่เขาไม่อนุญาต call มัน

00:17:05.000 --> 00:17:09.000
ก็จะมีบางตัวเช่น TikTok อะไรอย่างเงี้ย

00:17:09.300 --> 00:17:13.800
ที่ไม่อนุญาต cross origin เราก็ต้องทำ proxy บางอย่าง

00:17:14.100 --> 00:17:16.800
ที่ให้ไป call ผ่าน proxy เราก่อน

00:17:17.000 --> 00:17:21.700
แล้วก็ proxy เราไปคุยกับตัว third party javascript ไฟล์นะครับ

00:17:21.800 --> 00:17:24.300
ก็นี่ก็เป็นตัวอย่างปัญหาที่เกิดขึ้นตอนทำขึ้นมาจริง

00:17:24.600 --> 00:17:29.300
ซึ่งเราใช้ตัว edge function ของ Netlify นะครับ เป็นตัวทำ proxy

00:17:31.300 --> 00:17:34.700
ซึ่งอันนี้ก็เป็นตัวอย่าง request นะครับ ที่ใช้

00:17:34.700 --> 00:17:36.400
proxy ตัว

00:17:36.400 --> 00:17:38.800
netlify function นะครับ เพื่อไป

00:17:38.800 --> 00:17:40.400
ขอ javascript file ของ third-party

00:17:40.400 --> 00:17:42.300
นั้น มันจะเป็น analytics

00:17:42.300 --> 00:17:45.400
ของ TikTok นะครับ หรือว่าตัว

00:17:45.400 --> 00:17:46.900
bat.bing นะครับ

00:17:46.900 --> 00:17:50.100
ที่ third-party เราที่เราใช้นะครับ

00:17:50.100 --> 00:17:54.700
ซึ่งพอเราทำทุกอย่าง

00:17:54.700 --> 00:17:57.100
ที่พูดมานะครับ รวมกันแล้วเนี่ย ก็

00:17:57.100 --> 00:17:58.900
ผลลัพธ์ อันนี้เป็นกราฟ

00:17:58.900 --> 00:18:00.900
ที่อยู่ใน real user monitoring

00:18:00.900 --> 00:18:02.100
ของ Datadog นะครับ

00:18:02.100 --> 00:18:04.100
ก็ได้เวลา

00:18:04.100 --> 00:18:05.800
ถ้าเราทำไป

00:18:05.800 --> 00:18:08.400
2 หน้าเป็นหลัก ทำทั้ง

00:18:08.400 --> 00:18:10.700
หลายอย่างในทุกหน้า แล้วก็ทำตัว

00:18:10.700 --> 00:18:12.300
เรซที่สูง ตัว 2 หน้าเป็นหลัก

00:18:12.300 --> 00:18:13.700
ที่เราวัดที่สนใจนะครับ ก็คือหน้า

00:18:13.700 --> 00:18:15.100
login page กับหน้า questionnaire

00:18:15.100 --> 00:18:16.300
เราได้เวลา

00:18:16.300 --> 00:18:19.000
จากประมาณ 4 วินาที

00:18:19.000 --> 00:18:20.700
หรือ 3 วินาที ก็คือได้มา

00:18:20.700 --> 00:18:24.000
1 วินาที ซึ่งผมว่าก็ดี

00:18:24.000 --> 00:18:28.100
ดีระดับนึง แต่คิดว่ามี

00:18:28.100 --> 00:18:30.900
ส่วนที่ improve ได้มากกว่านี้

00:18:30.900 --> 00:18:34.200
ก็ lighthouse ตัว 11.5 ใน

00:18:34.200 --> 00:18:36.000
Google Chrome Canary ก็

00:18:36.000 --> 00:18:37.100
ได้คะแนนเขียวมา

00:18:37.100 --> 00:18:39.400
แต่ผมสนใจตัวเวลา

00:18:39.400 --> 00:18:41.400
ซะมากกว่า เพราะตอนนี้

00:18:41.400 --> 00:18:43.400
web app ของเราเนี่ย ไม่ได้มี

00:18:43.400 --> 00:18:47.000
requirement เรื่อง SEO อะไร เพราะมันเป็น

00:18:47.000 --> 00:18:50.600
point หลักคือหลัง login flow ครับ business flow

00:18:50.600 --> 00:18:52.800
มันคือหลัง login แล้วก็ตัว

00:18:52.800 --> 00:18:53.900
หรือ register

00:18:53.900 --> 00:18:54.800
ก็เลยสนใจเรื่องเวลา

00:18:54.800 --> 00:18:55.400
ซะมากกว่า

00:18:55.400 --> 00:18:58.800
ซึ่งมันมีส่วนที่ improvement

00:18:58.800 --> 00:19:00.300
เพิ่มได้นะครับ แล้วก็เรา

00:19:00.300 --> 00:19:00.700
ก็ทำไปบ้างแล้วด้วย

00:19:00.700 --> 00:19:01.900
มีทีมเราทำ

00:19:01.900 --> 00:19:03.800
ก็ตัว Partytown ครับ มัน

00:19:03.800 --> 00:19:05.000
มีอีกโหมดนึง

00:19:05.000 --> 00:19:07.200
ซึ่งก็คือใช้ตัว Atomic หรือว่า

00:19:07.200 --> 00:19:09.900
shared buffer ซึ่งเป็น

00:19:09.900 --> 00:19:12.800
feature browser นึงแล้วกัน ที่

00:19:12.800 --> 00:19:15.900
ทำให้มันคุยกัน ระหว่าง worker

00:19:15.900 --> 00:19:17.000
thread กับ main thread โดยไม่ผ่าน

00:19:17.000 --> 00:19:18.100
service worker ได้นะ ทำให้มันเร็ว

00:19:18.100 --> 00:19:19.800
ขึ้น เขาเคลมว่า 10 เท่า

00:19:19.800 --> 00:19:22.100
แต่เรามีปัญหาอยู่อย่างนึงว่า

00:19:22.100 --> 00:19:23.000
มันต้องไป config

00:19:23.000 --> 00:19:25.800
ตัว COOP ครับ

00:19:25.800 --> 00:19:28.100
ตัว header เพื่อเป็นการบอก

00:19:28.100 --> 00:19:28.600
browser ว่า

00:19:28.600 --> 00:19:30.200
เรื่อง

00:19:30.200 --> 00:19:32.600
ถ้าทุกคนเคยจำได้ มันเคยมี

00:19:32.600 --> 00:19:34.300
ปัญหาเรื่อง Spectre hack

00:19:34.300 --> 00:19:37.300
เกิดขึ้น ก็คือ CPU มัน

00:19:37.300 --> 00:19:38.400
โดน เขาเรียกอะไรนะ

00:19:40.900 --> 00:19:45.500
เมื่อนานแล้วมันมีปัญหาเรื่อง security ของ browser ครับ

00:19:45.600 --> 00:19:51.500
แล้วก็ browser ก็เลยออก API ตัว config ระหว่าง thread ได้ว่า

00:19:51.800 --> 00:19:56.000
ไม่ให้สามารถ share ข้อมูลระหว่างกัน ซึ่งการที่จะ config feature อันนี้

00:19:56.600 --> 00:20:05.700
ตัว COOP เนี่ย มันต้องรู้ว่า third party พวก iframe ของหน้าเราเนี่ย

00:20:05.800 --> 00:20:09.300
ต้องถูก config ไปด้วย แต่เรามี iframe บางตัวที่เราใช้

00:20:10.500 --> 00:20:13.300
เป็น third party อีกทีนึงที่เราไม่สามารถไปควบคุมเขาได้

00:20:13.700 --> 00:20:17.000
ทำให้ feature นี้เราไม่สามารถใช้ได้ ก็เลยไม่ได้ใช้โหมด atomic

00:20:17.300 --> 00:20:18.400
ของตัว Partytown ไป

00:20:19.400 --> 00:20:24.000
แล้วก็เราใช้ Datadog real user monitoring เป็นตัวทำ

00:20:24.200 --> 00:20:28.700
real user monitoring นะครับ จริงๆ พยายามลองเอามันไปออกจาก

00:20:29.100 --> 00:20:32.900
main thread เหมือนกัน แต่ก็ไม่ work ก็เลยถอยไป

00:20:33.400 --> 00:20:36.800
แล้วก็มีตัว form library ที่เราใช้ตอนแรกเป็น Zod ครับ

00:20:37.000 --> 00:20:42.500
ซึ่งก็ tree shake ไม่ได้ ก็ไปลองใช้ ValiBot อันนี้เสร็จไปแล้ว

00:20:42.800 --> 00:20:46.000
ทำไปแล้ว มีคนช่วยทำ

00:20:46.100 --> 00:20:51.300
แล้วก็มีอีกปัญหาหนึ่งนะครับ ก็คือเราใช้ module federation

00:20:51.500 --> 00:20:53.500
หรือว่าเทคนิค micro front end ประเภทหนึ่งนะครับ

00:20:53.600 --> 00:20:58.600
ก็มันก็มี limitation บางอย่าง เรื่อง request waterfall problem นะครับ

00:20:58.800 --> 00:21:06.000
ที่มันต้องรอโหลด main.js ก่อน, main.js ไปโหลด micro frontend นึง remote entry แล้ว remote entry ไปโหลด

00:21:06.300 --> 00:21:11.000
javascript ของ micro frontend นั้นน่ะครับ
ก็มีความ waterfall ซึ่งตอนนี้ก็รอ

00:21:13.000 --> 00:21:20.400
feature prefetch ของ module federation
อยู่นะครับ 2.0 เค้าก็เขียนไว้ว่าเดี๋ยวจะมี

00:21:20.700 --> 00:21:23.000
เค้าน่าจะช่วยแก้ปัญหาตัว waterfall problem นี้ได้

00:21:23.900 --> 00:21:27.800
แล้วก็มีตัว จริงๆ เรามีอีกปัญหาหนึ่งก็คือเรื่อง CSS เราด้วย

00:21:28.000 --> 00:21:32.900
เรามี CSS variable ที่ยาวพอสมควร ตัวใหญ่ ก็ทำให้มันโหลดช้า

00:21:33.000 --> 00:21:37.500
เราก็อยากจะได้ inline critical CSS เข้าไปแล้วก็ lazy load CSS อื่นๆ ที่หลัง

00:21:39.700 --> 00:21:46.000
ก็อันนี้ก็เป็นรูปที่ผมว่ามันค่อนข้างจริงนะครับ ก็คือเวลาเรา develop ไปเนี่ย

00:21:46.200 --> 00:21:52.900
ก็ graph ตัวล่างนะครับ ไอ้ตัวข้างบนเนี่ย เป็น framework นี้ที่เค้า

00:21:53.300 --> 00:21:57.500
เคลมว่าทำแล้วก็ไม่ต้องมา optimize ครับ
ซึ่งผมว่ามันน่าจะยังไม่ค่อยจริงเท่าไหร่

00:21:57.600 --> 00:22:01.700
ตอนนี้เราอยู่ framework ล่างนะครับ ก็คือเป็น question mark เนาะ

00:22:01.800 --> 00:22:06.800
เป็น framework ทั่วๆ ไป ก็เวลาเรา
develop อะไรไปเนี่ย feature เราเพิ่มเนาะ

00:22:06.900 --> 00:22:10.400
ทุกอย่างมันเปลี่ยน เราก็ต้อง performance เราก็ลดลงตามเวลา

00:22:10.500 --> 00:22:14.100
แล้วเราก็ต้องมานั่งคอย optimize
มันก็เร็วขึ้นๆ แล้วก็เราเพิ่ม feature อีก

00:22:14.200 --> 00:22:17.900
เราก็ช้าลง หนักลงอีก มันก็จะเกิดเป็น cycle ตัวการ optimize

00:22:18.000 --> 00:22:19.200
อย่างนี้ไปเรื่อยๆ นะครับ

00:22:19.900 --> 00:22:27.000
ก็ slide ของผม มีประมาณนี้ครับ
แล้วทุกคนมีคำถามเพิ่มเติมมั้ยครับ

00:22:33.700 --> 00:22:37.600
เวลาที่พวกฟังก์ชัน เราทำฟังก์ชัน pinning ได้เนาะ

00:22:37.800 --> 00:22:39.700
แต่ว่าเวลาถ้าต้อง develop ต่อไปแล้ว

00:22:39.700 --> 00:22:41.200
มันต้องมีการอัพเดตอย่างเงี้ย แล้วเกิดว่า

00:22:41.200 --> 00:22:42.700
มันเปลี่ยนโครงสร้างในตัวไลบรารี

00:22:43.300 --> 00:22:44.100
เรามีวิธีดีลกับมันยังไง

00:22:45.300 --> 00:22:45.900
ขอ import ครับ

00:22:48.100 --> 00:22:48.600
ตัว import ครับ

00:22:50.300 --> 00:22:52.300
ที่เราใช้เสียงไปดูสไลด์ที่เป็นเรื่อง

00:22:52.300 --> 00:22:53.100
import module

00:22:53.100 --> 00:22:54.200
คือแบบ มัน import เปลี่ยนที่ใช่มั้ยฮะ

00:22:56.000 --> 00:22:56.400
อื้อ

00:22:56.400 --> 00:22:57.400
ใช่ครับ คือถ้าเป็นบน production

00:22:57.400 --> 00:22:58.700
เค้าจะว่ามันมี node lock

00:22:58.700 --> 00:23:00.100
package lock เนาะ อาจจะล็อกได้

00:23:00.600 --> 00:23:02.900
แต่ว่าพอมันเป็นเรื่องของ

00:23:03.300 --> 00:23:04.700
พอมันต้อง develop อย่างเงี้ยครับ

00:23:04.900 --> 00:23:06.300
แล้วมันไม่ต้องการอัพเดตเวอร์ชันตัวนี้ฮะ

00:23:07.700 --> 00:23:09.400
ผมก็เลยสงสัยว่า ถ้าเกิดว่าเวลา

00:23:09.700 --> 00:23:11.700
จะ develop อัพเดตเวอร์ชัน

00:23:11.700 --> 00:23:13.000
อะไรเงี้ย มันจะแก้ปัญหายังไง

00:23:13.200 --> 00:23:15.100
จะต้องไปนั่งตามแก้นี่ทุกครั้งรึเปล่า

00:23:21.200 --> 00:23:22.400
ครับ ผมว่า

00:23:22.400 --> 00:23:23.700
เรื่องของการอัพเดตเวอร์ชันเนี่ย

00:23:23.900 --> 00:23:25.000
เราอาจจะต้องตามดู

00:23:25.300 --> 00:23:27.700
ในแต่ละเวอร์ชันที่เราจะอัพเดตเข้ามาว่า

00:23:27.900 --> 00:23:29.800
แต่ละเวอร์ชันน่ะ มันมี breaking change

00:23:29.900 --> 00:23:32.100
ไม่ว่าจะมีเรื่องของการเปลี่ยน path

00:23:32.100 --> 00:23:34.700
เปลี่ยนไฟล์ หรือว่า มีอัพเดตไฟล์อะไรเข้ามาครับ

00:23:35.000 --> 00:23:36.900
แล้วระหว่างการอัพเดตเวอร์ชัน

00:23:36.900 --> 00:23:38.100
เราน่าจะ detect ได้ว่า

00:23:38.300 --> 00:23:40.200
ตัวเวอร์ชันที่เราอัพเดตไปครับ

00:23:40.300 --> 00:23:42.300
มีการ breaking change ในโค้ดของเรา

00:23:42.700 --> 00:23:44.600
เราอาจจะต้องดูเรื่องของการ

00:23:45.000 --> 00:23:46.500
ทำ regression test เพื่อ

00:23:46.500 --> 00:23:48.300
detect ว่า ตรงนี้ เราอัพเดตไปแล้ว

00:23:48.700 --> 00:23:50.900
มัน break โค้ดเดิมของเราก็ได้ครับ

00:23:52.500 --> 00:23:52.900
ครับ อีกประเด็นนึงครับ

00:23:52.900 --> 00:23:53.700
เรื่อง proxy

00:23:53.800 --> 00:23:56.300
proxy ที่เราบอกว่าใช้ตัว

00:23:56.500 --> 00:23:57.300
Netlify ใช่มั้ยครับ

00:23:57.900 --> 00:23:58.800
Netlify function เนาะ

00:23:59.700 --> 00:24:00.700
Netlify function ใช่ครับ

00:24:01.200 --> 00:24:01.800
คำถามคือ

00:24:01.800 --> 00:24:02.600
เราน่าจะมีการทำ caching มั้ยครับ

00:24:02.600 --> 00:24:04.300
หรือว่าเราแค่เป็นการเป็นแค่

00:24:04.300 --> 00:24:06.500
proxy แบบ reverse proxy เฉยๆเลย

00:24:06.500 --> 00:24:07.800
เพราะว่าเท่าที่ดูเนี่ย

00:24:07.800 --> 00:24:10.000
เหมือนกับว่าถ้ามันต้องมีการ call

00:24:10.600 --> 00:24:11.800
ทุกครั้งเนี่ย data มัน bandwidth

00:24:11.800 --> 00:24:13.000
มันจะสูงมาก

00:24:14.300 --> 00:24:16.100
มี cache ครับ

00:24:16.300 --> 00:24:17.100
โอเค Netlify function

00:24:17.100 --> 00:24:18.000
สามารถบอกได้ว่า cache

00:24:19.000 --> 00:24:20.000
ขอ cache request นี้ไว้ได้

00:24:20.000 --> 00:24:20.800
อ๋อ โอเคครับ คือ

00:24:20.800 --> 00:24:21.600
คือสามารถที่จะกำหนดไว้ใน

00:24:21.600 --> 00:24:22.000
ในฟังก์ชันได้เลยเนาะว่า

00:24:22.500 --> 00:24:22.800
ได้เลยครับ

00:24:27.500 --> 00:24:27.800
โอเคครับ

00:24:38.900 --> 00:24:43.500
อยากถามเรื่อง regression ครับ ว่าเตรียม regression ยังไงบ้าง

00:24:43.700 --> 00:24:50.100
อาจถึงว่าพอแก้ทุกอย่างใน optimize ทุกอย่างของมันก็ต้อง

00:24:50.100 --> 00:24:54.200
regression ทั้งหมดอะไรเงี้ย ก็เลยถามว่าอย่างของที่ EarnIn

00:24:54.200 --> 00:24:57.200
แบบทำเรื่องพวกนี้ยังไงบ้างแบบทุกอย่าง automate หรือว่า

00:24:59.500 --> 00:25:02.100
เรามี automate pipeline CI/CD ครับ

00:25:02.200 --> 00:25:04.400
ก็คือ performance regression

00:25:04.600 --> 00:25:09.200
ยังไม่มี แต่ตัว CI/CD build ตัว build ผ่าน

00:25:10.000 --> 00:25:12.300
ถ้า push version build

00:25:12.700 --> 00:25:15.800
เรามี build pipeline แล้ว build พังก็บอก เราก็เห็นอยู่ใน PR

00:25:16.700 --> 00:25:22.700
มันก็ต้องตอบปัญหาเมื่อกี้ แล้วก็มีพวก e2e test ที่เราทำ

00:25:23.000 --> 00:25:29.600
ก็เป็น e2e test ที่เราม็อค backend ครับ อ๋อ ก็คือเป็น browser

00:25:29.600 --> 00:25:35.600
จริงๆ ใช้ Playwright แล้วก็ simulate ทุกเคส business case

00:25:36.100 --> 00:25:39.300
ที่เราสนใจ รันตอนเปิด PR อันนึง

00:25:40.000 --> 00:25:42.300
แล้วก็ถ้าผ่านก็ merge เข้าไป

00:25:42.700 --> 00:25:48.100
approve อะไรด้วย แล้วก็มี web monitoring อีกตัวนึงที่ไปรันกับ

00:25:48.100 --> 00:25:53.300
ตัว dev จริงๆ ที่เป็น scheduler แบบ cron job รัน ก็มี

00:25:53.600 --> 00:25:58.400
business flow หลักครับ รันเหมือนกันครับ เตรียมตรงนี้ แล้วก็

00:25:58.500 --> 00:26:05.200
มีอีกนิดนึงด้วย มี synthetic test ของ DataDog ที่ไปดูตัวทั้ง

00:26:05.900 --> 00:26:10.600
production ก็ตัว development
เตรียมเรื่องนี้นานแค่ไหนครับ

00:26:16.100 --> 00:26:19.900
อันนี้เราเริ่มตั้งแต่แรกๆ เลยครับ ระหว่างที่เราเริ่มการ develop

00:26:20.000 --> 00:26:24.900
เราก็คิดเสมอว่า การที่เราจะ deliver ตัว product ของเราได้เนี่ย

00:26:25.000 --> 00:26:31.400
มันก็ต้องมี quality ไม่ว่าจะผ่านของการ test ในระดับของการทำ

00:26:31.800 --> 00:26:36.000
manual test หรือว่า automate testing ที่เราอาจจะต้องกลับมา

00:26:36.000 --> 00:26:39.100
แก้ feature เดิม แล้วเราจะ confident ว่า feature ที่เราแก้ไปเนี่ย

00:26:39.100 --> 00:26:40.000
มันไม่พังครับ

00:26:43.800 --> 00:26:44.600
โอเคครับ ขอบคุณครับ

00:26:46.000 --> 00:26:46.500
เดี๋ยวคุยกันต่อได้ครับ

00:27:05.900 --> 00:27:07.300
Hello ถามนิดเดียวครับ

00:27:08.300 --> 00:27:13.100
เวลาดู Lighthouse ปกติมันก็มีใน DevTools นะครับ

00:27:13.400 --> 00:27:15.600
แต่ผมอยากรู้ว่าปกติพี่ใช้ใน DevTools

00:27:15.800 --> 00:27:19.200
หรือ deploy ขึ้นแล้วก็แปะลิงก์ลงในเว็บ

00:27:19.600 --> 00:27:21.000
PageSpeed Lighthouse

00:27:21.500 --> 00:27:24.400
อันนี้เป็น lesson เจ็บๆ ของผมอย่างนึงครับ

00:27:24.800 --> 00:27:28.900
คือตอนแรกผมคิดว่าดูในเครื่อง local

00:27:29.000 --> 00:27:31.100
ดูในเครื่อง local ตัวเอง

00:27:31.400 --> 00:27:33.100
make sense แต่จริงๆ มันไม่ valid

00:27:34.000 --> 00:27:37.400
ควรจะดูตัว dev จริงๆ หรือ production จริงๆ

00:27:37.600 --> 00:27:39.100
เลยมากกว่าตัว local

00:27:39.300 --> 00:27:41.500
เพราะมันจะเห็นอะไรบางอย่าง เช่น บางทีตัว

00:27:42.800 --> 00:27:44.000
third-party segment

00:27:44.200 --> 00:27:47.500
เราเนี่ยโหลด script ไม่เท่ากันในแต่ละ env ด้วยซ้ำ

00:27:48.500 --> 00:27:50.000
ก็ควรจะรันในตัวจริง

00:27:50.500 --> 00:27:53.800
ข้อดีของการรัน local คือมันเห็นเราจะแก้อะไร

00:27:54.200 --> 00:27:56.200
เรา fast feedback ได้มันเร็ว ถูกมั้ย

00:27:56.600 --> 00:27:59.500
จะแก้ปัญหาบางอย่างที่มัน obvious แก้ได้

00:27:59.600 --> 00:28:02.100
แต่ถ้าอะไรที่มันแบบก็คือต้องรันทั้งหมด

00:28:02.300 --> 00:28:05.700
ในมุมมองผมนะ ดูภาพรวมแต่ของจริงก็คือตัว production

00:28:07.700 --> 00:28:10.700
และอีกเรื่องนึงคือ Lighthouse เป็น lab

00:28:11.800 --> 00:28:15.600
มันเป็นการจำลองตัว device เนาะ ไม่ใช่ user จริงๆ

00:28:15.800 --> 00:28:20.300
ผมว่าสิ่งที่ควรทำเพิ่มคือแอด RUM (Real User Monitoring)

00:28:20.400 --> 00:28:24.200
ซึ่งถ้าไม่ใช่ DataDog ก็มีพวก Sentry อะไรอย่างเงี้ย

00:28:25.300 --> 00:28:29.500
หรือว่าตัว Faro ของ Grafana ครับ

00:28:29.700 --> 00:28:32.800
เป็น open source ที่ฟรีครับ

00:28:33.000 --> 00:28:36.600
ควรจะดู user data ของ user จริงๆ ที่เข้ามาด้วย

00:28:36.800 --> 00:28:39.000
Real User Monitoring มากกว่าแค่ตัว Lighthouse

00:28:40.300 --> 00:28:42.600
มี baseline ที่ดูนอกจาก Lighthouse มั้ยครับ

00:28:42.700 --> 00:28:44.400
ปกติที่ทำจริงๆ

00:28:46.600 --> 00:28:51.900
ที่ตัว tool ตัวอื่นอยู่ครับ ชื่อเว็บ PageSpeed test มั้ง

00:28:52.100 --> 00:28:53.700
แต่ตอนนี้ไม่ได้ใช้ครับ

00:28:54.300 --> 00:28:57.800
โอเคครับผม ก็ผมปกติจะบอกรายละเอียดอื่นๆ อีกครับ

00:28:59.900 --> 00:29:01.600
มีเท่านี้ครับ

00:29:12.900 --> 00:29:14.000
ก็ขอบคุณทุกท่านมากครับ
