WEBVTT - Auto-generated by https://github.com/dtinth/autosub

00:00:02.679 --> 00:00:02.997
สวัสดีค่ะ

00:00:03.080 --> 00:00:04.716
โทษทีปัญหาทางเทคนิคนิดหน่อยค่ะ

00:00:04.799 --> 00:00:05.357
มันงอแงค่ะ

00:00:05.440 --> 00:00:07.480
วันนี้ดัน error ใน production ซะงั้น

00:00:08.960 --> 00:00:11.037
ได้ยินอยู่เนาะ

00:00:11.679 --> 00:00:12.277
ชื่อการนะคะ

00:00:12.360 --> 00:00:14.957
วันนี้เดี๋ยวจะมาแชร์กับ web assembly ค่ะ

00:00:15.040 --> 00:00:18.160
ก็มาดูกันว่ามันคืออะไร ใช้งานยังไง

00:00:18.279 --> 00:00:21.877
แล้วเราจะเอามันมา plugin กับสิ่งที่เราทำอยู่ทุกวันนี้

00:00:21.960 --> 00:00:22.760
ได้อย่างไรคะ

00:00:23.320 --> 00:00:25.557
ข้อดีของมันคือมัน portable แล้วกัน

00:00:25.640 --> 00:00:28.480
แต่ portable ยังไง มีข้อจำกัดอย่างไรบ้าง

00:00:28.720 --> 00:00:31.120
แล้วทำไมมันถึง portable ไปดูกันนะคะ

00:00:31.400 --> 00:00:33.120
แต่ว่าก่อนอื่นขอขายของนิดนึงค่ะ

00:00:33.760 --> 00:00:36.457
วันอังคารหน้านะคะ ทาง MFX กับ HashiCorp

00:00:36.540 --> 00:00:38.237
จัดงาน conference กันค่ะ

00:00:38.320 --> 00:00:42.237
ก็เกี่ยวกับ HashiCorp stack infrastructure as code

00:00:42.320 --> 00:00:44.199
security แล้วก็ automation นะคะ

00:00:44.559 --> 00:00:46.316
ที่คอนแรดบางกอกค่ะ

00:00:46.399 --> 00:00:49.917
ก็คือตามไปได้นะคะ ก็เข้างานฟรีค่ะ

00:00:50.000 --> 00:00:51.837
แล้วก็มี swag แจกด้วย

00:00:51.920 --> 00:00:53.199
ทีมงานฝากบอกมานะคะ

00:00:53.559 --> 00:00:55.599
ก็สแกน QR code ลงทะเบียนกันได้ค่ะ

00:01:00.920 --> 00:01:02.399
แนะนำตัวก่อนนะคะ

00:01:02.920 --> 00:01:03.717
ชื่อการนะคะ

00:01:03.800 --> 00:01:06.877
ก็ปัจจุบันเป็น independent consultant ค่ะ

00:01:06.960 --> 00:01:10.120
ก็คือออกมาเดี่ยวแล้ว พเนจร ไม่ได้มีสังกัด

00:01:11.680 --> 00:01:15.196
ส่วนตัวก็คือเป็นคนที่ชอบ automate แล้วก็ optimize

00:01:15.280 --> 00:01:15.716
หลายๆ อย่างเนาะ

00:01:15.799 --> 00:01:19.520
เพราะงั้นคืออะไรก็ตามที่ลดเวลา runtime ได้จะแฮปปี้มาก

00:01:21.479 --> 00:01:24.840
เวลาว่างบางทีก็คืออยากรู้ว่าอะไรไวกว่ากัน

00:01:24.960 --> 00:01:27.160
ก็เลยจะไปทำ experiment มา

00:01:28.000 --> 00:01:31.837
แล้วถ้าขยันหน่อยก็จะเอาดาต้าที่ได้มามาออกเป็นบล็อก

00:01:31.920 --> 00:01:36.637
แล้วก็สรุปบทความให้คนอื่นเค้าอ่านกันเล่นนะคะ

00:01:36.720 --> 00:01:39.000
ส่วนมากคือจะ engage ใน community หลายส่วน

00:01:39.320 --> 00:01:42.316
ปัจจุบันก็คือเป็นทั้ง Amazon community builder

00:01:42.399 --> 00:01:44.280
แล้วก็ HashiCorp ambassador ด้วยค่ะ

00:01:44.960 --> 00:01:47.240
มีบล็อกอยู่นะคะ เข้าไปตามอ่านกันได้ค่ะ

00:01:47.759 --> 00:01:51.238
มีภาษาไทยบางบทความ การพึ่งเขียนล่าสุดออกไปเนาะ

00:01:51.520 --> 00:01:54.277
โซเชียลมีเดียจริงๆ Facebook มี แต่ว่ารู้สึกรกก็เลย

00:01:54.360 --> 00:01:54.837
เหมือนกันค่ะ

00:01:54.920 --> 00:01:56.440
ก็ตามไป search กันได้นะคะ

00:01:58.079 --> 00:02:00.600
แนะนำก่อนว่า web assembly คืออะไร

00:02:01.280 --> 00:02:03.636
สำหรับคนที่เรียน computer science มาเนี่ย

00:02:03.719 --> 00:02:05.076
เราก็จะได้ยิน assembly เนาะ

00:02:05.159 --> 00:02:08.036
ซึ่งถ้าเกิดชีวิตนี้ไม่เคยต้องเขียนมาถือว่าโชคดีแล้วค่ะ

00:02:08.119 --> 00:02:08.919
จะได้ไม่ฝันร้าย

00:02:10.759 --> 00:02:13.677
assembly เนี่ยคือมันเป็นอะไรที่แบบเขียนแบบเข้าใกล้

00:02:13.760 --> 00:02:14.599
ภาษามาชีนมากๆ

00:02:15.000 --> 00:02:18.960
แต่ว่าข้อดีของมันคือตัว artifact binary มันจะเล็ก

00:02:19.120 --> 00:02:20.997
แล้วเราเอามันไปทำอะไรหลายๆ อย่าง

00:02:21.080 --> 00:02:24.040
แต่ว่าพอมันเป็น web assembly เนี่ยก็คือมองว่า

00:02:24.360 --> 00:02:26.957
มันก็คงความเป็น assembly

00:02:27.040 --> 00:02:30.720
แต่ว่ามันจะมายืนอยู่บนฝั่ง web platform แทน

00:02:31.239 --> 00:02:34.637
คำว่า web platform ที่ว่าคืออะไรก็ตามที่เป็น

00:02:34.720 --> 00:02:35.637
web assembly

00:02:35.720 --> 00:02:38.920
แล้วถ้าเกิดเรามี browser runtime เราจะใช้งานมันได้

00:02:39.280 --> 00:02:44.076
เพราะงั้นคือจากเมื่อก่อนที่เวลาที่เราจะ deploy

00:02:44.159 --> 00:02:44.717
workload เนี่ย

00:02:44.800 --> 00:02:45.917
คือถ้าเกิดเป็นฝั่ง web เนาะ

00:02:46.000 --> 00:02:48.957
แล้วก็จะมีตัว front-end back-end แล้วก็ database

00:02:49.040 --> 00:02:49.236
ใช่มั้ย

00:02:49.319 --> 00:02:50.399
database ปัดมันไปก่อนนะ

00:02:50.840 --> 00:02:54.557
ตัวอย่างอย่างตัว front-end เนี่ย เราก็ deploy

00:02:54.640 --> 00:02:56.997
เป็น static site ก็ได้

00:02:57.080 --> 00:02:58.840
หรือเป็น server ก็ได้ อะไรก็ว่ากันไป

00:02:59.200 --> 00:03:02.436
แต่มันต้องมีสักตัวนึงทำหน้าที่เป็น web server

00:03:02.519 --> 00:03:03.399
ให้เราเอาของไปวาง

00:03:04.400 --> 00:03:06.000
ก็ต้องมีคนเลี้ยง web server เอาไว้

00:03:06.480 --> 00:03:08.837
แต่ถ้าเกิดเป็น back-end เนี่ยยังไงก็ตามก็ต้องมี server

00:03:08.920 --> 00:03:11.040
เพราะว่า back-end ไม่ได้เกิดมาจากอากาศธาตุ

00:03:11.200 --> 00:03:14.677
คือจะมาบอกว่า it runs on my machine ก็ไม่ได้

00:03:14.760 --> 00:03:17.759
เพราะว่าชาวบ้านชาวช่องเค้าโทรเข้ามาไม่ได้

00:03:21.120 --> 00:03:23.117
การที่เราจะเอาสมมติ back-end ไปวางเนี่ย

00:03:23.200 --> 00:03:25.117
มันก็ต้องมีตัว server

00:03:25.200 --> 00:03:28.280
และ server จะเป็นของเราหรือของเค้าก็แล้วแต่จะตกลงกัน

00:03:28.640 --> 00:03:31.597
แล้วไม่พอก็ขึ้นอยู่กับว่าเราใช้ภาษาอะไรเขียนด้วย

00:03:31.680 --> 00:03:34.880
เพราะถ้าเกิดว่าเราใช้ node เขียน API

00:03:35.080 --> 00:03:38.160
ข้อดีก็คือมาตรฐานสามัญชน คนใช้งานง่าย

00:03:38.319 --> 00:03:39.240
มีตัวอย่างให้เยอะ

00:03:39.400 --> 00:03:43.197
แต่เราก็ต้องเอาตัว node runtime เนี่ยไปวางไว้

00:03:43.280 --> 00:03:44.320
ในตัว server นั้น

00:03:44.519 --> 00:03:47.598
หรือถ้าเกิดถ้ามาตรฐานหน่อยก็ตั้งเป็น docker เข้าไป

00:03:47.840 --> 00:03:50.597
แต่ docker ที่ว่านี้ก็ต้องมี node runtime ด้วยนะ

00:03:50.680 --> 00:03:52.119
แล้วก็ต้องมี node_modules ด้วย

00:03:52.280 --> 00:03:54.837
ซึ่งเราก็รู้กันว่า node_modules คือสิ่งที่หนักที่สุด

00:03:54.920 --> 00:03:55.597
ในจักรวาล

00:03:55.680 --> 00:03:58.600
ยังไม่มีใครโค่นมันได้ ใช่มั้ย

00:03:59.040 --> 00:03:59.600
เจ็บใจมาก

00:03:59.920 --> 00:04:03.440
คือบอกเลยว่าแบบรอบนี้คือลงทุนซื้อ Mac 1 terabyte

00:04:03.720 --> 00:04:05.480
เพราะว่า node_modules เต็มเครื่อง

00:04:07.400 --> 00:04:10.397
คือ redeploy application นั้นแล้วก็มันไม่รอดสักอันที่หนึ่งเลย

00:04:10.480 --> 00:04:13.600
ก็แบบใช้เงินก็ไม่ใช่ปัญหา โอเคต่อทีเนี่ย

00:04:14.239 --> 00:04:18.917
หรือถ้าเกิดว่าบังเอิญแจ็กพอตเราอยู่ในบริษัทที่เค้าใช้ Rust

00:04:19.000 --> 00:04:20.080
ใช้ Go language หรือ API

00:04:20.320 --> 00:04:21.760
ข้อนี้ก็คือเป็น binary

00:04:21.959 --> 00:04:25.520
ข้อเสียคือ binary ของคุณไม่ได้รันได้ทุกที่ค่ะ

00:04:25.720 --> 00:04:29.040
เพราะว่า binary บน Linux ก็อันหนึ่ง

00:04:29.240 --> 00:04:30.637
binary บน Mac ก็อันหนึ่ง

00:04:30.720 --> 00:04:31.840
บน Windows ก็อันหนึ่ง

00:04:32.199 --> 00:04:35.197
คือเราจะมาปั้น binary บน Mac แล้วไปดีพลอยบน server

00:04:35.280 --> 00:04:37.960
ที่เป็น Linux อันนี้ก็ไหว้พระดีๆ ค่ะ

00:04:38.520 --> 00:04:39.560
เดี๋ยวมันจะระเบิดนะคะ

00:04:39.720 --> 00:04:41.080
หรือไม่ก็บางทีเจอเหตุการณ์นี้ค่ะ

00:04:41.240 --> 00:04:46.680
คือใน Mac ได้ ใน Windows ได้ Linux ได้

00:04:47.000 --> 00:04:48.760
แต่เป็น Intel หรือ AMD นะ

00:04:48.960 --> 00:04:51.197
แต่พอไปอยู่บน server ARM ปุ๊บระเบิดตูม

00:04:51.280 --> 00:04:52.396
ไม่เคยเจอ error นี้มาก่อน

00:04:52.479 --> 00:04:53.437
แล้วจะให้เทสบนเครื่องไหน

00:04:53.520 --> 00:04:56.600
เพราะเครื่อง dev ไม่มี ARM อ้าวฉิบหาย นั่นแหละ

00:04:57.400 --> 00:05:00.604
เพราะงั้นคือกลับไปที่ว่าพอมันเป็น WebAssembly เนี่ย

00:05:00.687 --> 00:05:03.517
สิ่งที่เกิดขึ้นคือปั้นมาแล้วรันได้

00:05:03.600 --> 00:05:05.836
ก็คือรันได้เพราะทุกคนไปใช้ runtime เดียวกัน

00:05:05.919 --> 00:05:06.998
คือ browser runtime

00:05:07.720 --> 00:05:09.797
เพราะงั้นปัญหาโลกแตกที่จะต้องมาเจอ

00:05:09.880 --> 00:05:12.240
ว่าถ้าเกิดเป็น Docker ใช่มั้ย

00:05:12.360 --> 00:05:13.840
Docker ก็มี architecture

00:05:14.440 --> 00:05:17.956
คือ Docker คุยกันข้าม OS และ CPU ไม่ได้

00:05:18.039 --> 00:05:18.877
คุยกันก็คือระเบิด

00:05:18.960 --> 00:05:20.917
คือโอเค image มันดึงออกมาได้

00:05:21.000 --> 00:05:22.116
แต่ตอนรันจริงมันจะ error

00:05:22.199 --> 00:05:23.396
ว่าใส่เราแล้วมันจะรันไม่ผ่าน

00:05:23.479 --> 00:05:24.720
แล้วมันจะรันไม่ติดนั่นแหละ

00:05:25.280 --> 00:05:28.360
เพราะงั้นคือแล้วมันจะเจอความบันเทิงตรงที่ว่า

00:05:28.639 --> 00:05:31.197
คือ node เนี่ยบางทีนะ dependency เนี่ย

00:05:31.280 --> 00:05:32.440
ก็ปกติไม่มีอะไร

00:05:32.800 --> 00:05:36.197
แต่พอไปอยู่บนสมมติเครื่อง ARM อย่างเงี้ย

00:05:36.280 --> 00:05:38.159
dependency ลงไม่ติด ลงไม่ได้

00:05:38.440 --> 00:05:40.556
คือลงไม่ได้ build ไม่ได้ รันไม่ได้

00:05:40.639 --> 00:05:42.680
อ้าวจบ กลับทำยังไงดีประมาณนั้น

00:05:43.479 --> 00:05:46.640
เพราะงั้นคือปัญหาโลกแตกที่มันต้องแบบ

00:05:46.759 --> 00:05:48.676
โอเคคือ dev ก็อันหนึ่ง

00:05:48.759 --> 00:05:50.116
แล้วตอน deploy ก็อันหนึ่ง

00:05:50.199 --> 00:05:51.477
คนมันคนละ target กัน

00:05:51.560 --> 00:05:55.317
คือแบบ CPU กับ architecture สลับฝั่งสลับตัวอะไรกันเงี้ย

00:05:55.400 --> 00:05:57.836
มันจะหมดไปเพราะว่าพอมันเป็น WebAssembly เนี่ย

00:05:57.919 --> 00:05:59.520
ก็คือปั้นมาทีเดียวจบ

00:05:59.639 --> 00:06:01.836
คือปั้นได้ก็คือได้ รันได้ก็คือรันได้

00:06:01.919 --> 00:06:05.000
ไม่ต้องไปนั่งลุ้นหน้างานว่าแล้วมันจะรันบนปลายทางได้มั้ย

00:06:05.120 --> 00:06:08.169
ปลายทางที่เราอาจจะไปรู้ตอนที่โยนขึ้นไปแล้วก็ได้

00:06:08.253 --> 00:06:09.999
แล้วกลับเรามาไม่ทัน นั่นแหละค่ะ

00:06:11.160 --> 00:06:15.317
ทีนี้ปัญหาโลกแตกอีกอันต่อมาคือ dependency

00:06:15.400 --> 00:06:16.277
ตรงนี้ยังไม่จบง่ายๆ

00:06:16.360 --> 00:06:19.277
เพราะว่าคือมันจะมีเหตุการณ์อย่างนี้

00:06:19.360 --> 00:06:22.439
คือบางทีเราลงได้เรา build ได้

00:06:23.280 --> 00:06:24.680
แต่เราอาจจะรันมันไม่ได้

00:06:24.840 --> 00:06:27.120
หรือรันมันได้แต่บางอย่างหาย

00:06:27.479 --> 00:06:30.559
เราไม่รู้นอกจากว่าคุณจะเขียน test กำกับไว้ทุกจุด

00:06:30.680 --> 00:06:32.160
ซึ่งอันนี้เป็นกับทุกภาษา

00:06:32.479 --> 00:06:37.320
หรือไม่บางทีก็คือปั้นมาได้

00:06:37.520 --> 00:06:42.080
แต่ว่าพอเอาไปรันจริงคือเหมือน implementation น่ะ

00:06:42.240 --> 00:06:44.757
มันจะไม่เหมือนกันเวลาข้าม architecture กัน

00:06:44.840 --> 00:06:47.197
เพราะว่ามีเหมือนกับ if else condition อยู่ในหลังบ้าน

00:06:47.280 --> 00:06:49.360
อะไรเงี้ยมันก็จะเกิดอาการพังได้

00:06:49.479 --> 00:06:53.157
เพราะงั้นคือมันเลยเป็นอะไรที่แบบท้าชะตาฟ้าดินมากๆ

00:06:53.240 --> 00:06:56.680
กับการที่เรา dev บนเครื่องแบบหนึ่ง

00:06:56.800 --> 00:06:58.377
แล้วเราต้องไป deploy ไปเข้าอีกแบบหนึ่ง

00:06:58.460 --> 00:07:03.116
โดยที่เราไม่มี environment จำลองแบบเครื่องปลายทาง

00:07:03.199 --> 00:07:04.119
ให้เรามานั่งลุ้นกัน

00:07:04.280 --> 00:07:05.839
คือปัญหาตรงนี้มันเกิดขึ้นเพราะว่า

00:07:06.280 --> 00:07:09.439
คือตัว compute ถ้าเกิดเป็น ARM

00:07:09.840 --> 00:07:11.119
ราคาถูกกว่าแบบเว่อร์มาก

00:07:11.360 --> 00:07:14.676
เพราะงั้นคือหลายๆ คนเลยพยายามในการที่ dev ยังไงก็ dev ไป

00:07:14.759 --> 00:07:17.556
แต่ว่าตอน deploy คือต้องไป deploy แบบเป็น ARM

00:07:17.639 --> 00:07:18.236
ต้องการลด cost

00:07:18.319 --> 00:07:19.796
แล้วราคามันต่างกันแบบเว่อร์ๆ นะ

00:07:19.879 --> 00:07:20.597
ต่างกันแบบเว่อร์จริง

00:07:20.680 --> 00:07:22.800
เพราะงั้นคือเค้าถึงลงทุนทำตรงนี้กัน

00:07:22.960 --> 00:07:25.719
แต่พอมันเป็นอย่างเงี้ยที่แบบติดเรื่อง CPU

00:07:25.960 --> 00:07:27.236
ติดเรื่อง OS อะไรเงี้ย

00:07:27.319 --> 00:07:28.600
มันก็เลยเป็นเรื่องที่แบบ

00:07:29.479 --> 00:07:31.819
คือถ้าเกิดเราไม่มีระบบจัดการดีๆ

00:07:31.919 --> 00:07:33.757
มันจะกิน man-day ของ dev เยอะ

00:07:33.840 --> 00:07:36.116
ในการที่เราต้องไปนั่ง debug ว่าปัญหาคือตรงไหน

00:07:36.199 --> 00:07:37.877
แล้วมันก็จะกลายเป็นสูญเสียเวลางาน

00:07:37.960 --> 00:07:39.997
เพราะว่าต้องมานั่งลุ้นกันว่าทำอะไรไป

00:07:40.080 --> 00:07:41.516
แล้วจะมีอะไรพังมั่งประมาณนั้น

00:07:41.599 --> 00:07:43.236
คือ QA ก็จะมานั่งลุ้นเรา

00:07:43.319 --> 00:07:46.240
เพราะแบบรำคาญว่าแบบแล้วพวกแกหยุดแก้กันได้ยัง

00:07:46.400 --> 00:07:47.919
ประมาณนั้น นั่นแหละ

00:07:48.560 --> 00:07:49.840
ผมไม่เอา ARM ไว้นะคะทุกคน

00:07:51.680 --> 00:07:55.159
ทีนี้แต่ข้อดีของ WebAssembly คือมันเบา

00:07:55.960 --> 00:07:57.516
เอาง่ายๆ คือถ้าเกิดเป็น Rust เนี่ย

00:07:57.599 --> 00:08:00.197
ที่เรารู้กันว่า Rust binary มันก็เบาอยู่แล้ว

00:08:00.280 --> 00:08:01.877
คือถ้าเกิดพูดถึง binary เนี่ย

00:08:01.960 --> 00:08:03.840
ก็จะเป็น Rust กับ Go เนาะ

00:08:03.960 --> 00:08:05.597
ซึ่ง Go แน่นอนว่า compile ไว

00:08:05.680 --> 00:08:08.760
แต่ว่า binary ก็จะอ้วนตุ๊ต๊ะประมาณหนึ่ง

00:08:09.080 --> 00:08:10.637
แต่ถ้าเกิดเป็น Rust เนี่ย

00:08:10.720 --> 00:08:13.477
โอเคเขียนยากกว่า ใช้เวลา compile นานกว่า

00:08:13.560 --> 00:08:15.359
แต่ว่าตัว binary มันจะเบากว่า

00:08:15.680 --> 00:08:19.799
แต่พอเป็น WebAssembly เนี่ย binary 100 KB

00:08:20.199 --> 00:08:21.280
ไม่ได้เว่อร์พูดจริง

00:08:21.800 --> 00:08:23.800
มันเบามากเบาแบบไม่ต้องคิดชีวิตเลย

00:08:23.960 --> 00:08:26.877
เพราะงั้นคือถ้าเกิดเราต้องปั้นอะไรสักอย่างมา

00:08:26.960 --> 00:08:32.277
แล้วแบบมันเปลี่ยนจาก Go หรือ Rust เป็น WebAssembly ได้เนี่ย

00:08:32.360 --> 00:08:34.440
โอ้โหคือแบบ storage หายไปเยอะมาก

00:08:34.680 --> 00:08:36.436
คือปกติเวลา deploy กันน่ะ

00:08:36.519 --> 00:08:39.037
มันต้องเอา artifact เนี่ยไปขึ้นไปใน storage

00:08:39.120 --> 00:08:40.520
พอมันขึ้นไป storage เนี่ย

00:08:40.760 --> 00:08:43.213
เรา build บ่อยๆ release บ่อยๆ test บ่อยๆ

00:08:43.333 --> 00:08:44.120
storage มันบวม

00:08:44.680 --> 00:08:46.477
แต่ถ้าเกิดว่าเราลดกำลังได้

00:08:46.560 --> 00:08:48.480
ว่า storage มันจะมีของไปวางน้อยลง

00:08:48.720 --> 00:08:49.720
มันลดตังค์ได้เยอะมาก

00:08:49.959 --> 00:08:53.079
คือแล้วยิ่งถ้าเกิดเป็นบริษัทที่ทำกันหลาย service น่ะ

00:08:53.360 --> 00:08:56.160
ตังค์ตรงเนี้ยลดได้ระดับแบบหลายเปอร์เซ็นต์เลย

00:08:56.360 --> 00:08:56.997
คือคุ้มจริง

00:08:57.080 --> 00:09:01.397
เพราะงั้นคือถ้าเกิดว่าเค้าทำเรื่องของ financial operation

00:09:01.480 --> 00:09:01.756
กันจริงๆ

00:09:01.839 --> 00:09:04.597
เค้าจะมาแบบรีดแข่งขันกันทุกส่วน

00:09:04.680 --> 00:09:07.840
ตรงนี้ก็เป็นจุดหนึ่งที่เค้าเอามารีดแข่งขันกันได้

00:09:09.440 --> 00:09:13.000
ทีนี้ข้อดีอีกอย่างหนึ่งคือพูดถึง backend ใช่มั้ย

00:09:13.459 --> 00:09:15.920
backend เนี่ยมันอยู่ที่อื่นไม่ได้อยู่ที่เรา

00:09:16.320 --> 00:09:19.080
เพราะงั้นคือถ้า backend เราร่วง

00:09:19.279 --> 00:09:20.480
user ก็ใช้ระบบเราไม่ได้

00:09:20.959 --> 00:09:24.200
แต่พอเป็น WebAssembly มันเป็น client-side

00:09:24.920 --> 00:09:27.477
นั่นแปลว่าสมมติว่าเรามี logic อันหนึ่ง

00:09:27.560 --> 00:09:30.480
แล้วกันเป็น logic ในการ encryption key เนาะ

00:09:30.680 --> 00:09:32.440
ซึ่งถ้าปกติก็คือเราอาจจะบอกว่า

00:09:32.800 --> 00:09:35.280
โอเคไอ้ logic นี้มันเขียนสมมติว่า

00:09:35.519 --> 00:09:38.037
อาจจะเป็นเคสที่ว่าไอ้ logic ตรงนี้เนี่ย

00:09:38.120 --> 00:09:40.279
มันเขียนเป็นใน TypeScript ยากเหลือเกิน

00:09:40.440 --> 00:09:41.717
เขียนเป็น Rust มันง่ายกว่า

00:09:41.800 --> 00:09:43.280
แล้วก็อาจจะไปขึ้น API เป็น Rust

00:09:43.640 --> 00:09:45.359
แต่พอขึ้น API เป็น Rust เนี่ย

00:09:45.560 --> 00:09:47.237
เราก็ต้องไป deploy ตัว API ตัวนี้

00:09:47.320 --> 00:09:49.160
แล้วก็ให้ชาวบ้านมานั่งทะลุมาหาเรา

00:09:49.399 --> 00:09:51.917
แต่ถ้าเกิดว่าเราไปปั้นตัวเนี้ยมาเป็น Rust

00:09:52.000 --> 00:09:53.240
แต่ว่าปั้นออกมาเป็น WASM

00:09:53.560 --> 00:09:56.280
แล้วเราเอา WASM ตรงเนี้ยมาฝังไว้ในหน้า frontend น่ะ

00:09:56.440 --> 00:09:57.996
มันเรียกกันเองได้เลยโดยที่หน้างาน

00:09:58.079 --> 00:10:00.316
โดยที่เราไม่ต้องไปทะลุ API ให้วุ่นวาย

00:10:00.399 --> 00:10:02.196
นั่นหมายความว่าเราไม่ต้องเปลืองตังค์

00:10:02.279 --> 00:10:03.520
ในการมานั่ง deploy API

00:10:07.160 --> 00:10:07.660
อือหือ

00:10:08.080 --> 00:10:09.720
ทีนี้มันก็มีข้อเสียเหมือนกันคือ

00:10:10.160 --> 00:10:12.957
ตัว WebAssembly เนี่ยมันใช้เวลาช้ากว่าในการรัน

00:10:13.040 --> 00:10:16.319
ถ้าเกิดเทียบกับเป็นแบบ native หรือ Docker แล้วกัน

00:10:16.760 --> 00:10:17.677
คือตรงนี้เป็น overhead

00:10:17.760 --> 00:10:22.760
เพราะว่า browser จริงๆมันก็ไม่ได้ไวอยู่แล้ว

00:10:23.160 --> 00:10:27.797
แต่มันรันแบบ common มากที่แบบว่าทุกที่ก็คือมี browser

00:10:27.880 --> 00:10:29.040
ทุกที่คือใช้ browser ได้

00:10:29.279 --> 00:10:31.357
เพราะฉะนั้นคือตรงเนี้ยมันเลยเป็นเรื่องของการ trade-off

00:10:31.440 --> 00:10:35.957
มากกว่าว่าเราจะแลกกันระหว่างตัว portability กับ speed

00:10:36.040 --> 00:10:37.077
ในการ execute

00:10:37.160 --> 00:10:38.677
ซึ่งตรงนี้ไม่ได้เป็นเรื่องแย่เสมอไป

00:10:38.760 --> 00:10:42.237
เพราะว่าบางทีคือ speed มันช้ากว่าก็จริง

00:10:42.320 --> 00:10:44.677
แต่ว่ามันอาจจะไม่ได้ต้องรันถี่ขนาดนั้น

00:10:44.760 --> 00:10:45.840
มันก็เลยไม่มีข้อขวด

00:10:46.000 --> 00:10:49.360
มันก็เลยเป็นความช้าที่มันพอรับได้อยู่แล้วกันประมาณนั้น

00:10:50.639 --> 00:10:51.200
อือหือ

00:10:52.040 --> 00:10:55.077
ทีนี้นอกจากการที่เราจะเอาตัว WebAssembly

00:10:55.160 --> 00:10:57.639
เนี่ยไปฝังไว้ใน browser ให้คนทั่วไปมาใช้

00:10:58.160 --> 00:11:01.320
เราก็สามารถเอามารันแบบเป็น binary program ได้ปกติ

00:11:01.639 --> 00:11:04.839
คือหมายความว่าปกติสมมุติอาจจะเป็น .exe อะไรพวกนี้

00:11:05.760 --> 00:11:08.237
เราก็สามารถเอาตัว WebAssembly ที่เป็น binary

00:11:08.320 --> 00:11:09.637
เนี่ยมารันตรงๆได้เหมือนกัน

00:11:09.720 --> 00:11:11.397
ก็แน่นอนว่า speed ก็ช้ากว่า

00:11:11.480 --> 00:11:16.996
แต่ก็มีข้อดีคือเราไม่ต้องมานั่งเสียเวลา setup pipeline

00:11:17.079 --> 00:11:18.837
ในการทำ deploy หรือ release

00:11:18.920 --> 00:11:20.400
แล้วก็มานั่ง config แยกกว่า

00:11:20.639 --> 00:11:23.837
ถ้าเกิดเราจะ release ตัว binary เป็นแต่ละ target

00:11:23.920 --> 00:11:25.480
ให้มันรองรับทุกสิ่งอย่างบนโลกใบนี้

00:11:25.680 --> 00:11:26.920
มันต้องทำยังไงกันยังไง

00:11:27.200 --> 00:11:31.797
เพราะว่าปกติถ้าเกิดเราจะ distribute ตัว binary

00:11:31.880 --> 00:11:37.117
สิ่งที่เกิดขึ้นคือแน่ๆคือต้องมี Linux Darwin แล้วก็ Windows

00:11:37.200 --> 00:11:40.560
แล้วก็ต้องมี ARM64 แล้วก็ Linux AMD64

00:11:42.360 --> 00:11:43.920
แล้วก็อาจจะมี RISC-V เข้ามาอีก

00:11:44.079 --> 00:11:46.319
ซึ่งตรงนี้บางทีอาจจะเจอผีที่ว่า

00:11:47.320 --> 00:11:51.477
ปั้น Intel ผ่าน แต่ปั้น ARM ไม่ผ่าน

00:11:51.560 --> 00:11:54.160
อันนี้ก็ต้องไปรื้อหน้ารันกันว่า dependency ลงครบไหม

00:11:54.480 --> 00:11:57.677
แล้วอีกอย่างนึงคือการที่เราต้องใช้กระบวนท่า

00:11:57.760 --> 00:11:59.677
ในการ cross-compile

00:11:59.760 --> 00:12:02.280
จากสมมุติเราอยู่บนเครื่อง AMD

00:12:02.440 --> 00:12:05.556
แต่ว่าเราต้องการปั้น binary เป็น ARM อย่างเงี้ย

00:12:05.639 --> 00:12:07.277
มันจะใช้เวลานานมาก

00:12:07.360 --> 00:12:12.477
คือถ้าเกิดว่าใครที่ใช้ M1 Mac รุ่นแรกๆแล้วต้องใช้ Docker

00:12:12.560 --> 00:12:12.996
จะจำได้ดี

00:12:13.079 --> 00:12:16.399
เพราะว่าทุกอย่างยังเป็น image AMD อยู่

00:12:16.519 --> 00:12:19.597
แล้วเวลาเอามารันบน Mac มันจะช้าแบบเต่าคลานเลย

00:12:19.680 --> 00:12:22.600
ถึงขั้นต้องให้คนไปหัดวิธี build กันในเครื่อง

00:12:22.760 --> 00:12:24.560
ไม่งั้นคือทำอะไรกินไม่ได้

00:12:25.120 --> 00:12:28.316
แล้วถ้าเกิดจะไป build แบบ ARM raw ไว้

00:12:28.399 --> 00:12:30.196
ก็คือรอประมาณ 3 ชั่วโมงเสร็จได้

00:12:30.279 --> 00:12:34.677
นอกจากจะไปปลุก runner CI ที่เป็น ARM มานั่งรัน

00:12:34.760 --> 00:12:38.316
แต่ก็คือเราก็ต้องมานั่ง config ของใครของมันแยกอยู่ดี

00:12:38.399 --> 00:12:39.759
ก็เลยเป็น trade-off ตรงนี้ว่า

00:12:41.199 --> 00:12:43.477
คือเวลาที่เสียไปแต่ละจุดมี

00:12:43.560 --> 00:12:45.237
แต่ว่าเอามาเฉลี่ยกันเนี่ย

00:12:45.320 --> 00:12:47.397
ถ้าเกิดมันออกท่า WebAssembly เนี่ย

00:12:47.480 --> 00:12:49.879
อาจจะทำให้ทุกคนเสียเวลาน้อยสุดก็ได้เหมือนกัน

00:12:51.600 --> 00:12:52.040
อือหือ

00:12:53.080 --> 00:12:56.517
ทีนี้พอมันเบาเนี่ย สิ่งที่เกิดขึ้นคือ IoT จะ happy มาก

00:12:56.600 --> 00:12:58.477
เพราะว่า IoT ที่ว่าเนี่ย

00:12:58.560 --> 00:13:00.677
อาจจะเป็นตัว single-board computer

00:13:00.760 --> 00:13:03.597
ที่ทำเป็น cluster อยู่บนพื้นที่ห่างไกล

00:13:03.680 --> 00:13:04.560
หรืออะไรก็แล้วแต่

00:13:04.680 --> 00:13:09.277
หรืออาจจะเป็นรถก็ได้ หรือ vehicle ก็ได้

00:13:09.360 --> 00:13:10.957
เพราะว่าอันนี้มีการใช้งานจริง

00:13:11.040 --> 00:13:14.000
คือบางที่ค่ะคือมันจะมีเหมือนกับ function บางอย่าง

00:13:14.399 --> 00:13:20.159
ที่เค้าต้องรันเวลามันเป็น part ของ OS บนพวกรถยนต์

00:13:20.519 --> 00:13:24.077
แล้วการที่เค้า deploy มันออกมาเป็น WebAssembly

00:13:24.160 --> 00:13:26.839
เนี่ยทำให้มันกินที่บน onboard memory ไม่เยอะ

00:13:27.079 --> 00:13:29.277
แล้ว execution time ก็ถือว่ารับได้

00:13:29.360 --> 00:13:31.357
เพราะว่าก็มีแต่คนเดียวใช้งาน

00:13:31.440 --> 00:13:32.840
ตรงนี้ก็เลยเป็นข้อดีที่ว่า

00:13:34.160 --> 00:13:36.477
การที่มันมี footprint ที่มันเล็ก

00:13:36.560 --> 00:13:38.637
เนี่ยทำให้มันคล่องตัวในการ deploy

00:13:38.720 --> 00:13:40.436
อีกอย่างนึงคือถ้าเกิดสมมุติว่า

00:13:40.519 --> 00:13:42.917
มันต้องมีการ update binary อะไรพวกนี้

00:13:43.000 --> 00:13:44.917
มันก็จะกิน network bandwidth ไม่ค่อยเยอะ

00:13:45.000 --> 00:13:48.876
เพราะว่าตัว artifact size เนี่ยมันเบาอยู่แล้ว

00:13:48.959 --> 00:13:50.397
ทำให้มีความคล่องตัวมากขึ้น

00:13:50.480 --> 00:13:53.760
ในการจัดการอะไรหลายๆอย่างที่มันเป็นเกี่ยวกับระบบ IoT

00:13:55.720 --> 00:13:56.160
อือฮึ

00:13:56.880 --> 00:14:00.040
ทีนี้ในเมื่อมันเป็น static และเป็น asset ปกติ

00:14:00.560 --> 00:14:03.280
เราสามารถไปขี่หลัง CDN ได้

00:14:03.680 --> 00:14:08.316
CDN ถ้าเกิดแปลความก็คือ content delivery network

00:14:08.399 --> 00:14:12.161
ว่าง่ายๆ คือ สมมุติว่าเราดิพลอยเว็บไซต์เป็น static

00:14:12.399 --> 00:14:15.237
เป็น frontend ธรรมดา HTML JavaScript

00:14:15.320 --> 00:14:17.319
แล้วเราก็เราอยู่กรุงเทพฯ นะตอนนี้

00:14:17.519 --> 00:14:21.280
แต่ server เราอยู่สมมุติอยู่ยุโรปแล้วกัน

00:14:21.600 --> 00:14:25.316
ถ้าเกิดว่าเราเข้าเว็บนั้นที่มันอยู่ยุโรป

00:14:25.399 --> 00:14:26.639
แต่เราอยู่ไทยอ่ะ มันจะช้า

00:14:27.040 --> 00:14:30.120
เพราะงั้นคือ CDN คือมันจะเป็นตัวกลางอีกทีนึงที่บอกว่า

00:14:30.519 --> 00:14:34.439
มันจะเหมือนกับคอยเอา source ของเราอ่ะ

00:14:34.639 --> 00:14:36.196
ไปวางไว้หลายๆ จุดบนพื้นที่

00:14:36.279 --> 00:14:38.840
จะเป็นอเมริกา ยุโรป เอเชียอะไรก็ว่ากันไป

00:14:39.160 --> 00:14:40.237
แล้วเวลาเราเข้าไปเนี่ย

00:14:40.320 --> 00:14:43.400
เราก็จะไปเช็คว่าเราอยู่บนจุดไหนของโลก

00:14:43.560 --> 00:14:47.319
แล้วเราไป retrieve ของจากไหนถึงจะได้ของไวที่สุดแล้วกัน

00:14:47.519 --> 00:14:50.560
เพราะงั้นคือถ้าเกิดเทียบกันเนี่ย สิ่งที่เกิดขึ้นคือ

00:14:50.880 --> 00:14:52.436
ถ้าเป็นในเรื่องของ logic backend น่ะ

00:14:52.519 --> 00:14:55.577
เราก็ต้องดิพลอยในจุดที่มันใกล้ user ที่สุดน่ะ

00:14:55.660 --> 00:14:57.357
หมายความว่า ถ้า user เราอยู่ไทย

00:14:57.440 --> 00:15:04.040
เราคงจะไปดิพลอยที่สิงคโปร์ หรืออินโด หรือไทยแลนด์แล้วกัน

00:15:04.199 --> 00:15:06.357
แต่ถ้าเกิดเป็น Wasm เนี่ย เราก็ไม่ต้องคิดอะไรมาก

00:15:06.440 --> 00:15:08.077
หน้ามืดให้มันเกาะหลัง CDN ไปเลย

00:15:08.160 --> 00:15:08.917
ก็เกาะกับ frontend ไป

00:15:09.000 --> 00:15:11.756
ก็ไม่ต้องไปนั่งทำเหมือนกับ replicate region deployment

00:15:11.839 --> 00:15:15.756
ให้มันมี duplicate deployment กันในหลาย region

00:15:15.839 --> 00:15:18.840
จะได้ low latency ในการ access service เหล่านี้

00:15:19.839 --> 00:15:24.717
อือฮึ ทีเนี้ยในการใช้งานจริงเนี่ย Google ใช้งานจริงอยู่ค่ะ

00:15:24.800 --> 00:15:28.439
ก็คือทาง Google เนี่ยได้มีการนำ feature core หลักของ

00:15:28.600 --> 00:15:30.717
product Google Earth เนี่ย ออกมาเป็น Wasm

00:15:30.800 --> 00:15:32.357
แล้วก็เอาไปดิพลอยในหลายๆ แพลตฟอร์ม

00:15:32.440 --> 00:15:34.756
เพราะว่า Google Earth เนี่ยมันเป็น multi-platform

00:15:34.839 --> 00:15:37.357
แพ็คมันก็จะมีทั้งเว็บ โมบายล์ ร้านแปะอะไรก็ว่าไป

00:15:37.440 --> 00:15:40.756
เพราะงั้นคือการที่มันเป็นอย่างเงี้ยมันเลยกลายเป็นที่ว่า

00:15:40.839 --> 00:15:43.357
เราไม่จำเป็นต้อง implement core logic ในหลายๆ ภาษา

00:15:43.440 --> 00:15:46.676
เพราะว่าเวลาเขียนแอปหรือเขียนเว็บอะไรเงี้ย

00:15:46.759 --> 00:15:48.157
มันจะใช้คนละภาษากัน

00:15:48.240 --> 00:15:51.079
แต่ถ้าเกิดว่าเรา abstract ตัวนี้ออกไปเป็นก้อน Wasm

00:15:51.279 --> 00:15:53.116
เราสามารถแชร์ logic ก้อนเดียวกัน

00:15:53.199 --> 00:15:56.760
แล้วไม่ว่าคุณอยู่ที่ไหนก็ใช้งานได้นั่นเอง

00:15:58.319 --> 00:16:01.196
อือฮึ แล้วก็อีกอย่างนึงคือตัว Wasm เนี่ย

00:16:01.279 --> 00:16:04.037
เราสามารถเอามันไปมัดเป็น container ก็ได้

00:16:04.120 --> 00:16:07.120
นั่นหมายความว่าตัว container เนี่ยก็จะมี 2 ท่า คือ

00:16:07.279 --> 00:16:10.316
1. เราเอาตัว Wasm runtime อ่ะ ไปยัดไว้ใน container เลย

00:16:10.399 --> 00:16:12.720
แล้วก็เอา Wasm binary แปะปุ๊บเป็น entry point ไป

00:16:13.120 --> 00:16:16.637
หรือท่าที่ 2 ก็คือ มันเป็น container ที่มีแต่ Wasm binary เลย

00:16:16.720 --> 00:16:19.357
แต่ว่าเราให้ตัว Wasm runtime อ่ะ

00:16:19.440 --> 00:16:23.400
ไปเกาะหลังอยู่ตัว daemon ที่ดัน container อีกทีนึง

00:16:23.639 --> 00:16:25.477
ข้อดีก็คือ image มันจะเบามาก

00:16:25.560 --> 00:16:27.876
ซึ่งมันน่าจะเป็นเรื่องแบบปลาดมาก

00:16:27.959 --> 00:16:31.880
ถ้าเกิดว่า Docker image size แค่ 250 KB จะเป็นไปได้แล้วจริง

00:16:33.880 --> 00:16:36.676
อือฮึ อันนี้ก็เป็นท่าดิพลอยอันนึงก็คือ

00:16:36.759 --> 00:16:40.360
เวลาดิพลอยจริงอ่ะก็คือ เราก็ไปขี่คอ CDN ไปเลย

00:16:40.880 --> 00:16:43.759
ถ้าเกิดว่าจะไม่ได้ดิพลอยเป็นท่า Docker ซึ่งก็ได้เหมือนกัน

00:16:46.079 --> 00:16:47.196
อันนี้เป็น benchmark นะคะ

00:16:47.279 --> 00:16:50.556
เทียบกันระหว่างการที่เราเอาตัว native function

00:16:50.639 --> 00:16:51.717
เป็น hello world ปกตินี่แหละ

00:16:51.800 --> 00:16:54.719
แต่ว่าเทียบกันระหว่างตัว Rust, Go, Python แล้วก็ Wasm

00:16:54.880 --> 00:16:58.239
จะเห็นได้ว่า ไม่แน่ใจอ่านได้มั้ย

00:16:58.480 --> 00:17:01.517
คือ Python น่ะที่มันตรงกลาง 2 อันน่ะ อันนั้นนานสุดอยู่แล้วแหละ

00:17:01.600 --> 00:17:03.320
แต่ว่าฝั่งซ้ายอ่ะมันจะเป็น Go

00:17:03.519 --> 00:17:06.880
ซึ่ง Go ที่เป็น Go native กับ Go Wasm อ่ะ ห่างกันประมาณนึง

00:17:07.079 --> 00:17:09.476
แต่ถ้าเกิดเป็นฝั่งขวา 2 อันน่ะ มันจะเป็น Rust

00:17:09.559 --> 00:17:13.157
ซึ่งจะเห็นได้ว่าที่เป็น Rust native กับ Rust ที่เป็น Wasm อ่ะ

00:17:13.240 --> 00:17:14.157
มันห่างกันไม่มาก

00:17:14.240 --> 00:17:18.236
เพราะงั้นคือถ้าเราอยากได้ performance ของ Wasm ที่มันดีที่สุดน่ะ

00:17:18.319 --> 00:17:21.480
เราจะต้องไปเขียนเป็น Rust แล้วก็ปั่นออกมาเป็น Wasm

00:17:21.959 --> 00:17:25.000
วิธีนี้จะทำให้ได้ Wasm binary ที่มีความไวสุด

00:17:27.520 --> 00:17:30.157
อันนี้เป็นตัว binary กับ container size

00:17:30.240 --> 00:17:32.877
ระหว่างที่เป็นตัว binary ของ Wasm กับ native

00:17:32.960 --> 00:17:35.476
แล้วก็ container ของ Wasm กับ native

00:17:35.559 --> 00:17:37.637
จะเห็นได้ว่า ถ้าเป็น binary size เนี่ย

00:17:37.720 --> 00:17:40.557
มันจะห่างกันประมาณ 400% ซึ่งก็ถือว่าเยอะอยู่

00:17:40.640 --> 00:17:43.397
แต่ถ้าเกิดเป็น container เนี่ย คือห่างกันแบบเวอร์ไปเลย

00:17:43.480 --> 00:17:46.077
คือประมาณเกือบ 6,000% ประมาณนั้น

00:17:46.160 --> 00:17:49.317
ซึ่งตรงนี้ก็จะมีข้อดีคือในการที่เราลด cost

00:17:49.400 --> 00:17:52.157
ในการที่เราต้อง store image container เอาไว้บน cloud ได้

00:17:52.240 --> 00:17:54.520
ก็จะลดตังค์ไปได้เยอะประมาณนึง

00:17:55.679 --> 00:18:00.277
ตัวนี้เป็นการที่ลองเอาตัว Wasm อ่ะค่ะ มาเรียกกับภาษาอื่น

00:18:00.360 --> 00:18:02.757
นั่นหมายความว่าคือจริงๆ อ่ะ Wasm ของมันอ่ะอยู่ของมันอยู่แล้วแหละ

00:18:02.840 --> 00:18:06.400
แต่ว่าจะลองใช้ภาษาอื่นเช่น Go, Rust, Python มาเรียก Wasm

00:18:06.600 --> 00:18:08.637
จะเห็นได้ว่า ข้างล่างที่เป็นสีม่วงๆ ค่ะ

00:18:08.720 --> 00:18:11.836
อันนั้นคือเป็น Wasm ตรงๆ เนาะ มันก็ไวสุดอยู่แล้ว

00:18:11.919 --> 00:18:13.720
แต่ว่าถ้าเกิดเป็นข้างบนสุดน่ะจะเป็น Python

00:18:13.840 --> 00:18:16.437
จะเห็นได้ว่า การที่เราเรียก ต่อให้เป็น Wasm ก็ตาม

00:18:16.520 --> 00:18:19.240
แต่ว่าเรียกผ่าน Python มันจะใช้เวลานานสุด

00:18:19.480 --> 00:18:21.836
ในขณะเดียวกันถ้าเกิดเป็น Rust กับ Go เนี่ย

00:18:21.919 --> 00:18:23.557
มันจะใช้เวลาห่างกันไม่ค่อยมาก

00:18:23.640 --> 00:18:28.637
อันนี้ก็แล้วแต่สะดวกว่า ecosystem ของแต่ละบริษัทใช้อะไรเป็นหลัก

00:18:28.720 --> 00:18:31.317
ซึ่งในการเรียกตรงนี้ก็ overhead ไม่ได้ต่างกันมาก

00:18:31.400 --> 00:18:34.637
ก็คือใช้อันไหนก็ได้ ถ้าเกิดแคร์เรื่อง performance นะคะ

00:18:34.720 --> 00:18:39.199
โอเค ก็ประมาณนี้ค่ะ หมดแล้ว มีคำถามมั้ยคะ

00:18:56.080 --> 00:19:00.800
โอเคครับผม ก็ขอขอบคุณพี่กานนะครับผม

00:19:01.440 --> 00:19:03.600
ก็เรื่อง WebAssembly นะครับ

00:19:04.440 --> 00:19:07.237
สำหรับทีนี้นะครับก็อย่างที่ผมได้กล่าวไปในช่วงขั้นต้น

00:19:07.320 --> 00:19:09.640
ใช่มั้ยครับว่าเรามีการ Q&A นะครับผม

00:19:10.880 --> 00:19:13.197
แล้วก็ใครก็ตามนะครับที่ถาม meaningful question นะครับ

00:19:13.280 --> 00:19:14.680
ไม่ต้องตึงมากก็ได้นะครับ

00:19:14.840 --> 00:19:18.719
เรามีแจก JetBrains นะครับ เป็น license 1 ปีเลยครับผม

00:19:20.400 --> 00:19:21.476
เข้าสู่ช่วง Q&A ครับ

00:19:21.559 --> 00:19:23.677
มีใครอยากจะถามคำถามอะไรมั้ยครับ

00:19:23.760 --> 00:19:26.680
เกี่ยวกับ WebAssembly เชิญครับผม เชิญครับ

00:19:30.559 --> 00:19:32.799
โอเคครับ คือส่วนตัวผมอ่ะ

00:19:33.240 --> 00:19:36.716
ผมมอง WebAssembly กับตัวที่เป็นของฝั่ง front-end

00:19:36.799 --> 00:19:38.560
ฝั่ง client น่ะครับ

00:19:38.679 --> 00:19:40.720
คือส่วนตัวผม ผมมีความสงสัยว่า

00:19:41.840 --> 00:19:44.000
ถ้าเหมือนเป็นตัวฝั่งของ front-end น่ะ

00:19:44.120 --> 00:19:46.716
ตัว WebAssembly กับตัวของฝั่งพวกเหมือน JavaScript

00:19:46.799 --> 00:19:48.680
พวกเช่นพวก React พวก Next อย่างเงี้ย

00:19:49.240 --> 00:19:52.797
ไอ้ฝั่งของ WebAssembly อ่ะ มันดูจะมี performance

00:19:52.880 --> 00:19:53.437
ที่มากกว่า

00:19:53.520 --> 00:19:56.520
ทำไมแบบหลายๆ ที่เค้ายังถึงไม่เป็น

00:19:56.880 --> 00:19:59.640
ยังไม่ migrate ไปเป็นตัวของ WebAssembly

00:19:59.880 --> 00:20:01.560
แล้วก็อีกคำถามนึงพวกมีด้วยคือ

00:20:02.039 --> 00:20:04.757
เพราะว่าผมสนใจฝั่งของ front-end นะครับ

00:20:04.840 --> 00:20:06.919
คือในมุมมองของ SEO อ่ะ

00:20:07.440 --> 00:20:10.117
ตัวของ WebAssembly มันสามารถทำให้แบบ SEO ดีๆ

00:20:10.200 --> 00:20:10.920
ได้มั้ยครับ

00:20:11.600 --> 00:20:12.716
อันนี้คิดว่าต้องแยกกันค่ะ

00:20:12.799 --> 00:20:17.960
คือหนึ่งตัวจริงๆ อ่ะ WebAssembly เนี่ยมันเป็นท่า

00:20:18.159 --> 00:20:19.397
มันเป็นท่าปะกาวแล้วกัน

00:20:19.480 --> 00:20:22.117
คือมันจะเป็นเคสที่ว่า มันมีสักอย่างอ่ะ

00:20:22.200 --> 00:20:24.836
ที่แบบต้องการให้มันใช้กันได้ทั่วๆ กันน่ะ

00:20:24.919 --> 00:20:27.836
แต่ว่าคือไอ้คนใช้อ่ะ มันดันอยู่คนละภาษา

00:20:27.919 --> 00:20:29.397
อยู่กับคนละ ecosystem เงี้ย

00:20:29.480 --> 00:20:31.557
คือเหมือนสภาพว่าเหมือนที่แบบบางทีอ่ะ

00:20:31.640 --> 00:20:34.557
ถ้าเกิดเราจะคุย low-level มากๆ เราต้องใช้ภาษา C

00:20:34.640 --> 00:20:37.437
แต่ปัญหาก็คือ แต่คือเราอยู่ Go เราอยู่ Rust อยู่ Node

00:20:37.520 --> 00:20:39.397
เพราะงั้นคือเราก็ต้องเหมือนกับหาทางปะกาว

00:20:39.480 --> 00:20:42.039
ให้แบบอะไรก็ได้คือ ไปเรียก C มาให้ได้แล้วกัน

00:20:42.440 --> 00:20:43.357
แต่ว่าเรามาต้องเป็น C

00:20:43.440 --> 00:20:45.279
เพราะว่ามีแต่ C คุยกับมันรู้เรื่องอย่างเงี้ยเป็นต้น

00:20:45.679 --> 00:20:47.039
เพราะงั้นคือมันเลยเป็นเคสที่ว่า

00:20:47.480 --> 00:20:51.836
อะไรที่เป็นเคสที่ว่าคือมันต้องใช้กันหลายที่อ่ะ

00:20:51.919 --> 00:20:54.479
แต่ว่าคือไม่ได้มีแต่ front-end ใช้อ่ะ ประมาณนั้น

00:20:54.600 --> 00:20:56.997
มันก็เลยควรจะเอาไป port อะไรเป็น Wasm

00:20:57.080 --> 00:21:01.237
แล้วก็เรียกอีกทีนึงเป็นเหมือนกับเป็น foreign object อ่ะ

00:21:01.320 --> 00:21:04.720
ที่ให้ตัวหน้าบ้านอ่ะ ไปเรียกอีกทีนึงประมาณนั้น

00:21:04.880 --> 00:21:05.956
ส่วนในเรื่องของ SEO เนี่ย

00:21:06.039 --> 00:21:07.277
จริงๆ คือคิดว่าไม่เกี่ยวกัน

00:21:07.360 --> 00:21:10.877
เพราะว่า Wasm ก็คือปั้นออกมาเป็น binary Wasm แล้วกัน

00:21:10.960 --> 00:21:14.120
เพราะงั้นคือ น่าจะไม่ได้มีความเกี่ยวข้องอะไรกับ SEO

00:21:15.679 --> 00:21:17.397
คือที่ผมหมายถึงคือแบบ

00:21:17.480 --> 00:21:20.301
สมมติจะทำแบบทั้งเว็บ ทาง front-end อ่ะ

00:21:20.384 --> 00:21:21.196
เป็น WebAssembly เลย

00:21:21.279 --> 00:21:24.117
เพราะว่าเหมือนผมเคยใช้บางที่อ่ะ

00:21:24.200 --> 00:21:26.440
ที่เป็นแบบเหมือน front-end ที่เป็น WebAssembly

00:21:26.600 --> 00:21:27.200
เลยอ่ะครับ

00:21:27.480 --> 00:21:29.317
คือสมมติถ้าแบบอยากทำทั้งก้อนนั้นน่ะ

00:21:29.400 --> 00:21:32.037
เป็นอย่างนั้น พอมีทางที่จะเป็นไปได้มั้ย

00:21:32.120 --> 00:21:36.279
จริงๆ ถ้าเกิดมี มันจะมี Rust framework ตัวนึงค่ะ

00:21:36.400 --> 00:21:38.196
egui มั้ง ถ้าจำไม่ผิดนะ

00:21:38.279 --> 00:21:40.237
ตัวเนี้ยก็คือ มันจะเป็น UI framework

00:21:40.320 --> 00:21:41.437
ที่เราก็ใช้ Rust เขียนนั่นแหละ

00:21:41.520 --> 00:21:44.677
แต่ว่าเวลามันปั้นออกมาค่ะ แล้วเวลามันทำ deploy อ่ะ

00:21:44.760 --> 00:21:47.481
คือมันสามารถปั้นออกมาเป็น WebAssembly

00:21:47.679 --> 00:21:48.960
แล้วก็ไป deploy ท่านั้นได้

00:21:49.120 --> 00:21:52.080
ถ้าเกิดเป็นของ Go ก็จะมีตัว fyne มั้ง

00:21:52.840 --> 00:21:54.237
จำชื่อไม่ได้ f อะไรสักอย่างนึงก็แหละ

00:21:54.320 --> 00:21:55.956
อันนั้นก็คือทำเป็น front-end

00:21:56.039 --> 00:21:57.836
แล้วก็ปั้นออกมาเป็น Wasm ได้เหมือนกัน

00:21:57.919 --> 00:21:59.517
แต่ว่าจะมีข้อเสียนะ

00:21:59.600 --> 00:22:02.877
คือ Wasm ทั้งก้อนที่เป็น front-end น่ะ

00:22:02.960 --> 00:22:04.317
มันจะช้าแบบเต่าเลย

00:22:04.400 --> 00:22:07.640
ก็คือแบบนั่ง initial ร่างกายมันคือแบบรอแบบวิสัยเลยอ่ะ

00:22:07.799 --> 00:22:08.757
เพราะงั้นคืออันนี้ไม่แนะนำ

00:22:08.840 --> 00:22:11.637
อีกอย่างนึงคือ อาจจะหาคนมาทำต่อแล้วก็ maintain ยาก

00:22:11.720 --> 00:22:14.076
แล้วก็พอมันไม่ได้เป็น plain text น่ะ

00:22:14.159 --> 00:22:17.440
มันจะมี overhead ในการที่มันนั่งเหมือนกับ parse อะไร

00:22:17.720 --> 00:22:19.440
เพราะงั้นคือถ้าเกิดเป็นเว็บที่

00:22:19.679 --> 00:22:21.120
ถ้าเกิดเป็น caller ที่เค้า

00:22:21.320 --> 00:22:22.677
เหมือนกับไม่ได้ทำให้มันดัก

00:22:22.760 --> 00:22:25.517
แล้วมันสามารถคุยกับไฟล์ WebAssembly ได้

00:22:25.600 --> 00:22:26.437
อาจจะเหนื่อยหน่อยประมาณนั้น

00:22:26.520 --> 00:22:27.037
ซึ่งไม่แนะนำ

00:22:27.120 --> 00:22:30.557
คือจริงๆ ถ้าเกิดเป็น condition ที่ว่าเป็น front-end

00:22:30.640 --> 00:22:31.476
เลยอ่ะ อย่างเงี้ย

00:22:31.559 --> 00:22:34.800
จะไม่แนะนำให้ทำทั้งก้อนเป็น WebAssembly ไม่แนะนำ

00:22:35.400 --> 00:22:36.599
ก็คือจะให้เป็นบางส่วน

00:22:36.720 --> 00:22:38.180
อาจจะแบบเรียก iframe เป็น WebAssembly

00:22:38.300 --> 00:22:39.440
อย่างนั้นใช่มั้ยครับ

00:22:39.640 --> 00:22:40.117
ใช่เหมือนกัน

00:22:40.200 --> 00:22:45.397
คืออะไรก็ตามที่คิดว่าเขียนเองใน Node แล้วมันเขียนยาก

00:22:45.480 --> 00:22:47.760
ไปเขียนภาษาอื่นแล้วก็ปั้นมาง่ายกว่า

00:22:47.880 --> 00:22:51.277
หรือเป็น function core logic ที่ mobile ก็ต้องใช้

00:22:51.360 --> 00:22:53.240
desktop ก็ต้องใช้ web ก็ต้องใช้อะไรอย่างเงี้ยเป็นต้น

00:22:53.360 --> 00:22:54.596
แทนที่จะไป implement ใหม่ทุกรอบ

00:22:54.679 --> 00:22:55.960
ก็คือทำเป็นกองกลางไปเลย

00:22:57.840 --> 00:22:58.599
ขอบคุณครับ

00:23:01.559 --> 00:23:05.000
พี่กานครับ ถือว่าเป็น meaningful question รึเปล่าครับผม

00:23:05.840 --> 00:23:07.476
ถือว่าคำถามดีนะคะ

00:23:07.559 --> 00:23:09.200
อยากแจกมั้ยครับ อยากแจกมั้ย

00:23:11.039 --> 00:23:14.397
อ้อ อ่าแล้วมีเหมือนเค้าจะสละสิทธิ์เลยนะครับผม

00:23:14.480 --> 00:23:15.716
แต่เค้าจะไม่ได้รับสละนะครับ

00:23:15.799 --> 00:23:18.280
มีใครมีคำถามเพิ่มเติมมั้ยครับผม

00:23:19.960 --> 00:23:22.476
มีมั้ยครับ มีนะครับ

00:23:22.559 --> 00:23:22.879
ครับ

00:23:29.000 --> 00:23:29.560
ได้ครับ

00:23:30.960 --> 00:23:34.117
โอเคครับ อยากถามเกี่ยวกับ use case

00:23:34.200 --> 00:23:37.797
ที่เราควรจะเลือกใช้ Wasm นะครับ

00:23:37.880 --> 00:23:41.320
เพราะว่าอย่างในบางเคสก็ ตอนนี้ยังนึกไม่ออกว่า

00:23:41.919 --> 00:23:45.280
ถ้าจะต้องไปใช้ Wasm เนี่ย จะใช้ในกรณีใดบ้าง

00:23:45.640 --> 00:23:50.560
นอกจากพวกที่มันเป็น computing intensive นะครับ

00:23:51.640 --> 00:23:54.039
หรือว่า แล้วก็อีกอย่างนึงก็คือว่า

00:23:54.240 --> 00:23:56.000
เรามีหลักในการเลือกยังไงบ้างว่า

00:23:56.200 --> 00:23:59.080
เคสเนี้ย native Node.js มัน work อยู่แล้ว

00:23:59.200 --> 00:24:00.999
แทนที่มันจะต้องไปเขียนเป็น Wasm

00:24:01.480 --> 00:24:04.600
หรือเคสเนี้ย Node.js มันเกินกำลังละ

00:24:05.159 --> 00:24:06.836
มันควรจะต้องไปใช้ Wasm แทนอ่ะครับ

00:24:06.919 --> 00:24:08.437
อ่า โอเคค่ะ มี 2 คำถามนะ

00:24:08.520 --> 00:24:11.357
ก็คือ 1 ก็คือสลับ workload intensive อะไรเงี้ย

00:24:11.440 --> 00:24:14.677
จริงๆ มองว่างี้ค่ะ คือในอะไรก็ตาม Wasm อ่ะ

00:24:14.760 --> 00:24:17.476
คือมันผ่านตัวแปลภาษามาแล้วรอบนึง

00:24:17.559 --> 00:24:18.956
เพราะงั้นคือยังไงมันก็ช้ากว่าอยู่แล้วแหละ

00:24:19.039 --> 00:24:21.680
เพราะงั้นคือถ้าเกิดต้องการอะไรที่มันไว

00:24:21.799 --> 00:24:24.840
หรือ intensive อ่ะ จะไม่แนะนำให้แต่ Wasm เลย

00:24:25.240 --> 00:24:27.880
แต่ว่า Wasm เนี่ยมันจะมีข้อดีตรงที่ว่าคือ

00:24:28.200 --> 00:24:30.277
เอางี้ Wasm อ่ะ มันจะดันช้ากว่าชาวบ้านนะ

00:24:30.360 --> 00:24:31.557
แน่นอนยังไงก็ช้ากว่า

00:24:31.640 --> 00:24:33.960
แต่ว่ามันจะมีข้อดีตรงที่ว่า

00:24:34.440 --> 00:24:35.760
คือถ้าเกิดเป็นอย่างเคส

00:24:35.880 --> 00:24:38.596
ตัวอย่างก็คือเป็น product Google Earth ของ Google

00:24:38.679 --> 00:24:42.357
ที่เค้าต้อง deliver และ deploy หลาย platform

00:24:42.440 --> 00:24:44.917
เช่น มันก็จะมี Google Earth บน web บน mobile

00:24:45.000 --> 00:24:46.757
ที่เป็น Android แล้วก็ iOS

00:24:46.840 --> 00:24:47.917
แล้วก็จะมีบน desktop

00:24:48.000 --> 00:24:50.277
ซึ่งก็เป็น desktop ทั้ง Windows Mac Linux

00:24:50.360 --> 00:24:50.997
อะไรพวกเนี้ย

00:24:51.080 --> 00:24:54.037
ซึ่งมันจะมี core logic บางอย่างเหมือนกันอยู่ในนั้น

00:24:54.120 --> 00:24:57.960
แต่ว่าคือเราก็รู้กันว่า Android ใช้ Kotlin

00:24:58.120 --> 00:24:59.520
หรือ Java เขียนใช่มั้ย

00:24:59.640 --> 00:25:00.880
แล้ว iOS ก็ใช้ Swift

00:25:01.480 --> 00:25:04.600
บน Windows ก็อะไรก็ไม่รู้

00:25:04.799 --> 00:25:06.839
หรืออาจจะเป็น Electron ก็ได้ ง่ายๆ หน่อยใช่มั้ย

00:25:07.159 --> 00:25:09.437
หรือถ้าเกิดเป็น Mac เป็น macOS app

00:25:09.520 --> 00:25:12.199
ก็อาจจะเป็น Swift หรือ Electron ก็ได้ถ้าเกิดหน้ามืดหน่อย

00:25:12.360 --> 00:25:15.600
Linux ก็ GTK อะไรก็ว่ากันไป

00:25:15.960 --> 00:25:19.277
คือเพราะงั้นคือถ้าเกิดว่าเราต้องไปใช้ tool แยก

00:25:19.360 --> 00:25:21.196
ในการที่ implement core logic เนี่ย

00:25:21.279 --> 00:25:23.716
มันจะกลายเป็นงานถึกมากๆ

00:25:23.799 --> 00:25:25.596
เพราะว่าคือ logic แบบเดียวกัน

00:25:25.679 --> 00:25:27.639
คือต้อง implement ประมาณ 3-4 ทีมพร้อมกันน่ะ

00:25:27.880 --> 00:25:29.600
เพราะงั้นคือตรงเนี้ยถ้าเกิดว่าเราสามารถ

00:25:29.919 --> 00:25:32.039
extract core logic ออกมาเป็น Wasm ได้

00:25:32.240 --> 00:25:34.917
เนี่ยมันสามารถทำให้ใครก็ตามที่อยู่ไหนก็ไม่รู้

00:25:35.000 --> 00:25:36.476
แต่ว่าเราเรียกไปใช้ได้เลย

00:25:36.559 --> 00:25:39.397
โดยที่ไม่ต้องมีการ reimplement logic ใหม่

00:25:39.480 --> 00:25:42.039
ในภาษาปลายทาง มันจะเป็นเคสนี้มากกว่าค่ะ

00:25:42.720 --> 00:25:44.000
เอ่อ ก็คือว่าหมายความว่า

00:25:44.200 --> 00:25:47.716
อะไรที่เรา ที่มันจะเป็น multi-platform มากๆ เนี่ย

00:25:47.799 --> 00:25:49.316
Wasm จะเป็นตัวเลือกที่ดี

00:25:49.399 --> 00:25:49.877
ถูกต้องค่ะ

00:25:49.960 --> 00:25:53.357
คือเราก็แค่ทำหน้ากาก interface แต่ละ platform แยกไว้

00:25:53.440 --> 00:25:56.437
แต่ว่าตัวไส้กองกลางคือเราก็มาจิ้ม Wasm ทีเดียวเลยจบ

00:25:56.520 --> 00:25:58.877
ไม่ต้องไปนั่ง implement แยกในแต่ละที่เอง

00:25:58.960 --> 00:26:02.596
โอเคครับ ขอบคุณครับ น่าจะเคลียร์ละ

00:26:02.679 --> 00:26:03.520
ขอบคุณนะครับ

00:26:03.760 --> 00:26:09.517
ทีนี้ถึงช่วงเวลายากนะครับ

00:26:09.600 --> 00:26:12.076
อยากจะให้ อยากมีคำถามเพิ่มเติมมั้ยนะครับ

00:26:12.159 --> 00:26:14.719
ถามก่อน ก่อนที่เราจะเริ่มแจกตัวนะครับ

00:26:16.760 --> 00:26:19.440
งั้นเดี๋ยวขอให้พี่กานคิดดีกว่าว่า

00:26:20.399 --> 00:26:23.437
จะเริ่มคิดหนักกันใช่มั้ยเปล่า เพราะอยากแจก

00:26:23.520 --> 00:26:24.717
จะเป็นใครดีนะครับ อ่ะให้คุณซื้อ

00:26:24.800 --> 00:26:27.559
โอเคครับผม

00:26:28.960 --> 00:26:31.920
ขอ congratulations นะครับสำหรับ

00:26:32.799 --> 00:26:35.040
1 year license นะครับผม ครับผม

00:26:37.080 --> 00:26:38.720
เดี๋ยว year ที่ 2 ต้องซื้อเองนะครับ

00:26:40.360 --> 00:26:42.359
ครับ ขอบคุณพี่กานมากเลยครับ พี่
